/*
 *	autogen/server/zone/Zone.cpp generated by engine3 IDL compiler 0.70
 */

#include "Zone.h"

#include "server/zone/QuadTree.h"

#include "server/zone/QuadTreeEntry.h"

#include "server/zone/ZoneProcessServer.h"

#include "server/zone/objects/area/ActiveArea.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/managers/planet/PlanetManager.h"

#include "server/zone/managers/creature/CreatureManager.h"

#include "server/zone/managers/gcw/GCWManager.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/objects/region/CityRegion.h"

#include "server/zone/objects/pathfinding/NavArea.h"

/*
 *	ZoneStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 2833757774,RPC_FINALIZE__,RPC_GETNEARESTPLANETARYOBJECT__SCENEOBJECT_STRING_,RPC_INITIALIZEPRIVATEDATA__,RPC_CREATECONTAINERCOMPONENT__,RPC_UPDATEACTIVEAREAS__TANGIBLEOBJECT_,RPC_STARTMANAGERS__,RPC_STOPMANAGERS__,RPC_CLEARZONE__,RPC_GETHEIGHT__FLOAT_FLOAT_,RPC_GETHEIGHTNOCACHE__FLOAT_FLOAT_,RPC_ADDSCENEOBJECT__SCENEOBJECT_,RPC_ADDCITYREGIONTOUPDATE__CITYREGION_,RPC_UPDATECITYREGIONS__,RPC_SENDMAPLOCATIONSTO__CREATUREOBJECT_,RPC_DROPSCENEOBJECT__SCENEOBJECT_,RPC_GETPLANETMANAGER__,RPC_GETZONESERVER__,RPC_GETCREATUREMANAGER__,RPC_GETGCWMANAGER__,RPC_GETGALACTICTIME__,RPC_HASMANAGERSSTARTED__,RPC_ISZONECLEARED__,RPC_GETSPAWNEDAIAGENTS__,RPC_GETMINX__,RPC_GETMAXX__,RPC_GETMINY__,RPC_GETMAXY__,RPC_GETBOUNDINGRADIUS__,RPC_REGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_,RPC_UNREGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_,RPC_OBJECTISVALIDPLANETARYMAPPERFORMANCELOCATION__SCENEOBJECT_,RPC_ISOBJECTREGISTEREDWITHPLANETARYMAP__SCENEOBJECT_,RPC_UPDATEPLANETARYMAPICON__SCENEOBJECT_BYTE_,RPC_GETZONENAME__,RPC_GETZONECRC__,RPC_SETPLANETCHATROOM__CHATROOM_,RPC_GETPLANETCHATROOM__};

Zone::Zone(ZoneProcessServer* processor, const String& zoneName) : SceneObject(DummyConstructorParameter::instance()) {
	ZoneImplementation* _implementation = new ZoneImplementation(processor, zoneName);
	_impl = _implementation;
	_implementation->_initializeImplementation();
	_impl->_setStub(this);
	_setClassName("Zone");
}

Zone::Zone(DummyConstructorParameter* param) : SceneObject(param) {
	_setClassName("Zone");
}

Zone::~Zone() {
}



void Zone::initializeTransientMembers() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

Reference<SceneObject* > Zone::getNearestPlanetaryObject(SceneObject* object, const String& mapObjectLocationType) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNEARESTPLANETARYOBJECT__SCENEOBJECT_STRING_);
		method.addObjectParameter(object);
		method.addAsciiParameter(mapObjectLocationType);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getNearestPlanetaryObject(object, mapObjectLocationType);
	}
}

void Zone::initializePrivateData() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEPRIVATEDATA__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializePrivateData();
	}
}

QuadTree* Zone::getRegionTree() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getRegionTree();
	}
}

int Zone::getInRangeSolidObjects(float x, float y, float range, SortedVector<ManagedReference<QuadTreeEntry* > >* objects, bool readLockZone) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInRangeSolidObjects(x, y, range, objects, readLockZone);
	}
}

int Zone::getInRangeObjects(float x, float y, float range, SortedVector<ManagedReference<QuadTreeEntry* > >* objects, bool readLockZone, bool includeBuildingObjects) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInRangeObjects(x, y, range, objects, readLockZone, includeBuildingObjects);
	}
}

int Zone::getInRangeObjects(float x, float y, float range, InRangeObjectsVector* objects, bool readLockZone, bool includeBuildingObjects) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInRangeObjects(x, y, range, objects, readLockZone, includeBuildingObjects);
	}
}

void Zone::createContainerComponent() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECONTAINERCOMPONENT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->createContainerComponent();
	}
}

int Zone::getInRangeActiveAreas(float x, float y, SortedVector<ManagedReference<ActiveArea* > >* objects, bool readLockZone) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInRangeActiveAreas(x, y, objects, readLockZone);
	}
}

int Zone::getInRangeActiveAreas(float x, float y, ActiveAreasVector* objects, bool readLockZone) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInRangeActiveAreas(x, y, objects, readLockZone);
	}
}

int Zone::getInRangeNavMeshes(float x, float y, SortedVector<ManagedReference<NavArea* > >* objects, bool readLockZone) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInRangeNavMeshes(x, y, objects, readLockZone);
	}
}

int Zone::getInRangeActiveAreas(float x, float y, float range, SortedVector<ManagedReference<ActiveArea* > >* objects, bool readLockZone) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInRangeActiveAreas(x, y, range, objects, readLockZone);
	}
}

int Zone::getInRangeActiveAreas(float x, float y, float range, ActiveAreasVector* objects, bool readLockZone) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInRangeActiveAreas(x, y, range, objects, readLockZone);
	}
}

SortedVector<ManagedReference<SceneObject* > > Zone::getPlanetaryObjectList(const String& mapObjectLocationType) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPlanetaryObjectList(mapObjectLocationType);
	}
}

void Zone::insert(QuadTreeEntry* entry) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->insert(entry);
	}
}

void Zone::remove(QuadTreeEntry* entry) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->remove(entry);
	}
}

void Zone::update(QuadTreeEntry* entry) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->update(entry);
	}
}

void Zone::inRange(QuadTreeEntry* entry, float range) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->inRange(entry, range);
	}
}

void Zone::updateActiveAreas(TangibleObject* tano) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEACTIVEAREAS__TANGIBLEOBJECT_);
		method.addObjectParameter(tano);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateActiveAreas(tano);
	}
}

void Zone::startManagers() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTMANAGERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->startManagers();
	}
}

void Zone::stopManagers() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPMANAGERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->stopManagers();
	}
}

void Zone::clearZone() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARZONE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearZone();
	}
}

float Zone::getHeight(float x, float y) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEIGHT__FLOAT_FLOAT_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHeight(x, y);
	}
}

float Zone::getHeightNoCache(float x, float y) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEIGHTNOCACHE__FLOAT_FLOAT_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHeightNoCache(x, y);
	}
}

void Zone::addSceneObject(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSCENEOBJECT__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((object == NULL) || object->isLockedByCurrentThread());
		_implementation->addSceneObject(object);
	}
}

void Zone::addCityRegionToUpdate(CityRegion* city) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCITYREGIONTOUPDATE__CITYREGION_);
		method.addObjectParameter(city);

		method.executeWithVoidReturn();
	} else {
		_implementation->addCityRegionToUpdate(city);
	}
}

void Zone::updateCityRegions() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATECITYREGIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateCityRegions();
	}
}

void Zone::sendMapLocationsTo(CreatureObject* player) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDMAPLOCATIONSTO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendMapLocationsTo(player);
	}
}

void Zone::dropSceneObject(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DROPSCENEOBJECT__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((object == NULL) || object->isLockedByCurrentThread());
		_implementation->dropSceneObject(object);
	}
}

PlanetManager* Zone::getPlanetManager() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLANETMANAGER__);

		return static_cast<PlanetManager*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getPlanetManager();
	}
}

ZoneServer* Zone::getZoneServer() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETZONESERVER__);

		return static_cast<ZoneServer*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getZoneServer();
	}
}

CreatureManager* Zone::getCreatureManager() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATUREMANAGER__);

		return static_cast<CreatureManager*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getCreatureManager();
	}
}

GCWManager* Zone::getGCWManager() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGCWMANAGER__);

		return static_cast<GCWManager*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getGCWManager();
	}
}

unsigned long long Zone::getGalacticTime() const {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGALACTICTIME__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getGalacticTime();
	}
}

bool Zone::hasManagersStarted() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASMANAGERSSTARTED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasManagersStarted();
	}
}

bool Zone::isZoneCleared() const {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISZONECLEARED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isZoneCleared();
	}
}

int Zone::getSpawnedAiAgents() const {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPAWNEDAIAGENTS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSpawnedAiAgents();
	}
}

float Zone::getMinX() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINX__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMinX();
	}
}

float Zone::getMaxX() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXX__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxX();
	}
}

float Zone::getMinY() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMinY();
	}
}

float Zone::getMaxY() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxY();
	}
}

bool Zone::isWithinBoundaries(const Vector3& position) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->isWithinBoundaries(position);
	}
}

float Zone::getBoundingRadius() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBOUNDINGRADIUS__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getBoundingRadius();
	}
}

void Zone::registerObjectWithPlanetaryMap(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->registerObjectWithPlanetaryMap(object);
	}
}

void Zone::unregisterObjectWithPlanetaryMap(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNREGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->unregisterObjectWithPlanetaryMap(object);
	}
}

bool Zone::objectIsValidPlanetaryMapPerformanceLocation(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_OBJECTISVALIDPLANETARYMAPPERFORMANCELOCATION__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->objectIsValidPlanetaryMapPerformanceLocation(object);
	}
}

bool Zone::isObjectRegisteredWithPlanetaryMap(SceneObject* object) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOBJECTREGISTEREDWITHPLANETARYMAP__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isObjectRegisteredWithPlanetaryMap(object);
	}
}

void Zone::updatePlanetaryMapIcon(SceneObject* object, byte icon) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPLANETARYMAPICON__SCENEOBJECT_BYTE_);
		method.addObjectParameter(object);
		method.addByteParameter(icon);

		method.executeWithVoidReturn();
	} else {
		_implementation->updatePlanetaryMapIcon(object, icon);
	}
}

String Zone::getZoneName() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETZONENAME__);

		String _return_getZoneName;
		method.executeWithAsciiReturn(_return_getZoneName);
		return _return_getZoneName;
	} else {
		return _implementation->getZoneName();
	}
}

unsigned int Zone::getZoneCRC() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETZONECRC__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getZoneCRC();
	}
}

void Zone::setPlanetChatRoom(ChatRoom* room) {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPLANETCHATROOM__CHATROOM_);
		method.addObjectParameter(room);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPlanetChatRoom(room);
	}
}

ChatRoom* Zone::getPlanetChatRoom() {
	ZoneImplementation* _implementation = static_cast<ZoneImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLANETCHATROOM__);

		return static_cast<ChatRoom*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getPlanetChatRoom();
	}
}

DistributedObjectServant* Zone::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* Zone::_getImplementationForRead() const {
	return _impl;
}

void Zone::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ZoneImplementation
 */

ZoneImplementation::ZoneImplementation(DummyConstructorParameter* param) : SceneObjectImplementation(param) {
	_initializeImplementation();
}


ZoneImplementation::~ZoneImplementation() {
	ZoneImplementation::finalize();
}


void ZoneImplementation::_initializeImplementation() {
	_setClassHelper(ZoneHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ZoneImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<Zone*>(stub);
	SceneObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ZoneImplementation::_getStub() {
	return _this.get();
}

ZoneImplementation::operator const Zone*() {
	return _this.get();
}

void ZoneImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ZoneImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ZoneImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ZoneImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ZoneImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ZoneImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ZoneImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ZoneImplementation::_serializationHelperMethod() {
	SceneObjectImplementation::_serializationHelperMethod();

	_setClassName("Zone");

}

void ZoneImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ZoneImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ZoneImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xa762ac22: //Zone.zoneName
		TypeInfo<String >::parseFromBinaryStream(&zoneName, stream);
		return true;

	case 0xd9ac1ed3: //Zone.zoneCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&zoneCRC, stream);
		return true;

	case 0x7b0557ae: //Zone.regionTree
		TypeInfo<QuadTreeReference >::parseFromBinaryStream(&regionTree, stream);
		return true;

	case 0x623385b4: //Zone.quadTree
		TypeInfo<QuadTreeReference >::parseFromBinaryStream(&quadTree, stream);
		return true;

	case 0x883bb6d6: //Zone.spawnedAiAgents
		TypeInfo<AtomicInteger >::parseFromBinaryStream(&spawnedAiAgents, stream);
		return true;

	}

	return false;
}

void ZoneImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ZoneImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ZoneImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xa762ac22; //Zone.zoneName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&zoneName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd9ac1ed3; //Zone.zoneCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&zoneCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7b0557ae; //Zone.regionTree
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<QuadTreeReference >::toBinaryStream(&regionTree, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x623385b4; //Zone.quadTree
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<QuadTreeReference >::toBinaryStream(&quadTree, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x883bb6d6; //Zone.spawnedAiAgents
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AtomicInteger >::toBinaryStream(&spawnedAiAgents, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

QuadTree* ZoneImplementation::getRegionTree() {
	// server/zone/Zone.idl():  		return regionTree.get();
	return (&regionTree)->get();
}

void ZoneImplementation::addCityRegionToUpdate(CityRegion* city) {
	// server/zone/Zone.idl():  		cityRegionUpdateVector.put(city);
	(&cityRegionUpdateVector)->put(city);
}

PlanetManager* ZoneImplementation::getPlanetManager() {
	// server/zone/Zone.idl():  		return planetManager;
	return planetManager;
}

ZoneServer* ZoneImplementation::getZoneServer() {
	// server/zone/Zone.idl():  		return server;
	return server;
}

CreatureManager* ZoneImplementation::getCreatureManager() {
	// server/zone/Zone.idl():  		return creatureManager;
	return creatureManager;
}

GCWManager* ZoneImplementation::getGCWManager() {
	// server/zone/Zone.idl():  		return planetManager.getGCWManager();
	return planetManager->getGCWManager();
}

unsigned long long ZoneImplementation::getGalacticTime() const{
	// server/zone/Zone.idl():  		return galacticTime.miliDifference() / 1000;
	return (&galacticTime)->miliDifference() / 1000;
}

bool ZoneImplementation::hasManagersStarted() {
	// server/zone/Zone.idl():  		return managersStarted.get();
	return (&managersStarted)->get();
}

bool ZoneImplementation::isZoneCleared() const{
	// server/zone/Zone.idl():  		return zoneCleared;
	return zoneCleared;
}

int ZoneImplementation::getSpawnedAiAgents() const{
	// server/zone/Zone.idl():  		return spawnedAiAgents.get();
	return (&spawnedAiAgents)->get();
}

String ZoneImplementation::getZoneName() {
	// server/zone/Zone.idl():  		return zoneName;
	return zoneName;
}

unsigned int ZoneImplementation::getZoneCRC() {
	// server/zone/Zone.idl():  		return zoneCRC;
	return zoneCRC;
}

void ZoneImplementation::setPlanetChatRoom(ChatRoom* room) {
	// server/zone/Zone.idl():  		planetChatRoom = room;
	planetChatRoom = room;
}

ChatRoom* ZoneImplementation::getPlanetChatRoom() {
	// server/zone/Zone.idl():  		return planetChatRoom;
	return planetChatRoom;
}

/*
 *	ZoneAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ZoneAdapter::ZoneAdapter(Zone* obj) : SceneObjectAdapter(obj) {
}

void ZoneAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_GETNEARESTPLANETARYOBJECT__SCENEOBJECT_STRING_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			 String mapObjectLocationType; inv->getAsciiParameter(mapObjectLocationType);
			
			DistributedObject* _m_res = getNearestPlanetaryObject(object, mapObjectLocationType);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_INITIALIZEPRIVATEDATA__:
		{
			
			initializePrivateData();
			
		}
		break;
	case RPC_CREATECONTAINERCOMPONENT__:
		{
			
			createContainerComponent();
			
		}
		break;
	case RPC_UPDATEACTIVEAREAS__TANGIBLEOBJECT_:
		{
			TangibleObject* tano = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			updateActiveAreas(tano);
			
		}
		break;
	case RPC_STARTMANAGERS__:
		{
			
			startManagers();
			
		}
		break;
	case RPC_STOPMANAGERS__:
		{
			
			stopManagers();
			
		}
		break;
	case RPC_CLEARZONE__:
		{
			
			clearZone();
			
		}
		break;
	case RPC_GETHEIGHT__FLOAT_FLOAT_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			
			float _m_res = getHeight(x, y);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHEIGHTNOCACHE__FLOAT_FLOAT_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			
			float _m_res = getHeightNoCache(x, y);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ADDSCENEOBJECT__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addSceneObject(object);
			
		}
		break;
	case RPC_ADDCITYREGIONTOUPDATE__CITYREGION_:
		{
			CityRegion* city = static_cast<CityRegion*>(inv->getObjectParameter());
			
			addCityRegionToUpdate(city);
			
		}
		break;
	case RPC_UPDATECITYREGIONS__:
		{
			
			updateCityRegions();
			
		}
		break;
	case RPC_SENDMAPLOCATIONSTO__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendMapLocationsTo(player);
			
		}
		break;
	case RPC_DROPSCENEOBJECT__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			dropSceneObject(object);
			
		}
		break;
	case RPC_GETPLANETMANAGER__:
		{
			
			DistributedObject* _m_res = getPlanetManager();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETZONESERVER__:
		{
			
			DistributedObject* _m_res = getZoneServer();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETCREATUREMANAGER__:
		{
			
			DistributedObject* _m_res = getCreatureManager();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETGCWMANAGER__:
		{
			
			DistributedObject* _m_res = getGCWManager();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETGALACTICTIME__:
		{
			
			unsigned long long _m_res = getGalacticTime();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_HASMANAGERSSTARTED__:
		{
			
			bool _m_res = hasManagersStarted();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISZONECLEARED__:
		{
			
			bool _m_res = isZoneCleared();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSPAWNEDAIAGENTS__:
		{
			
			int _m_res = getSpawnedAiAgents();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMINX__:
		{
			
			float _m_res = getMinX();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETMAXX__:
		{
			
			float _m_res = getMaxX();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETMINY__:
		{
			
			float _m_res = getMinY();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETMAXY__:
		{
			
			float _m_res = getMaxY();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBOUNDINGRADIUS__:
		{
			
			float _m_res = getBoundingRadius();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_REGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			registerObjectWithPlanetaryMap(object);
			
		}
		break;
	case RPC_UNREGISTEROBJECTWITHPLANETARYMAP__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			unregisterObjectWithPlanetaryMap(object);
			
		}
		break;
	case RPC_OBJECTISVALIDPLANETARYMAPPERFORMANCELOCATION__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = objectIsValidPlanetaryMapPerformanceLocation(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISOBJECTREGISTEREDWITHPLANETARYMAP__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = isObjectRegisteredWithPlanetaryMap(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_UPDATEPLANETARYMAPICON__SCENEOBJECT_BYTE_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			byte icon = inv->getByteParameter();
			
			updatePlanetaryMapIcon(object, icon);
			
		}
		break;
	case RPC_GETZONENAME__:
		{
			
			String _m_res = getZoneName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETZONECRC__:
		{
			
			unsigned int _m_res = getZoneCRC();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETPLANETCHATROOM__CHATROOM_:
		{
			ChatRoom* room = static_cast<ChatRoom*>(inv->getObjectParameter());
			
			setPlanetChatRoom(room);
			
		}
		break;
	case RPC_GETPLANETCHATROOM__:
		{
			
			DistributedObject* _m_res = getPlanetChatRoom();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	default:
		SceneObjectAdapter::invokeMethod(methid, inv);
	}
}

void ZoneAdapter::initializeTransientMembers() {
	(static_cast<Zone*>(stub))->initializeTransientMembers();
}

void ZoneAdapter::finalize() {
	(static_cast<Zone*>(stub))->finalize();
}

Reference<SceneObject* > ZoneAdapter::getNearestPlanetaryObject(SceneObject* object, const String& mapObjectLocationType) {
	return (static_cast<Zone*>(stub))->getNearestPlanetaryObject(object, mapObjectLocationType);
}

void ZoneAdapter::initializePrivateData() {
	(static_cast<Zone*>(stub))->initializePrivateData();
}

void ZoneAdapter::createContainerComponent() {
	(static_cast<Zone*>(stub))->createContainerComponent();
}

void ZoneAdapter::updateActiveAreas(TangibleObject* tano) {
	(static_cast<Zone*>(stub))->updateActiveAreas(tano);
}

void ZoneAdapter::startManagers() {
	(static_cast<Zone*>(stub))->startManagers();
}

void ZoneAdapter::stopManagers() {
	(static_cast<Zone*>(stub))->stopManagers();
}

void ZoneAdapter::clearZone() {
	(static_cast<Zone*>(stub))->clearZone();
}

float ZoneAdapter::getHeight(float x, float y) {
	return (static_cast<Zone*>(stub))->getHeight(x, y);
}

float ZoneAdapter::getHeightNoCache(float x, float y) {
	return (static_cast<Zone*>(stub))->getHeightNoCache(x, y);
}

void ZoneAdapter::addSceneObject(SceneObject* object) {
	(static_cast<Zone*>(stub))->addSceneObject(object);
}

void ZoneAdapter::addCityRegionToUpdate(CityRegion* city) {
	(static_cast<Zone*>(stub))->addCityRegionToUpdate(city);
}

void ZoneAdapter::updateCityRegions() {
	(static_cast<Zone*>(stub))->updateCityRegions();
}

void ZoneAdapter::sendMapLocationsTo(CreatureObject* player) {
	(static_cast<Zone*>(stub))->sendMapLocationsTo(player);
}

void ZoneAdapter::dropSceneObject(SceneObject* object) {
	(static_cast<Zone*>(stub))->dropSceneObject(object);
}

PlanetManager* ZoneAdapter::getPlanetManager() {
	return (static_cast<Zone*>(stub))->getPlanetManager();
}

ZoneServer* ZoneAdapter::getZoneServer() {
	return (static_cast<Zone*>(stub))->getZoneServer();
}

CreatureManager* ZoneAdapter::getCreatureManager() {
	return (static_cast<Zone*>(stub))->getCreatureManager();
}

GCWManager* ZoneAdapter::getGCWManager() {
	return (static_cast<Zone*>(stub))->getGCWManager();
}

unsigned long long ZoneAdapter::getGalacticTime() const {
	return (static_cast<Zone*>(stub))->getGalacticTime();
}

bool ZoneAdapter::hasManagersStarted() {
	return (static_cast<Zone*>(stub))->hasManagersStarted();
}

bool ZoneAdapter::isZoneCleared() const {
	return (static_cast<Zone*>(stub))->isZoneCleared();
}

int ZoneAdapter::getSpawnedAiAgents() const {
	return (static_cast<Zone*>(stub))->getSpawnedAiAgents();
}

float ZoneAdapter::getMinX() {
	return (static_cast<Zone*>(stub))->getMinX();
}

float ZoneAdapter::getMaxX() {
	return (static_cast<Zone*>(stub))->getMaxX();
}

float ZoneAdapter::getMinY() {
	return (static_cast<Zone*>(stub))->getMinY();
}

float ZoneAdapter::getMaxY() {
	return (static_cast<Zone*>(stub))->getMaxY();
}

float ZoneAdapter::getBoundingRadius() {
	return (static_cast<Zone*>(stub))->getBoundingRadius();
}

void ZoneAdapter::registerObjectWithPlanetaryMap(SceneObject* object) {
	(static_cast<Zone*>(stub))->registerObjectWithPlanetaryMap(object);
}

void ZoneAdapter::unregisterObjectWithPlanetaryMap(SceneObject* object) {
	(static_cast<Zone*>(stub))->unregisterObjectWithPlanetaryMap(object);
}

bool ZoneAdapter::objectIsValidPlanetaryMapPerformanceLocation(SceneObject* object) {
	return (static_cast<Zone*>(stub))->objectIsValidPlanetaryMapPerformanceLocation(object);
}

bool ZoneAdapter::isObjectRegisteredWithPlanetaryMap(SceneObject* object) {
	return (static_cast<Zone*>(stub))->isObjectRegisteredWithPlanetaryMap(object);
}

void ZoneAdapter::updatePlanetaryMapIcon(SceneObject* object, byte icon) {
	(static_cast<Zone*>(stub))->updatePlanetaryMapIcon(object, icon);
}

String ZoneAdapter::getZoneName() {
	return (static_cast<Zone*>(stub))->getZoneName();
}

unsigned int ZoneAdapter::getZoneCRC() {
	return (static_cast<Zone*>(stub))->getZoneCRC();
}

void ZoneAdapter::setPlanetChatRoom(ChatRoom* room) {
	(static_cast<Zone*>(stub))->setPlanetChatRoom(room);
}

ChatRoom* ZoneAdapter::getPlanetChatRoom() {
	return (static_cast<Zone*>(stub))->getPlanetChatRoom();
}

/*
 *	ZoneHelper
 */

ZoneHelper* ZoneHelper::staticInitializer = ZoneHelper::instance();

ZoneHelper::ZoneHelper() {
	className = "Zone";

	Core::getObjectBroker()->registerClass(className, this);
}

void ZoneHelper::finalizeHelper() {
	ZoneHelper::finalize();
}

DistributedObject* ZoneHelper::instantiateObject() {
	return new Zone(DummyConstructorParameter::instance());
}

DistributedObjectServant* ZoneHelper::instantiateServant() {
	return new ZoneImplementation(DummyConstructorParameter::instance());
}

DistributedObjectPOD* ZoneHelper::instantiatePOD() {
	return new ZonePOD();
}

DistributedObjectAdapter* ZoneHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ZoneAdapter(static_cast<Zone*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	ZonePOD
 */

ZonePOD::~ZonePOD() {
	finalize();
}

ZonePOD::ZonePOD(void) {
	_className = "Zone";
}


void ZonePOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ZonePOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ZonePOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (zoneName) {
	_nameHashCode = 0xa762ac22; //Zone.zoneName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&zoneName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (zoneCRC) {
	_nameHashCode = 0xd9ac1ed3; //Zone.zoneCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&zoneCRC.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (regionTree) {
	_nameHashCode = 0x7b0557ae; //Zone.regionTree
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<QuadTreeReference >::toBinaryStream(&regionTree.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (quadTree) {
	_nameHashCode = 0x623385b4; //Zone.quadTree
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<QuadTreeReference >::toBinaryStream(&quadTree.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spawnedAiAgents) {
	_nameHashCode = 0x883bb6d6; //Zone.spawnedAiAgents
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AtomicInteger >::toBinaryStream(&spawnedAiAgents.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool ZonePOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xa762ac22: //Zone.zoneName
		{
			String _mnzoneName;
			TypeInfo<String >::parseFromBinaryStream(&_mnzoneName, stream);
			zoneName = std::move(_mnzoneName);
		}
		return true;

	case 0xd9ac1ed3: //Zone.zoneCRC
		{
			unsigned int _mnzoneCRC;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnzoneCRC, stream);
			zoneCRC = std::move(_mnzoneCRC);
		}
		return true;

	case 0x7b0557ae: //Zone.regionTree
		{
			QuadTreeReference _mnregionTree;
			TypeInfo<QuadTreeReference >::parseFromBinaryStream(&_mnregionTree, stream);
			regionTree = std::move(_mnregionTree);
		}
		return true;

	case 0x623385b4: //Zone.quadTree
		{
			QuadTreeReference _mnquadTree;
			TypeInfo<QuadTreeReference >::parseFromBinaryStream(&_mnquadTree, stream);
			quadTree = std::move(_mnquadTree);
		}
		return true;

	case 0x883bb6d6: //Zone.spawnedAiAgents
		{
			AtomicInteger _mnspawnedAiAgents;
			TypeInfo<AtomicInteger >::parseFromBinaryStream(&_mnspawnedAiAgents, stream);
			spawnedAiAgents = std::move(_mnspawnedAiAgents);
		}
		return true;

	}

	return false;
}

void ZonePOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ZonePOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ZonePOD::writeObjectCompact(ObjectOutputStream* stream) {
	SceneObjectPOD::writeObjectCompact(stream);

	TypeInfo<String >::toBinaryStream(&zoneName.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&zoneCRC.value(), stream);

	TypeInfo<QuadTreeReference >::toBinaryStream(&regionTree.value(), stream);

	TypeInfo<QuadTreeReference >::toBinaryStream(&quadTree.value(), stream);

	TypeInfo<AtomicInteger >::toBinaryStream(&spawnedAiAgents.value(), stream);


}

