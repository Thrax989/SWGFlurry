/*
 *	autogen/server/zone/objects/player/sessions/PlaceStructureSession.cpp generated by engine3 IDL compiler 0.70
 */

#include "PlaceStructureSession.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/tangible/deed/structure/StructureDeed.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/area/ActiveArea.h"

/*
 *	PlaceStructureSessionStub
 */

enum {RPC_INITIALIZESESSION__ = 497288393,RPC_REMOVETEMPORARYNOBUILDZONE__,RPC_CONSTRUCTSTRUCTURE__FLOAT_FLOAT_INT_,RPC_COMPLETESESSION__,RPC_CANCELSESSION__,RPC_CLEARSESSION__};

PlaceStructureSession::PlaceStructureSession(CreatureObject* creature, StructureDeed* deed) : Facade(DummyConstructorParameter::instance()) {
	PlaceStructureSessionImplementation* _implementation = new PlaceStructureSessionImplementation(creature, deed);
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("PlaceStructureSession");
}

PlaceStructureSession::PlaceStructureSession(DummyConstructorParameter* param) : Facade(param) {
	_setClassName("PlaceStructureSession");
}

PlaceStructureSession::~PlaceStructureSession() {
}



int PlaceStructureSession::initializeSession() {
	PlaceStructureSessionImplementation* _implementation = static_cast<PlaceStructureSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZESESSION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->initializeSession();
	}
}

void PlaceStructureSession::placeTemporaryNoBuildZone(const SharedStructureObjectTemplate* serverTemplate) {
	PlaceStructureSessionImplementation* _implementation = static_cast<PlaceStructureSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->placeTemporaryNoBuildZone(serverTemplate);
	}
}

void PlaceStructureSession::removeTemporaryNoBuildZone() {
	PlaceStructureSessionImplementation* _implementation = static_cast<PlaceStructureSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVETEMPORARYNOBUILDZONE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeTemporaryNoBuildZone();
	}
}

int PlaceStructureSession::constructStructure(float x, float y, int angle) {
	PlaceStructureSessionImplementation* _implementation = static_cast<PlaceStructureSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONSTRUCTSTRUCTURE__FLOAT_FLOAT_INT_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addSignedIntParameter(angle);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->constructStructure(x, y, angle);
	}
}

int PlaceStructureSession::completeSession() {
	PlaceStructureSessionImplementation* _implementation = static_cast<PlaceStructureSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETESESSION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->completeSession();
	}
}

int PlaceStructureSession::cancelSession() {
	PlaceStructureSessionImplementation* _implementation = static_cast<PlaceStructureSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCELSESSION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->cancelSession();
	}
}

int PlaceStructureSession::clearSession() {
	PlaceStructureSessionImplementation* _implementation = static_cast<PlaceStructureSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSESSION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->clearSession();
	}
}

DistributedObjectServant* PlaceStructureSession::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* PlaceStructureSession::_getImplementationForRead() const {
	return _impl;
}

void PlaceStructureSession::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	PlaceStructureSessionImplementation
 */

PlaceStructureSessionImplementation::PlaceStructureSessionImplementation(DummyConstructorParameter* param) : FacadeImplementation(param) {
	_initializeImplementation();
}


PlaceStructureSessionImplementation::~PlaceStructureSessionImplementation() {
}


void PlaceStructureSessionImplementation::finalize() {
}

void PlaceStructureSessionImplementation::_initializeImplementation() {
	_setClassHelper(PlaceStructureSessionHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void PlaceStructureSessionImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<PlaceStructureSession*>(stub);
	FacadeImplementation::_setStub(stub);
}

DistributedObjectStub* PlaceStructureSessionImplementation::_getStub() {
	return _this.get();
}

PlaceStructureSessionImplementation::operator const PlaceStructureSession*() {
	return _this.get();
}

void PlaceStructureSessionImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void PlaceStructureSessionImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void PlaceStructureSessionImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void PlaceStructureSessionImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void PlaceStructureSessionImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void PlaceStructureSessionImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void PlaceStructureSessionImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void PlaceStructureSessionImplementation::_serializationHelperMethod() {
	FacadeImplementation::_serializationHelperMethod();

	_setClassName("PlaceStructureSession");

}

void PlaceStructureSessionImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PlaceStructureSessionImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool PlaceStructureSessionImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (FacadeImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xac923358: //PlaceStructureSession.creatureObject
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&creatureObject, stream);
		return true;

	case 0x4ea10045: //PlaceStructureSession.deedObject
		TypeInfo<ManagedWeakReference<StructureDeed* > >::parseFromBinaryStream(&deedObject, stream);
		return true;

	case 0x7f96ed8: //PlaceStructureSession.positionX
		TypeInfo<float >::parseFromBinaryStream(&positionX, stream);
		return true;

	case 0x338736f: //PlaceStructureSession.positionY
		TypeInfo<float >::parseFromBinaryStream(&positionY, stream);
		return true;

	case 0x26d05024: //PlaceStructureSession.directionAngle
		TypeInfo<int >::parseFromBinaryStream(&directionAngle, stream);
		return true;

	case 0x8c1d0456: //PlaceStructureSession.constructionBarricade
		TypeInfo<ManagedWeakReference<SceneObject* > >::parseFromBinaryStream(&constructionBarricade, stream);
		return true;

	case 0x35b982c3: //PlaceStructureSession.zone
		TypeInfo<ManagedWeakReference<Zone* > >::parseFromBinaryStream(&zone, stream);
		return true;

	case 0x57830721: //PlaceStructureSession.temporaryNoBuildZone
		TypeInfo<ManagedWeakReference<ActiveArea* > >::parseFromBinaryStream(&temporaryNoBuildZone, stream);
		return true;

	}

	return false;
}

void PlaceStructureSessionImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlaceStructureSessionImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlaceStructureSessionImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = FacadeImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xac923358; //PlaceStructureSession.creatureObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&creatureObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4ea10045; //PlaceStructureSession.deedObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<StructureDeed* > >::toBinaryStream(&deedObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7f96ed8; //PlaceStructureSession.positionX
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&positionX, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x338736f; //PlaceStructureSession.positionY
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&positionY, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x26d05024; //PlaceStructureSession.directionAngle
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&directionAngle, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8c1d0456; //PlaceStructureSession.constructionBarricade
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObject* > >::toBinaryStream(&constructionBarricade, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x35b982c3; //PlaceStructureSession.zone
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<Zone* > >::toBinaryStream(&zone, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x57830721; //PlaceStructureSession.temporaryNoBuildZone
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<ActiveArea* > >::toBinaryStream(&temporaryNoBuildZone, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void PlaceStructureSessionImplementation::writeJSON(nlohmann::json& j) {
	FacadeImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["creatureObject"] = creatureObject;

	thisObject["deedObject"] = deedObject;

	thisObject["positionX"] = positionX;

	thisObject["positionY"] = positionY;

	thisObject["directionAngle"] = directionAngle;

	thisObject["constructionBarricade"] = constructionBarricade;

	thisObject["zone"] = zone;

	thisObject["temporaryNoBuildZone"] = temporaryNoBuildZone;

	j["PlaceStructureSession"] = thisObject;
}

PlaceStructureSessionImplementation::PlaceStructureSessionImplementation(CreatureObject* creature, StructureDeed* deed) {
	_initializeImplementation();
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		Logger.setLoggingName("PlaceStructureSession");
	Logger::setLoggingName("PlaceStructureSession");
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		Logger.setLogging(true);
	Logger::setLogging(true);
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		creatureObject = creature;
	creatureObject = creature;
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		deedObject = deed;
	deedObject = deed;
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		zone = creature.getZone();
	zone = creature->getZone();
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		positionX = 0;
	positionX = 0;
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		positionY = 0;
	positionY = 0;
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		directionAngle = 0;
	directionAngle = 0;
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		constructionBarricade = null;
	constructionBarricade = NULL;
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		temporaryNoBuildZone = null;
	temporaryNoBuildZone = NULL;
}

int PlaceStructureSessionImplementation::initializeSession() {
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		return 0;
	return 0;
}

int PlaceStructureSessionImplementation::cancelSession() {
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		CreatureObject creature = creatureObject;
	ManagedReference<CreatureObject* > creature = creatureObject;
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		return 
	if (creature != NULL)	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  			creature.dropActiveSession(SessionFacadeType.PLACESTRUCTURE);
	creature->dropActiveSession(SessionFacadeType::PLACESTRUCTURE);
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		return 0;
	return 0;
}

int PlaceStructureSessionImplementation::clearSession() {
	// server/zone/objects/player/sessions/PlaceStructureSession.idl():  		return 0;
	return 0;
}

/*
 *	PlaceStructureSessionAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


PlaceStructureSessionAdapter::PlaceStructureSessionAdapter(PlaceStructureSession* obj) : FacadeAdapter(obj) {
}

void PlaceStructureSessionAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZESESSION__:
		{
			
			int _m_res = initializeSession();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_REMOVETEMPORARYNOBUILDZONE__:
		{
			
			removeTemporaryNoBuildZone();
			
		}
		break;
	case RPC_CONSTRUCTSTRUCTURE__FLOAT_FLOAT_INT_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			int angle = inv->getSignedIntParameter();
			
			int _m_res = constructStructure(x, y, angle);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_COMPLETESESSION__:
		{
			
			int _m_res = completeSession();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CANCELSESSION__:
		{
			
			int _m_res = cancelSession();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CLEARSESSION__:
		{
			
			int _m_res = clearSession();
			resp->insertSignedInt(_m_res);
		}
		break;
	default:
		FacadeAdapter::invokeMethod(methid, inv);
	}
}

int PlaceStructureSessionAdapter::initializeSession() {
	return (static_cast<PlaceStructureSession*>(stub))->initializeSession();
}

void PlaceStructureSessionAdapter::removeTemporaryNoBuildZone() {
	(static_cast<PlaceStructureSession*>(stub))->removeTemporaryNoBuildZone();
}

int PlaceStructureSessionAdapter::constructStructure(float x, float y, int angle) {
	return (static_cast<PlaceStructureSession*>(stub))->constructStructure(x, y, angle);
}

int PlaceStructureSessionAdapter::completeSession() {
	return (static_cast<PlaceStructureSession*>(stub))->completeSession();
}

int PlaceStructureSessionAdapter::cancelSession() {
	return (static_cast<PlaceStructureSession*>(stub))->cancelSession();
}

int PlaceStructureSessionAdapter::clearSession() {
	return (static_cast<PlaceStructureSession*>(stub))->clearSession();
}

/*
 *	PlaceStructureSessionHelper
 */

PlaceStructureSessionHelper* PlaceStructureSessionHelper::staticInitializer = PlaceStructureSessionHelper::instance();

PlaceStructureSessionHelper::PlaceStructureSessionHelper() {
	className = "PlaceStructureSession";

	Core::getObjectBroker()->registerClass(className, this);
}

void PlaceStructureSessionHelper::finalizeHelper() {
	PlaceStructureSessionHelper::finalize();
}

DistributedObject* PlaceStructureSessionHelper::instantiateObject() {
	return new PlaceStructureSession(DummyConstructorParameter::instance());
}

DistributedObjectServant* PlaceStructureSessionHelper::instantiateServant() {
	return new PlaceStructureSessionImplementation(DummyConstructorParameter::instance());
}

DistributedObjectPOD* PlaceStructureSessionHelper::instantiatePOD() {
	return new PlaceStructureSessionPOD();
}

DistributedObjectAdapter* PlaceStructureSessionHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new PlaceStructureSessionAdapter(static_cast<PlaceStructureSession*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	PlaceStructureSessionPOD
 */

PlaceStructureSessionPOD::~PlaceStructureSessionPOD() {
}

PlaceStructureSessionPOD::PlaceStructureSessionPOD(void) {
	_className = "PlaceStructureSession";
}


void PlaceStructureSessionPOD::writeJSON(nlohmann::json& j) {
	FacadePOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (creatureObject)
		thisObject["creatureObject"] = creatureObject.value();

	if (deedObject)
		thisObject["deedObject"] = deedObject.value();

	if (positionX)
		thisObject["positionX"] = positionX.value();

	if (positionY)
		thisObject["positionY"] = positionY.value();

	if (directionAngle)
		thisObject["directionAngle"] = directionAngle.value();

	if (constructionBarricade)
		thisObject["constructionBarricade"] = constructionBarricade.value();

	if (zone)
		thisObject["zone"] = zone.value();

	if (temporaryNoBuildZone)
		thisObject["temporaryNoBuildZone"] = temporaryNoBuildZone.value();

	j["PlaceStructureSession"] = thisObject;
}


void PlaceStructureSessionPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlaceStructureSessionPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlaceStructureSessionPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = FacadePOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (creatureObject) {
	_nameHashCode = 0xac923358; //PlaceStructureSession.creatureObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::toBinaryStream(&creatureObject.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (deedObject) {
	_nameHashCode = 0x4ea10045; //PlaceStructureSession.deedObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<StructureDeedPOD* > >::toBinaryStream(&deedObject.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (positionX) {
	_nameHashCode = 0x7f96ed8; //PlaceStructureSession.positionX
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&positionX.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (positionY) {
	_nameHashCode = 0x338736f; //PlaceStructureSession.positionY
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&positionY.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (directionAngle) {
	_nameHashCode = 0x26d05024; //PlaceStructureSession.directionAngle
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&directionAngle.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (constructionBarricade) {
	_nameHashCode = 0x8c1d0456; //PlaceStructureSession.constructionBarricade
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&constructionBarricade.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (zone) {
	_nameHashCode = 0x35b982c3; //PlaceStructureSession.zone
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<ZonePOD* > >::toBinaryStream(&zone.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (temporaryNoBuildZone) {
	_nameHashCode = 0x57830721; //PlaceStructureSession.temporaryNoBuildZone
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<ActiveAreaPOD* > >::toBinaryStream(&temporaryNoBuildZone.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool PlaceStructureSessionPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (FacadePOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xac923358: //PlaceStructureSession.creatureObject
		{
			ManagedWeakReference<CreatureObjectPOD* > _mncreatureObject;
			TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::parseFromBinaryStream(&_mncreatureObject, stream);
			creatureObject = std::move(_mncreatureObject);
		}
		return true;

	case 0x4ea10045: //PlaceStructureSession.deedObject
		{
			ManagedWeakReference<StructureDeedPOD* > _mndeedObject;
			TypeInfo<ManagedWeakReference<StructureDeedPOD* > >::parseFromBinaryStream(&_mndeedObject, stream);
			deedObject = std::move(_mndeedObject);
		}
		return true;

	case 0x7f96ed8: //PlaceStructureSession.positionX
		{
			float _mnpositionX;
			TypeInfo<float >::parseFromBinaryStream(&_mnpositionX, stream);
			positionX = std::move(_mnpositionX);
		}
		return true;

	case 0x338736f: //PlaceStructureSession.positionY
		{
			float _mnpositionY;
			TypeInfo<float >::parseFromBinaryStream(&_mnpositionY, stream);
			positionY = std::move(_mnpositionY);
		}
		return true;

	case 0x26d05024: //PlaceStructureSession.directionAngle
		{
			int _mndirectionAngle;
			TypeInfo<int >::parseFromBinaryStream(&_mndirectionAngle, stream);
			directionAngle = std::move(_mndirectionAngle);
		}
		return true;

	case 0x8c1d0456: //PlaceStructureSession.constructionBarricade
		{
			ManagedWeakReference<SceneObjectPOD* > _mnconstructionBarricade;
			TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::parseFromBinaryStream(&_mnconstructionBarricade, stream);
			constructionBarricade = std::move(_mnconstructionBarricade);
		}
		return true;

	case 0x35b982c3: //PlaceStructureSession.zone
		{
			ManagedWeakReference<ZonePOD* > _mnzone;
			TypeInfo<ManagedWeakReference<ZonePOD* > >::parseFromBinaryStream(&_mnzone, stream);
			zone = std::move(_mnzone);
		}
		return true;

	case 0x57830721: //PlaceStructureSession.temporaryNoBuildZone
		{
			ManagedWeakReference<ActiveAreaPOD* > _mntemporaryNoBuildZone;
			TypeInfo<ManagedWeakReference<ActiveAreaPOD* > >::parseFromBinaryStream(&_mntemporaryNoBuildZone, stream);
			temporaryNoBuildZone = std::move(_mntemporaryNoBuildZone);
		}
		return true;

	}

	return false;
}

void PlaceStructureSessionPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PlaceStructureSessionPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void PlaceStructureSessionPOD::writeObjectCompact(ObjectOutputStream* stream) {
	FacadePOD::writeObjectCompact(stream);

	TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::toBinaryStream(&creatureObject.value(), stream);

	TypeInfo<ManagedWeakReference<StructureDeedPOD* > >::toBinaryStream(&deedObject.value(), stream);

	TypeInfo<float >::toBinaryStream(&positionX.value(), stream);

	TypeInfo<float >::toBinaryStream(&positionY.value(), stream);

	TypeInfo<int >::toBinaryStream(&directionAngle.value(), stream);

	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&constructionBarricade.value(), stream);

	TypeInfo<ManagedWeakReference<ZonePOD* > >::toBinaryStream(&zone.value(), stream);

	TypeInfo<ManagedWeakReference<ActiveAreaPOD* > >::toBinaryStream(&temporaryNoBuildZone.value(), stream);


}

