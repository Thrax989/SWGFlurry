/*
 *	autogen/server/zone/objects/auction/AuctionItem.cpp generated by engine3 IDL compiler 0.70
 */

#include "AuctionItem.h"

#include "server/zone/objects/scene/SceneObject.h"

/*
 *	AuctionItemStub
 */

enum {RPC_COMPARETO__AUCTIONITEM_ = 276266056,RPC_NOTIFYLOADFROMDATABASE__,RPC_SETVENDORID__LONG_,RPC_SETITEMNAME__STRING_,RPC_SETITEMDESCRIPTION__STRING_,RPC_SETPRICE__INT_,RPC_SETPROXY__INT_,RPC_SETAUCTIONEDITEMOBJECTID__LONG_,RPC_SETITEMTYPE__INT_,RPC_SETOWNERID__LONG_,RPC_SETOFFERTOID__LONG_,RPC_SETBIDDERNAME__STRING_,RPC_SETOWNERNAME__STRING_,RPC_SETAUCTION__BOOL_,RPC_SETAUCTIONPREMIUM__,RPC_CLEARAUCTIONWITHDRAW__,RPC_SETONBAZAAR__BOOL_,RPC_SETEXPIRETIME__INT_,RPC_SETBUYERID__LONG_,RPC_SETSTATUS__INT_,RPC_ISONBAZAAR__,RPC_ISAUCTION__,RPC_GETSTATUS__,RPC_GETVENDORID__,RPC_GETAUCTIONEDITEMOBJECTID__,RPC_GETOWNERID__,RPC_GETOFFERTOID__,RPC_SETVENDORUID__STRING_,RPC_GETVENDORUID__,RPC_GETOWNERNAME__,RPC_GETITEMNAME__,RPC_GETEXPIRETIME__,RPC_GETPRICE__,RPC_GETPROXY__,RPC_GETITEMTYPE__,RPC_GETBUYERID__,RPC_GETBIDDERNAME__,RPC_GETITEMDESCRIPTION__,RPC_GETAUCTIONOPTIONS__,RPC_ISPREMIUMAUCTION__,RPC_ISOWNER__SCENEOBJECT_,RPC_ISAUCTIONOBJECT__,RPC_SETSIZE__INT_,RPC_GETSIZE__,RPC_GETCRATEDITEMTYPE__,RPC_SETCRATEDITEMTYPE__INT_,RPC_ISFACTORYCRATE__,RPC_SETFACTORYCRATE__BOOL_,RPC_SETUPDATED__BOOL_,RPC_ISUPDATED__};

AuctionItem::AuctionItem(unsigned long long objectid) : ManagedObject(DummyConstructorParameter::instance()) {
	AuctionItemImplementation* _implementation = new AuctionItemImplementation(objectid);
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("AuctionItem");
}

AuctionItem::AuctionItem(DummyConstructorParameter* param) : ManagedObject(param) {
	_setClassName("AuctionItem");
}

AuctionItem::~AuctionItem() {
}



int AuctionItem::compareTo(AuctionItem* obj) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPARETO__AUCTIONITEM_);
		method.addObjectParameter(obj);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->compareTo(obj);
	}
}

void AuctionItem::notifyLoadFromDatabase() {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

void AuctionItem::setVendorID(unsigned long long val) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETVENDORID__LONG_);
		method.addUnsignedLongParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setVendorID(val);
	}
}

void AuctionItem::setItemName(const String& name) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETITEMNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setItemName(name);
	}
}

void AuctionItem::setItemDescription(const String& descr) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETITEMDESCRIPTION__STRING_);
		method.addAsciiParameter(descr);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setItemDescription(descr);
	}
}

void AuctionItem::setPrice(int newPrice) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPRICE__INT_);
		method.addSignedIntParameter(newPrice);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPrice(newPrice);
	}
}

void AuctionItem::setProxy(int newProxy) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPROXY__INT_);
		method.addSignedIntParameter(newProxy);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setProxy(newProxy);
	}
}

void AuctionItem::setAuctionedItemObjectID(unsigned long long objectID) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAUCTIONEDITEMOBJECTID__LONG_);
		method.addUnsignedLongParameter(objectID);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAuctionedItemObjectID(objectID);
	}
}

void AuctionItem::setItemType(int type) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETITEMTYPE__INT_);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setItemType(type);
	}
}

void AuctionItem::setOwnerID(unsigned long long ownerObjectID) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOWNERID__LONG_);
		method.addUnsignedLongParameter(ownerObjectID);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setOwnerID(ownerObjectID);
	}
}

void AuctionItem::setOfferToID(unsigned long long vendorOwnerID) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOFFERTOID__LONG_);
		method.addUnsignedLongParameter(vendorOwnerID);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setOfferToID(vendorOwnerID);
	}
}

void AuctionItem::setBidderName(const String& name) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBIDDERNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBidderName(name);
	}
}

void AuctionItem::setOwnerName(const String& name) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOWNERNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setOwnerName(name);
	}
}

void AuctionItem::setAuction(bool isAuction) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAUCTION__BOOL_);
		method.addBooleanParameter(isAuction);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAuction(isAuction);
	}
}

void AuctionItem::setAuctionPremium() {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAUCTIONPREMIUM__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAuctionPremium();
	}
}

void AuctionItem::clearAuctionWithdraw() {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARAUCTIONWITHDRAW__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearAuctionWithdraw();
	}
}

void AuctionItem::setOnBazaar(bool val) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETONBAZAAR__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setOnBazaar(val);
	}
}

void AuctionItem::setExpireTime(int time) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETEXPIRETIME__INT_);
		method.addSignedIntParameter(time);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setExpireTime(time);
	}
}

void AuctionItem::setBuyerID(unsigned long long id) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBUYERID__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBuyerID(id);
	}
}

void AuctionItem::setStatus(int value) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTATUS__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setStatus(value);
	}
}

bool AuctionItem::isOnBazaar() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONBAZAAR__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOnBazaar();
	}
}

bool AuctionItem::isAuction() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAUCTION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAuction();
	}
}

int AuctionItem::getStatus() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTATUS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getStatus();
	}
}

unsigned long long AuctionItem::getVendorID() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVENDORID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getVendorID();
	}
}

unsigned long long AuctionItem::getAuctionedItemObjectID() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAUCTIONEDITEMOBJECTID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getAuctionedItemObjectID();
	}
}

unsigned long long AuctionItem::getOwnerID() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOWNERID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getOwnerID();
	}
}

unsigned long long AuctionItem::getOfferToID() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOFFERTOID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getOfferToID();
	}
}

void AuctionItem::setVendorUID(const String& uid) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETVENDORUID__STRING_);
		method.addAsciiParameter(uid);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setVendorUID(uid);
	}
}

const String AuctionItem::getVendorUID() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVENDORUID__);

		String _return_getVendorUID;
		method.executeWithAsciiReturn(_return_getVendorUID);
		return _return_getVendorUID;
	} else {
		return _implementation->getVendorUID();
	}
}

String AuctionItem::getOwnerName() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOWNERNAME__);

		String _return_getOwnerName;
		method.executeWithAsciiReturn(_return_getOwnerName);
		return _return_getOwnerName;
	} else {
		return _implementation->getOwnerName();
	}
}

String AuctionItem::getItemName() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETITEMNAME__);

		String _return_getItemName;
		method.executeWithAsciiReturn(_return_getItemName);
		return _return_getItemName;
	} else {
		return _implementation->getItemName();
	}
}

int AuctionItem::getExpireTime() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETEXPIRETIME__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getExpireTime();
	}
}

int AuctionItem::getPrice() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPRICE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPrice();
	}
}

int AuctionItem::getProxy() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPROXY__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getProxy();
	}
}

int AuctionItem::getItemType() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETITEMTYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getItemType();
	}
}

unsigned long long AuctionItem::getBuyerID() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBUYERID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getBuyerID();
	}
}

String AuctionItem::getBidderName() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBIDDERNAME__);

		String _return_getBidderName;
		method.executeWithAsciiReturn(_return_getBidderName);
		return _return_getBidderName;
	} else {
		return _implementation->getBidderName();
	}
}

String AuctionItem::getItemDescription() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETITEMDESCRIPTION__);

		String _return_getItemDescription;
		method.executeWithAsciiReturn(_return_getItemDescription);
		return _return_getItemDescription;
	} else {
		return _implementation->getItemDescription();
	}
}

int AuctionItem::getAuctionOptions() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAUCTIONOPTIONS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAuctionOptions();
	}
}

bool AuctionItem::isPremiumAuction() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPREMIUMAUCTION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPremiumAuction();
	}
}

bool AuctionItem::isOwner(SceneObject* player) const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOWNER__SCENEOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOwner(player);
	}
}

bool AuctionItem::isAuctionObject() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAUCTIONOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAuctionObject();
	}
}

void AuctionItem::setSize(int s) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSIZE__INT_);
		method.addSignedIntParameter(s);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSize(s);
	}
}

int AuctionItem::getSize() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSize();
	}
}

int AuctionItem::getCratedItemType() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCRATEDITEMTYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCratedItemType();
	}
}

void AuctionItem::setCratedItemType(int type) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCRATEDITEMTYPE__INT_);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCratedItemType(type);
	}
}

bool AuctionItem::isFactoryCrate() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFACTORYCRATE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFactoryCrate();
	}
}

void AuctionItem::setFactoryCrate(bool crate) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFACTORYCRATE__BOOL_);
		method.addBooleanParameter(crate);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setFactoryCrate(crate);
	}
}

void AuctionItem::setUpdated(bool val) {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETUPDATED__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setUpdated(val);
	}
}

bool AuctionItem::isUpdated() const {
	AuctionItemImplementation* _implementation = static_cast<AuctionItemImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUPDATED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isUpdated();
	}
}

DistributedObjectServant* AuctionItem::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* AuctionItem::_getImplementationForRead() const {
	return _impl;
}

void AuctionItem::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	AuctionItemImplementation
 */

AuctionItemImplementation::AuctionItemImplementation(DummyConstructorParameter* param) : ManagedObjectImplementation(param) {
	_initializeImplementation();
}


AuctionItemImplementation::~AuctionItemImplementation() {
}


void AuctionItemImplementation::finalize() {
}

void AuctionItemImplementation::_initializeImplementation() {
	_setClassHelper(AuctionItemHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void AuctionItemImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<AuctionItem*>(stub);
	ManagedObjectImplementation::_setStub(stub);
}

DistributedObjectStub* AuctionItemImplementation::_getStub() {
	return _this.get();
}

AuctionItemImplementation::operator const AuctionItem*() {
	return _this.get();
}

void AuctionItemImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void AuctionItemImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void AuctionItemImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void AuctionItemImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void AuctionItemImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void AuctionItemImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void AuctionItemImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void AuctionItemImplementation::_serializationHelperMethod() {
	ManagedObjectImplementation::_serializationHelperMethod();

	_setClassName("AuctionItem");

}

void AuctionItemImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(AuctionItemImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool AuctionItemImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ManagedObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xd3721eb7: //AuctionItem.vendorID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&vendorID, stream);
		return true;

	case 0xc1c9c55b: //AuctionItem.auctionedItemObjectID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&auctionedItemObjectID, stream);
		return true;

	case 0x5f6b8f6: //AuctionItem.itemType
		TypeInfo<int >::parseFromBinaryStream(&itemType, stream);
		return true;

	case 0x87fa0477: //AuctionItem.size
		TypeInfo<int >::parseFromBinaryStream(&size, stream);
		return true;

	case 0x4bd0ce0c: //AuctionItem.ownerID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&ownerID, stream);
		return true;

	case 0x7fe78407: //AuctionItem.ownerName
		TypeInfo<String >::parseFromBinaryStream(&ownerName, stream);
		return true;

	case 0xac7a216a: //AuctionItem.bidderName
		TypeInfo<String >::parseFromBinaryStream(&bidderName, stream);
		return true;

	case 0xbb302a62: //AuctionItem.offerToID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&offerToID, stream);
		return true;

	case 0x553415e6: //AuctionItem.vuid
		TypeInfo<String >::parseFromBinaryStream(&vuid, stream);
		return true;

	case 0xa979b1fa: //AuctionItem.itemName
		TypeInfo<String >::parseFromBinaryStream(&itemName, stream);
		return true;

	case 0xa772caca: //AuctionItem.itemDescription
		TypeInfo<String >::parseFromBinaryStream(&itemDescription, stream);
		return true;

	case 0xc8730753: //AuctionItem.price
		TypeInfo<int >::parseFromBinaryStream(&price, stream);
		return true;

	case 0x50632d68: //AuctionItem.proxyBid
		TypeInfo<int >::parseFromBinaryStream(&proxyBid, stream);
		return true;

	case 0xc91826a0: //AuctionItem.auction
		TypeInfo<bool >::parseFromBinaryStream(&auction, stream);
		return true;

	case 0x3a2982b9: //AuctionItem.status
		TypeInfo<int >::parseFromBinaryStream(&status, stream);
		return true;

	case 0xcb2cdb14: //AuctionItem.onBazaar
		TypeInfo<bool >::parseFromBinaryStream(&onBazaar, stream);
		return true;

	case 0xee273fee: //AuctionItem.isCrate
		TypeInfo<bool >::parseFromBinaryStream(&isCrate, stream);
		return true;

	case 0x8c9f3fa0: //AuctionItem.cratedItemType
		TypeInfo<int >::parseFromBinaryStream(&cratedItemType, stream);
		return true;

	case 0x435fe0: //AuctionItem.buyerID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&buyerID, stream);
		return true;

	case 0x396a8462: //AuctionItem.expireTime
		TypeInfo<unsigned int >::parseFromBinaryStream(&expireTime, stream);
		return true;

	case 0xddd43d5a: //AuctionItem.updated
		TypeInfo<bool >::parseFromBinaryStream(&updated, stream);
		return true;

	case 0x75922636: //AuctionItem.auctionOptions
		TypeInfo<int >::parseFromBinaryStream(&auctionOptions, stream);
		return true;

	}

	return false;
}

void AuctionItemImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = AuctionItemImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int AuctionItemImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ManagedObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xd3721eb7; //AuctionItem.vendorID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&vendorID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc1c9c55b; //AuctionItem.auctionedItemObjectID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&auctionedItemObjectID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5f6b8f6; //AuctionItem.itemType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&itemType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x87fa0477; //AuctionItem.size
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&size, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4bd0ce0c; //AuctionItem.ownerID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&ownerID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7fe78407; //AuctionItem.ownerName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&ownerName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xac7a216a; //AuctionItem.bidderName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&bidderName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbb302a62; //AuctionItem.offerToID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&offerToID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x553415e6; //AuctionItem.vuid
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&vuid, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa979b1fa; //AuctionItem.itemName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&itemName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa772caca; //AuctionItem.itemDescription
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&itemDescription, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc8730753; //AuctionItem.price
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&price, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x50632d68; //AuctionItem.proxyBid
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&proxyBid, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc91826a0; //AuctionItem.auction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&auction, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3a2982b9; //AuctionItem.status
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&status, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcb2cdb14; //AuctionItem.onBazaar
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&onBazaar, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xee273fee; //AuctionItem.isCrate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&isCrate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8c9f3fa0; //AuctionItem.cratedItemType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&cratedItemType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x435fe0; //AuctionItem.buyerID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&buyerID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x396a8462; //AuctionItem.expireTime
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&expireTime, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xddd43d5a; //AuctionItem.updated
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&updated, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x75922636; //AuctionItem.auctionOptions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&auctionOptions, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void AuctionItemImplementation::writeJSON(nlohmann::json& j) {
	ManagedObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["vendorID"] = vendorID;

	thisObject["auctionedItemObjectID"] = auctionedItemObjectID;

	thisObject["itemType"] = itemType;

	thisObject["size"] = size;

	thisObject["ownerID"] = ownerID;

	thisObject["ownerName"] = ownerName;

	thisObject["bidderName"] = bidderName;

	thisObject["offerToID"] = offerToID;

	thisObject["vuid"] = vuid;

	thisObject["itemName"] = itemName;

	thisObject["itemDescription"] = itemDescription;

	thisObject["price"] = price;

	thisObject["proxyBid"] = proxyBid;

	thisObject["auction"] = auction;

	thisObject["status"] = status;

	thisObject["onBazaar"] = onBazaar;

	thisObject["isCrate"] = isCrate;

	thisObject["cratedItemType"] = cratedItemType;

	thisObject["buyerID"] = buyerID;

	thisObject["expireTime"] = expireTime;

	thisObject["updated"] = updated;

	thisObject["auctionOptions"] = auctionOptions;

	j["AuctionItem"] = thisObject;
}

AuctionItemImplementation::AuctionItemImplementation(unsigned long long objectid) {
	_initializeImplementation();
	// server/zone/objects/auction/AuctionItem.idl():  		auctionedItemObjectID = objectid;
	auctionedItemObjectID = objectid;
	// server/zone/objects/auction/AuctionItem.idl():  		itemType = 0;
	itemType = 0;
	// server/zone/objects/auction/AuctionItem.idl():  		size = 1;
	size = 1;
	// server/zone/objects/auction/AuctionItem.idl():  		ownerID = 0;
	ownerID = 0;
	// server/zone/objects/auction/AuctionItem.idl():  		offerToID = 0;
	offerToID = 0;
	// server/zone/objects/auction/AuctionItem.idl():  		price = 0;
	price = 0;
	// server/zone/objects/auction/AuctionItem.idl():  		proxyBid = 0;
	proxyBid = 0;
	// server/zone/objects/auction/AuctionItem.idl():  		status = FORSALE;
	status = FORSALE;
	// server/zone/objects/auction/AuctionItem.idl():  		auction = true;
	auction = true;
	// server/zone/objects/auction/AuctionItem.idl():  		onBazaar = false;
	onBazaar = false;
	// server/zone/objects/auction/AuctionItem.idl():  		isCrate = false;
	isCrate = false;
	// server/zone/objects/auction/AuctionItem.idl():  		cratedItemType = 0;
	cratedItemType = 0;
	// server/zone/objects/auction/AuctionItem.idl():  		buyerID = 0;
	buyerID = 0;
	// server/zone/objects/auction/AuctionItem.idl():  		expireTime = 0;
	expireTime = 0;
	// server/zone/objects/auction/AuctionItem.idl():  		updated = false;
	updated = false;
	// server/zone/objects/auction/AuctionItem.idl():  		auctionOptions = 0;
	auctionOptions = 0;
}

int AuctionItemImplementation::compareTo(AuctionItem* obj) {
	// server/zone/objects/auction/AuctionItem.idl():  			return 0;
	if (getAuctionedItemObjectID() < obj->getAuctionedItemObjectID())	// server/zone/objects/auction/AuctionItem.idl():  			return 1;
	return 1;

	else 	// server/zone/objects/auction/AuctionItem.idl():  			return 0;
	if (getAuctionedItemObjectID() > obj->getAuctionedItemObjectID())	// server/zone/objects/auction/AuctionItem.idl():  			return -1;
	return -1;

	else 	// server/zone/objects/auction/AuctionItem.idl():  			return 0;
	return 0;
}

void AuctionItemImplementation::setVendorID(unsigned long long val) {
	// server/zone/objects/auction/AuctionItem.idl():  		vendorID = val;
	vendorID = val;
}

void AuctionItemImplementation::setItemName(const String& name) {
	// server/zone/objects/auction/AuctionItem.idl():  		itemName = name;
	itemName = name;
}

void AuctionItemImplementation::setItemDescription(const String& descr) {
	// server/zone/objects/auction/AuctionItem.idl():  		itemDescription = descr;
	itemDescription = descr;
}

void AuctionItemImplementation::setPrice(int newPrice) {
	// server/zone/objects/auction/AuctionItem.idl():  		price = newPrice;
	price = newPrice;
}

void AuctionItemImplementation::setProxy(int newProxy) {
	// server/zone/objects/auction/AuctionItem.idl():  		proxyBid = newProxy;
	proxyBid = newProxy;
}

void AuctionItemImplementation::setAuctionedItemObjectID(unsigned long long objectID) {
	// server/zone/objects/auction/AuctionItem.idl():  		auctionedItemObjectID = objectID;
	auctionedItemObjectID = objectID;
}

void AuctionItemImplementation::setItemType(int type) {
	// server/zone/objects/auction/AuctionItem.idl():  		itemType = type;
	itemType = type;
}

void AuctionItemImplementation::setOwnerID(unsigned long long ownerObjectID) {
	// server/zone/objects/auction/AuctionItem.idl():  		ownerID = ownerObjectID;
	ownerID = ownerObjectID;
}

void AuctionItemImplementation::setOfferToID(unsigned long long vendorOwnerID) {
	// server/zone/objects/auction/AuctionItem.idl():  		offerToID = vendorOwnerID;
	offerToID = vendorOwnerID;
}

void AuctionItemImplementation::setBidderName(const String& name) {
	// server/zone/objects/auction/AuctionItem.idl():  		bidderName = name;
	bidderName = name;
}

void AuctionItemImplementation::setOwnerName(const String& name) {
	// server/zone/objects/auction/AuctionItem.idl():  		ownerName = name;
	ownerName = name;
}

void AuctionItemImplementation::setAuction(bool isAuction) {
	// server/zone/objects/auction/AuctionItem.idl():  		auction = isAuction;
	auction = isAuction;
}

void AuctionItemImplementation::setAuctionPremium() {
	// server/zone/objects/auction/AuctionItem.idl():  		auctionOptions = auctionOptions | OPTION_PREMIUM;
	auctionOptions = auctionOptions | OPTION_PREMIUM;
}

void AuctionItemImplementation::setOnBazaar(bool val) {
	// server/zone/objects/auction/AuctionItem.idl():  		onBazaar = val;
	onBazaar = val;
}

void AuctionItemImplementation::setExpireTime(int time) {
	// server/zone/objects/auction/AuctionItem.idl():  		expireTime = time;
	expireTime = time;
}

void AuctionItemImplementation::setBuyerID(unsigned long long id) {
	// server/zone/objects/auction/AuctionItem.idl():  		buyerID = id;
	buyerID = id;
}

void AuctionItemImplementation::setStatus(int value) {
	// server/zone/objects/auction/AuctionItem.idl():  		status = value;
	status = value;
}

bool AuctionItemImplementation::isOnBazaar() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return onBazaar;
	return onBazaar;
}

bool AuctionItemImplementation::isAuction() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return auction;
	return auction;
}

int AuctionItemImplementation::getStatus() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return status;
	return status;
}

unsigned long long AuctionItemImplementation::getVendorID() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return vendorID;
	return vendorID;
}

unsigned long long AuctionItemImplementation::getAuctionedItemObjectID() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return auctionedItemObjectID;
	return auctionedItemObjectID;
}

unsigned long long AuctionItemImplementation::getOwnerID() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return ownerID;
	return ownerID;
}

unsigned long long AuctionItemImplementation::getOfferToID() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return offerToID;
	return offerToID;
}

void AuctionItemImplementation::setVendorUID(const String& uid) {
	// server/zone/objects/auction/AuctionItem.idl():  		vuid = uid;
	vuid = uid;
}

const String AuctionItemImplementation::getVendorUID() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return vuid;
	return vuid;
}

String AuctionItemImplementation::getOwnerName() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return ownerName;
	return ownerName;
}

String AuctionItemImplementation::getItemName() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return itemName;
	return itemName;
}

int AuctionItemImplementation::getExpireTime() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return expireTime;
	return expireTime;
}

int AuctionItemImplementation::getPrice() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return price;
	return price;
}

int AuctionItemImplementation::getProxy() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return proxyBid;
	return proxyBid;
}

int AuctionItemImplementation::getItemType() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return itemType;
	return itemType;
}

unsigned long long AuctionItemImplementation::getBuyerID() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return buyerID;
	return buyerID;
}

String AuctionItemImplementation::getBidderName() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return bidderName;
	return bidderName;
}

String AuctionItemImplementation::getItemDescription() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return itemDescription;
	return itemDescription;
}

int AuctionItemImplementation::getAuctionOptions() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return auctionOptions;
	return auctionOptions;
}

bool AuctionItemImplementation::isPremiumAuction() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return auctionOptions & OPTION_PREMIUM;
	return auctionOptions & OPTION_PREMIUM;
}

bool AuctionItemImplementation::isOwner(SceneObject* player) const{
	// server/zone/objects/auction/AuctionItem.idl():  		return player.getObjectID() == getOwnerID();
	return player->getObjectID() == getOwnerID();
}

bool AuctionItemImplementation::isAuctionObject() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return true;
	return true;
}

void AuctionItemImplementation::setSize(int s) {
	// server/zone/objects/auction/AuctionItem.idl():  		size = s;
	size = s;
}

int AuctionItemImplementation::getSize() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return size;
	return size;
}

int AuctionItemImplementation::getCratedItemType() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return cratedItemType;
	return cratedItemType;
}

void AuctionItemImplementation::setCratedItemType(int type) {
	// server/zone/objects/auction/AuctionItem.idl():  		cratedItemType = type;
	cratedItemType = type;
}

bool AuctionItemImplementation::isFactoryCrate() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return isCrate;
	return isCrate;
}

void AuctionItemImplementation::setFactoryCrate(bool crate) {
	// server/zone/objects/auction/AuctionItem.idl():  		isCrate = crate;
	isCrate = crate;
}

void AuctionItemImplementation::setUpdated(bool val) {
	// server/zone/objects/auction/AuctionItem.idl():  		updated = val;
	updated = val;
}

bool AuctionItemImplementation::isUpdated() const{
	// server/zone/objects/auction/AuctionItem.idl():  		return updated;
	return updated;
}

/*
 *	AuctionItemAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


AuctionItemAdapter::AuctionItemAdapter(AuctionItem* obj) : ManagedObjectAdapter(obj) {
}

void AuctionItemAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_COMPARETO__AUCTIONITEM_:
		{
			AuctionItem* obj = static_cast<AuctionItem*>(inv->getObjectParameter());
			
			int _m_res = compareTo(obj);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_SETVENDORID__LONG_:
		{
			unsigned long long val = inv->getUnsignedLongParameter();
			
			setVendorID(val);
			
		}
		break;
	case RPC_SETITEMNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setItemName(name);
			
		}
		break;
	case RPC_SETITEMDESCRIPTION__STRING_:
		{
			 String descr; inv->getAsciiParameter(descr);
			
			setItemDescription(descr);
			
		}
		break;
	case RPC_SETPRICE__INT_:
		{
			int newPrice = inv->getSignedIntParameter();
			
			setPrice(newPrice);
			
		}
		break;
	case RPC_SETPROXY__INT_:
		{
			int newProxy = inv->getSignedIntParameter();
			
			setProxy(newProxy);
			
		}
		break;
	case RPC_SETAUCTIONEDITEMOBJECTID__LONG_:
		{
			unsigned long long objectID = inv->getUnsignedLongParameter();
			
			setAuctionedItemObjectID(objectID);
			
		}
		break;
	case RPC_SETITEMTYPE__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			setItemType(type);
			
		}
		break;
	case RPC_SETOWNERID__LONG_:
		{
			unsigned long long ownerObjectID = inv->getUnsignedLongParameter();
			
			setOwnerID(ownerObjectID);
			
		}
		break;
	case RPC_SETOFFERTOID__LONG_:
		{
			unsigned long long vendorOwnerID = inv->getUnsignedLongParameter();
			
			setOfferToID(vendorOwnerID);
			
		}
		break;
	case RPC_SETBIDDERNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setBidderName(name);
			
		}
		break;
	case RPC_SETOWNERNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setOwnerName(name);
			
		}
		break;
	case RPC_SETAUCTION__BOOL_:
		{
			bool isAuction = inv->getBooleanParameter();
			
			setAuction(isAuction);
			
		}
		break;
	case RPC_SETAUCTIONPREMIUM__:
		{
			
			setAuctionPremium();
			
		}
		break;
	case RPC_CLEARAUCTIONWITHDRAW__:
		{
			
			clearAuctionWithdraw();
			
		}
		break;
	case RPC_SETONBAZAAR__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setOnBazaar(val);
			
		}
		break;
	case RPC_SETEXPIRETIME__INT_:
		{
			int time = inv->getSignedIntParameter();
			
			setExpireTime(time);
			
		}
		break;
	case RPC_SETBUYERID__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			setBuyerID(id);
			
		}
		break;
	case RPC_SETSTATUS__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setStatus(value);
			
		}
		break;
	case RPC_ISONBAZAAR__:
		{
			
			bool _m_res = isOnBazaar();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAUCTION__:
		{
			
			bool _m_res = isAuction();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSTATUS__:
		{
			
			int _m_res = getStatus();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETVENDORID__:
		{
			
			unsigned long long _m_res = getVendorID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETAUCTIONEDITEMOBJECTID__:
		{
			
			unsigned long long _m_res = getAuctionedItemObjectID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETOWNERID__:
		{
			
			unsigned long long _m_res = getOwnerID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETOFFERTOID__:
		{
			
			unsigned long long _m_res = getOfferToID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETVENDORUID__STRING_:
		{
			 String uid; inv->getAsciiParameter(uid);
			
			setVendorUID(uid);
			
		}
		break;
	case RPC_GETVENDORUID__:
		{
			
			const String _m_res = getVendorUID();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETOWNERNAME__:
		{
			
			String _m_res = getOwnerName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETITEMNAME__:
		{
			
			String _m_res = getItemName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETEXPIRETIME__:
		{
			
			int _m_res = getExpireTime();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETPRICE__:
		{
			
			int _m_res = getPrice();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETPROXY__:
		{
			
			int _m_res = getProxy();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETITEMTYPE__:
		{
			
			int _m_res = getItemType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBUYERID__:
		{
			
			unsigned long long _m_res = getBuyerID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETBIDDERNAME__:
		{
			
			String _m_res = getBidderName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETITEMDESCRIPTION__:
		{
			
			String _m_res = getItemDescription();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETAUCTIONOPTIONS__:
		{
			
			int _m_res = getAuctionOptions();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISPREMIUMAUCTION__:
		{
			
			bool _m_res = isPremiumAuction();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISOWNER__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = isOwner(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAUCTIONOBJECT__:
		{
			
			bool _m_res = isAuctionObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETSIZE__INT_:
		{
			int s = inv->getSignedIntParameter();
			
			setSize(s);
			
		}
		break;
	case RPC_GETSIZE__:
		{
			
			int _m_res = getSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCRATEDITEMTYPE__:
		{
			
			int _m_res = getCratedItemType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETCRATEDITEMTYPE__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			setCratedItemType(type);
			
		}
		break;
	case RPC_ISFACTORYCRATE__:
		{
			
			bool _m_res = isFactoryCrate();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETFACTORYCRATE__BOOL_:
		{
			bool crate = inv->getBooleanParameter();
			
			setFactoryCrate(crate);
			
		}
		break;
	case RPC_SETUPDATED__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setUpdated(val);
			
		}
		break;
	case RPC_ISUPDATED__:
		{
			
			bool _m_res = isUpdated();
			resp->insertBoolean(_m_res);
		}
		break;
	default:
		ManagedObjectAdapter::invokeMethod(methid, inv);
	}
}

int AuctionItemAdapter::compareTo(AuctionItem* obj) {
	return (static_cast<AuctionItem*>(stub))->compareTo(obj);
}

void AuctionItemAdapter::notifyLoadFromDatabase() {
	(static_cast<AuctionItem*>(stub))->notifyLoadFromDatabase();
}

void AuctionItemAdapter::setVendorID(unsigned long long val) {
	(static_cast<AuctionItem*>(stub))->setVendorID(val);
}

void AuctionItemAdapter::setItemName(const String& name) {
	(static_cast<AuctionItem*>(stub))->setItemName(name);
}

void AuctionItemAdapter::setItemDescription(const String& descr) {
	(static_cast<AuctionItem*>(stub))->setItemDescription(descr);
}

void AuctionItemAdapter::setPrice(int newPrice) {
	(static_cast<AuctionItem*>(stub))->setPrice(newPrice);
}

void AuctionItemAdapter::setProxy(int newProxy) {
	(static_cast<AuctionItem*>(stub))->setProxy(newProxy);
}

void AuctionItemAdapter::setAuctionedItemObjectID(unsigned long long objectID) {
	(static_cast<AuctionItem*>(stub))->setAuctionedItemObjectID(objectID);
}

void AuctionItemAdapter::setItemType(int type) {
	(static_cast<AuctionItem*>(stub))->setItemType(type);
}

void AuctionItemAdapter::setOwnerID(unsigned long long ownerObjectID) {
	(static_cast<AuctionItem*>(stub))->setOwnerID(ownerObjectID);
}

void AuctionItemAdapter::setOfferToID(unsigned long long vendorOwnerID) {
	(static_cast<AuctionItem*>(stub))->setOfferToID(vendorOwnerID);
}

void AuctionItemAdapter::setBidderName(const String& name) {
	(static_cast<AuctionItem*>(stub))->setBidderName(name);
}

void AuctionItemAdapter::setOwnerName(const String& name) {
	(static_cast<AuctionItem*>(stub))->setOwnerName(name);
}

void AuctionItemAdapter::setAuction(bool isAuction) {
	(static_cast<AuctionItem*>(stub))->setAuction(isAuction);
}

void AuctionItemAdapter::setAuctionPremium() {
	(static_cast<AuctionItem*>(stub))->setAuctionPremium();
}

void AuctionItemAdapter::clearAuctionWithdraw() {
	(static_cast<AuctionItem*>(stub))->clearAuctionWithdraw();
}

void AuctionItemAdapter::setOnBazaar(bool val) {
	(static_cast<AuctionItem*>(stub))->setOnBazaar(val);
}

void AuctionItemAdapter::setExpireTime(int time) {
	(static_cast<AuctionItem*>(stub))->setExpireTime(time);
}

void AuctionItemAdapter::setBuyerID(unsigned long long id) {
	(static_cast<AuctionItem*>(stub))->setBuyerID(id);
}

void AuctionItemAdapter::setStatus(int value) {
	(static_cast<AuctionItem*>(stub))->setStatus(value);
}

bool AuctionItemAdapter::isOnBazaar() const {
	return (static_cast<AuctionItem*>(stub))->isOnBazaar();
}

bool AuctionItemAdapter::isAuction() const {
	return (static_cast<AuctionItem*>(stub))->isAuction();
}

int AuctionItemAdapter::getStatus() const {
	return (static_cast<AuctionItem*>(stub))->getStatus();
}

unsigned long long AuctionItemAdapter::getVendorID() const {
	return (static_cast<AuctionItem*>(stub))->getVendorID();
}

unsigned long long AuctionItemAdapter::getAuctionedItemObjectID() const {
	return (static_cast<AuctionItem*>(stub))->getAuctionedItemObjectID();
}

unsigned long long AuctionItemAdapter::getOwnerID() const {
	return (static_cast<AuctionItem*>(stub))->getOwnerID();
}

unsigned long long AuctionItemAdapter::getOfferToID() const {
	return (static_cast<AuctionItem*>(stub))->getOfferToID();
}

void AuctionItemAdapter::setVendorUID(const String& uid) {
	(static_cast<AuctionItem*>(stub))->setVendorUID(uid);
}

const String AuctionItemAdapter::getVendorUID() const {
	return (static_cast<AuctionItem*>(stub))->getVendorUID();
}

String AuctionItemAdapter::getOwnerName() const {
	return (static_cast<AuctionItem*>(stub))->getOwnerName();
}

String AuctionItemAdapter::getItemName() const {
	return (static_cast<AuctionItem*>(stub))->getItemName();
}

int AuctionItemAdapter::getExpireTime() const {
	return (static_cast<AuctionItem*>(stub))->getExpireTime();
}

int AuctionItemAdapter::getPrice() const {
	return (static_cast<AuctionItem*>(stub))->getPrice();
}

int AuctionItemAdapter::getProxy() const {
	return (static_cast<AuctionItem*>(stub))->getProxy();
}

int AuctionItemAdapter::getItemType() const {
	return (static_cast<AuctionItem*>(stub))->getItemType();
}

unsigned long long AuctionItemAdapter::getBuyerID() const {
	return (static_cast<AuctionItem*>(stub))->getBuyerID();
}

String AuctionItemAdapter::getBidderName() const {
	return (static_cast<AuctionItem*>(stub))->getBidderName();
}

String AuctionItemAdapter::getItemDescription() const {
	return (static_cast<AuctionItem*>(stub))->getItemDescription();
}

int AuctionItemAdapter::getAuctionOptions() const {
	return (static_cast<AuctionItem*>(stub))->getAuctionOptions();
}

bool AuctionItemAdapter::isPremiumAuction() const {
	return (static_cast<AuctionItem*>(stub))->isPremiumAuction();
}

bool AuctionItemAdapter::isOwner(SceneObject* player) const {
	return (static_cast<AuctionItem*>(stub))->isOwner(player);
}

bool AuctionItemAdapter::isAuctionObject() const {
	return (static_cast<AuctionItem*>(stub))->isAuctionObject();
}

void AuctionItemAdapter::setSize(int s) {
	(static_cast<AuctionItem*>(stub))->setSize(s);
}

int AuctionItemAdapter::getSize() const {
	return (static_cast<AuctionItem*>(stub))->getSize();
}

int AuctionItemAdapter::getCratedItemType() const {
	return (static_cast<AuctionItem*>(stub))->getCratedItemType();
}

void AuctionItemAdapter::setCratedItemType(int type) {
	(static_cast<AuctionItem*>(stub))->setCratedItemType(type);
}

bool AuctionItemAdapter::isFactoryCrate() const {
	return (static_cast<AuctionItem*>(stub))->isFactoryCrate();
}

void AuctionItemAdapter::setFactoryCrate(bool crate) {
	(static_cast<AuctionItem*>(stub))->setFactoryCrate(crate);
}

void AuctionItemAdapter::setUpdated(bool val) {
	(static_cast<AuctionItem*>(stub))->setUpdated(val);
}

bool AuctionItemAdapter::isUpdated() const {
	return (static_cast<AuctionItem*>(stub))->isUpdated();
}

/*
 *	AuctionItemHelper
 */

AuctionItemHelper* AuctionItemHelper::staticInitializer = AuctionItemHelper::instance();

AuctionItemHelper::AuctionItemHelper() {
	className = "AuctionItem";

	Core::getObjectBroker()->registerClass(className, this);
}

void AuctionItemHelper::finalizeHelper() {
	AuctionItemHelper::finalize();
}

DistributedObject* AuctionItemHelper::instantiateObject() {
	return new AuctionItem(DummyConstructorParameter::instance());
}

DistributedObjectServant* AuctionItemHelper::instantiateServant() {
	return new AuctionItemImplementation(DummyConstructorParameter::instance());
}

DistributedObjectPOD* AuctionItemHelper::instantiatePOD() {
	return new AuctionItemPOD();
}

DistributedObjectAdapter* AuctionItemHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new AuctionItemAdapter(static_cast<AuctionItem*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	AuctionItemPOD
 */

AuctionItemPOD::~AuctionItemPOD() {
}

AuctionItemPOD::AuctionItemPOD(void) {
	_className = "AuctionItem";
}


void AuctionItemPOD::writeJSON(nlohmann::json& j) {
	ManagedObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (vendorID)
		thisObject["vendorID"] = vendorID.value();

	if (auctionedItemObjectID)
		thisObject["auctionedItemObjectID"] = auctionedItemObjectID.value();

	if (itemType)
		thisObject["itemType"] = itemType.value();

	if (size)
		thisObject["size"] = size.value();

	if (ownerID)
		thisObject["ownerID"] = ownerID.value();

	if (ownerName)
		thisObject["ownerName"] = ownerName.value();

	if (bidderName)
		thisObject["bidderName"] = bidderName.value();

	if (offerToID)
		thisObject["offerToID"] = offerToID.value();

	if (vuid)
		thisObject["vuid"] = vuid.value();

	if (itemName)
		thisObject["itemName"] = itemName.value();

	if (itemDescription)
		thisObject["itemDescription"] = itemDescription.value();

	if (price)
		thisObject["price"] = price.value();

	if (proxyBid)
		thisObject["proxyBid"] = proxyBid.value();

	if (auction)
		thisObject["auction"] = auction.value();

	if (status)
		thisObject["status"] = status.value();

	if (onBazaar)
		thisObject["onBazaar"] = onBazaar.value();

	if (isCrate)
		thisObject["isCrate"] = isCrate.value();

	if (cratedItemType)
		thisObject["cratedItemType"] = cratedItemType.value();

	if (buyerID)
		thisObject["buyerID"] = buyerID.value();

	if (expireTime)
		thisObject["expireTime"] = expireTime.value();

	if (updated)
		thisObject["updated"] = updated.value();

	if (auctionOptions)
		thisObject["auctionOptions"] = auctionOptions.value();

	j["AuctionItem"] = thisObject;
}


void AuctionItemPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = AuctionItemPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int AuctionItemPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ManagedObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (vendorID) {
	_nameHashCode = 0xd3721eb7; //AuctionItem.vendorID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&vendorID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (auctionedItemObjectID) {
	_nameHashCode = 0xc1c9c55b; //AuctionItem.auctionedItemObjectID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&auctionedItemObjectID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (itemType) {
	_nameHashCode = 0x5f6b8f6; //AuctionItem.itemType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&itemType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (size) {
	_nameHashCode = 0x87fa0477; //AuctionItem.size
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&size.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (ownerID) {
	_nameHashCode = 0x4bd0ce0c; //AuctionItem.ownerID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&ownerID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (ownerName) {
	_nameHashCode = 0x7fe78407; //AuctionItem.ownerName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&ownerName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (bidderName) {
	_nameHashCode = 0xac7a216a; //AuctionItem.bidderName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&bidderName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (offerToID) {
	_nameHashCode = 0xbb302a62; //AuctionItem.offerToID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&offerToID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (vuid) {
	_nameHashCode = 0x553415e6; //AuctionItem.vuid
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&vuid.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (itemName) {
	_nameHashCode = 0xa979b1fa; //AuctionItem.itemName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&itemName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (itemDescription) {
	_nameHashCode = 0xa772caca; //AuctionItem.itemDescription
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&itemDescription.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (price) {
	_nameHashCode = 0xc8730753; //AuctionItem.price
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&price.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (proxyBid) {
	_nameHashCode = 0x50632d68; //AuctionItem.proxyBid
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&proxyBid.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (auction) {
	_nameHashCode = 0xc91826a0; //AuctionItem.auction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&auction.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (status) {
	_nameHashCode = 0x3a2982b9; //AuctionItem.status
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&status.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (onBazaar) {
	_nameHashCode = 0xcb2cdb14; //AuctionItem.onBazaar
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&onBazaar.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (isCrate) {
	_nameHashCode = 0xee273fee; //AuctionItem.isCrate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&isCrate.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (cratedItemType) {
	_nameHashCode = 0x8c9f3fa0; //AuctionItem.cratedItemType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&cratedItemType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (buyerID) {
	_nameHashCode = 0x435fe0; //AuctionItem.buyerID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&buyerID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (expireTime) {
	_nameHashCode = 0x396a8462; //AuctionItem.expireTime
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&expireTime.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (updated) {
	_nameHashCode = 0xddd43d5a; //AuctionItem.updated
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&updated.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (auctionOptions) {
	_nameHashCode = 0x75922636; //AuctionItem.auctionOptions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&auctionOptions.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool AuctionItemPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ManagedObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xd3721eb7: //AuctionItem.vendorID
		{
			unsigned long long _mnvendorID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnvendorID, stream);
			vendorID = std::move(_mnvendorID);
		}
		return true;

	case 0xc1c9c55b: //AuctionItem.auctionedItemObjectID
		{
			unsigned long long _mnauctionedItemObjectID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnauctionedItemObjectID, stream);
			auctionedItemObjectID = std::move(_mnauctionedItemObjectID);
		}
		return true;

	case 0x5f6b8f6: //AuctionItem.itemType
		{
			int _mnitemType;
			TypeInfo<int >::parseFromBinaryStream(&_mnitemType, stream);
			itemType = std::move(_mnitemType);
		}
		return true;

	case 0x87fa0477: //AuctionItem.size
		{
			int _mnsize;
			TypeInfo<int >::parseFromBinaryStream(&_mnsize, stream);
			size = std::move(_mnsize);
		}
		return true;

	case 0x4bd0ce0c: //AuctionItem.ownerID
		{
			unsigned long long _mnownerID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnownerID, stream);
			ownerID = std::move(_mnownerID);
		}
		return true;

	case 0x7fe78407: //AuctionItem.ownerName
		{
			String _mnownerName;
			TypeInfo<String >::parseFromBinaryStream(&_mnownerName, stream);
			ownerName = std::move(_mnownerName);
		}
		return true;

	case 0xac7a216a: //AuctionItem.bidderName
		{
			String _mnbidderName;
			TypeInfo<String >::parseFromBinaryStream(&_mnbidderName, stream);
			bidderName = std::move(_mnbidderName);
		}
		return true;

	case 0xbb302a62: //AuctionItem.offerToID
		{
			unsigned long long _mnofferToID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnofferToID, stream);
			offerToID = std::move(_mnofferToID);
		}
		return true;

	case 0x553415e6: //AuctionItem.vuid
		{
			String _mnvuid;
			TypeInfo<String >::parseFromBinaryStream(&_mnvuid, stream);
			vuid = std::move(_mnvuid);
		}
		return true;

	case 0xa979b1fa: //AuctionItem.itemName
		{
			String _mnitemName;
			TypeInfo<String >::parseFromBinaryStream(&_mnitemName, stream);
			itemName = std::move(_mnitemName);
		}
		return true;

	case 0xa772caca: //AuctionItem.itemDescription
		{
			String _mnitemDescription;
			TypeInfo<String >::parseFromBinaryStream(&_mnitemDescription, stream);
			itemDescription = std::move(_mnitemDescription);
		}
		return true;

	case 0xc8730753: //AuctionItem.price
		{
			int _mnprice;
			TypeInfo<int >::parseFromBinaryStream(&_mnprice, stream);
			price = std::move(_mnprice);
		}
		return true;

	case 0x50632d68: //AuctionItem.proxyBid
		{
			int _mnproxyBid;
			TypeInfo<int >::parseFromBinaryStream(&_mnproxyBid, stream);
			proxyBid = std::move(_mnproxyBid);
		}
		return true;

	case 0xc91826a0: //AuctionItem.auction
		{
			bool _mnauction;
			TypeInfo<bool >::parseFromBinaryStream(&_mnauction, stream);
			auction = std::move(_mnauction);
		}
		return true;

	case 0x3a2982b9: //AuctionItem.status
		{
			int _mnstatus;
			TypeInfo<int >::parseFromBinaryStream(&_mnstatus, stream);
			status = std::move(_mnstatus);
		}
		return true;

	case 0xcb2cdb14: //AuctionItem.onBazaar
		{
			bool _mnonBazaar;
			TypeInfo<bool >::parseFromBinaryStream(&_mnonBazaar, stream);
			onBazaar = std::move(_mnonBazaar);
		}
		return true;

	case 0xee273fee: //AuctionItem.isCrate
		{
			bool _mnisCrate;
			TypeInfo<bool >::parseFromBinaryStream(&_mnisCrate, stream);
			isCrate = std::move(_mnisCrate);
		}
		return true;

	case 0x8c9f3fa0: //AuctionItem.cratedItemType
		{
			int _mncratedItemType;
			TypeInfo<int >::parseFromBinaryStream(&_mncratedItemType, stream);
			cratedItemType = std::move(_mncratedItemType);
		}
		return true;

	case 0x435fe0: //AuctionItem.buyerID
		{
			unsigned long long _mnbuyerID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnbuyerID, stream);
			buyerID = std::move(_mnbuyerID);
		}
		return true;

	case 0x396a8462: //AuctionItem.expireTime
		{
			unsigned int _mnexpireTime;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnexpireTime, stream);
			expireTime = std::move(_mnexpireTime);
		}
		return true;

	case 0xddd43d5a: //AuctionItem.updated
		{
			bool _mnupdated;
			TypeInfo<bool >::parseFromBinaryStream(&_mnupdated, stream);
			updated = std::move(_mnupdated);
		}
		return true;

	case 0x75922636: //AuctionItem.auctionOptions
		{
			int _mnauctionOptions;
			TypeInfo<int >::parseFromBinaryStream(&_mnauctionOptions, stream);
			auctionOptions = std::move(_mnauctionOptions);
		}
		return true;

	}

	return false;
}

void AuctionItemPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(AuctionItemPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void AuctionItemPOD::writeObjectCompact(ObjectOutputStream* stream) {
	ManagedObjectPOD::writeObjectCompact(stream);

	TypeInfo<unsigned long long >::toBinaryStream(&vendorID.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&auctionedItemObjectID.value(), stream);

	TypeInfo<int >::toBinaryStream(&itemType.value(), stream);

	TypeInfo<int >::toBinaryStream(&size.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&ownerID.value(), stream);

	TypeInfo<String >::toBinaryStream(&ownerName.value(), stream);

	TypeInfo<String >::toBinaryStream(&bidderName.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&offerToID.value(), stream);

	TypeInfo<String >::toBinaryStream(&vuid.value(), stream);

	TypeInfo<String >::toBinaryStream(&itemName.value(), stream);

	TypeInfo<String >::toBinaryStream(&itemDescription.value(), stream);

	TypeInfo<int >::toBinaryStream(&price.value(), stream);

	TypeInfo<int >::toBinaryStream(&proxyBid.value(), stream);

	TypeInfo<bool >::toBinaryStream(&auction.value(), stream);

	TypeInfo<int >::toBinaryStream(&status.value(), stream);

	TypeInfo<bool >::toBinaryStream(&onBazaar.value(), stream);

	TypeInfo<bool >::toBinaryStream(&isCrate.value(), stream);

	TypeInfo<int >::toBinaryStream(&cratedItemType.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&buyerID.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&expireTime.value(), stream);

	TypeInfo<bool >::toBinaryStream(&updated.value(), stream);

	TypeInfo<int >::toBinaryStream(&auctionOptions.value(), stream);


}

