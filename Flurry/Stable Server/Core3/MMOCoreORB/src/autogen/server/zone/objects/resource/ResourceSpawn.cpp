/*
 *	autogen/server/zone/objects/resource/ResourceSpawn.cpp generated by engine3 IDL compiler 0.70
 */

#include "ResourceSpawn.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/resource/ResourceContainer.h"

/*
 *	ResourceSpawnStub
 */

enum {RPC_FINALIZE__ = 889586298,RPC_DECREASECONTAINERREFERENCECOUNT__,RPC_ISRESOURCESPAWN__,RPC_SETNAME__STRING_,RPC_SETTYPE__STRING_,RPC_SETSPAWNPOOL__INT_STRING_,RPC_SETZONERESTRICTION__STRING_,RPC_ADDCLASS__STRING_,RPC_ADDSTFCLASS__STRING_,RPC_ADDATTRIBUTE__STRING_INT_,RPC_ISTYPE__STRING_,RPC_SETSURVEYTOOLTYPE__INT_,RPC_SETISENERGY__BOOL_,RPC_GETNAME__,RPC_GETTYPE__,RPC_GETCLASS__INT_,RPC_GETSTFCLASS__INT_,RPC_GETFINALCLASS__,RPC_GETFAMILYNAME__,RPC_GETSURVEYMISSIONSPAWNFAMILYNAME__,RPC_SETSPAWNED__LONG_,RPC_SETDESPAWNED__LONG_,RPC_GETDESPAWNED__,RPC_SETCONTAINERCRC__INT_,RPC_GETCONTAINERCRC__,RPC_GETSPAWNPOOL__,RPC_GETPOOLSLOT__,RPC_ISENERGY__,RPC_GETZONERESTRICTION__,RPC_GETSURVEYTOOLTYPE__,RPC_GETSPAWNMAPSIZE__,RPC_EXTRACTRESOURCE__STRING_INT_,RPC_CREATERESOURCE__INT_,RPC_GETSPAWNMAPZONE__INT_,RPC_ISUNKNOWNTYPE__,RPC_GETPLANETCRC__,RPC_GETDENSITYAT__STRING_FLOAT_FLOAT_,RPC_INSHIFT__,RPC_GETATTRIBUTEANDVALUE__STRING_INT_,RPC_GETATTRIBUTEVALUE__INT_,RPC_GETVALUEOF__INT_,RPC_GETVALUEOF__STRING_,RPC_ADDSTATSTODEEDLISTBOX__SUILISTBOX_,RPC_PRINT__};

ResourceSpawn::ResourceSpawn() : SceneObject(DummyConstructorParameter::instance()) {
	ResourceSpawnImplementation* _implementation = new ResourceSpawnImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("ResourceSpawn");
}

ResourceSpawn::ResourceSpawn(DummyConstructorParameter* param) : SceneObject(param) {
	_setClassName("ResourceSpawn");
}

ResourceSpawn::~ResourceSpawn() {
}



void ResourceSpawn::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

void ResourceSpawn::decreaseContainerReferenceCount() {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASECONTAINERREFERENCECOUNT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->decreaseContainerReferenceCount();
	}
}

bool ResourceSpawn::isResourceSpawn() {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRESOURCESPAWN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isResourceSpawn();
	}
}

void ResourceSpawn::setName(const String& name) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setName(name);
	}
}

void ResourceSpawn::setType(const String& type) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTYPE__STRING_);
		method.addAsciiParameter(type);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setType(type);
	}
}

void ResourceSpawn::setSpawnPool(int pool, const String& slot) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPAWNPOOL__INT_STRING_);
		method.addSignedIntParameter(pool);
		method.addAsciiParameter(slot);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSpawnPool(pool, slot);
	}
}

void ResourceSpawn::setZoneRestriction(const String& zoneName) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETZONERESTRICTION__STRING_);
		method.addAsciiParameter(zoneName);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setZoneRestriction(zoneName);
	}
}

void ResourceSpawn::addClass(const String& newclass) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCLASS__STRING_);
		method.addAsciiParameter(newclass);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addClass(newclass);
	}
}

void ResourceSpawn::addStfClass(const String& newclass) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSTFCLASS__STRING_);
		method.addAsciiParameter(newclass);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addStfClass(newclass);
	}
}

void ResourceSpawn::addAttribute(const String& attribute, int value) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDATTRIBUTE__STRING_INT_);
		method.addAsciiParameter(attribute);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addAttribute(attribute, value);
	}
}

bool ResourceSpawn::isType(const String& type) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTYPE__STRING_);
		method.addAsciiParameter(type);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isType(type);
	}
}

void ResourceSpawn::setSurveyToolType(int type) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSURVEYTOOLTYPE__INT_);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSurveyToolType(type);
	}
}

void ResourceSpawn::setIsEnergy(bool val) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETISENERGY__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setIsEnergy(val);
	}
}

String ResourceSpawn::getName() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNAME__);

		String _return_getName;
		method.executeWithAsciiReturn(_return_getName);
		return _return_getName;
	} else {
		return _implementation->getName();
	}
}

String ResourceSpawn::getType() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTYPE__);

		String _return_getType;
		method.executeWithAsciiReturn(_return_getType);
		return _return_getType;
	} else {
		return _implementation->getType();
	}
}

String ResourceSpawn::getClass(int index) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLASS__INT_);
		method.addSignedIntParameter(index);

		String _return_getClass;
		method.executeWithAsciiReturn(_return_getClass);
		return _return_getClass;
	} else {
		return _implementation->getClass(index);
	}
}

String ResourceSpawn::getStfClass(int index) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTFCLASS__INT_);
		method.addSignedIntParameter(index);

		String _return_getStfClass;
		method.executeWithAsciiReturn(_return_getStfClass);
		return _return_getStfClass;
	} else {
		return _implementation->getStfClass(index);
	}
}

String ResourceSpawn::getFinalClass() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFINALCLASS__);

		String _return_getFinalClass;
		method.executeWithAsciiReturn(_return_getFinalClass);
		return _return_getFinalClass;
	} else {
		return _implementation->getFinalClass();
	}
}

String ResourceSpawn::getFamilyName() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFAMILYNAME__);

		String _return_getFamilyName;
		method.executeWithAsciiReturn(_return_getFamilyName);
		return _return_getFamilyName;
	} else {
		return _implementation->getFamilyName();
	}
}

String ResourceSpawn::getSurveyMissionSpawnFamilyName() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSURVEYMISSIONSPAWNFAMILYNAME__);

		String _return_getSurveyMissionSpawnFamilyName;
		method.executeWithAsciiReturn(_return_getSurveyMissionSpawnFamilyName);
		return _return_getSurveyMissionSpawnFamilyName;
	} else {
		return _implementation->getSurveyMissionSpawnFamilyName();
	}
}

void ResourceSpawn::setSpawned(unsigned long long t) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPAWNED__LONG_);
		method.addUnsignedLongParameter(t);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSpawned(t);
	}
}

void ResourceSpawn::setDespawned(unsigned long long t) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDESPAWNED__LONG_);
		method.addUnsignedLongParameter(t);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDespawned(t);
	}
}

unsigned long long ResourceSpawn::getDespawned() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDESPAWNED__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getDespawned();
	}
}

void ResourceSpawn::setContainerCRC(unsigned int crc) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONTAINERCRC__INT_);
		method.addUnsignedIntParameter(crc);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setContainerCRC(crc);
	}
}

unsigned int ResourceSpawn::getContainerCRC() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTAINERCRC__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getContainerCRC();
	}
}

int ResourceSpawn::getSpawnPool() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPAWNPOOL__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSpawnPool();
	}
}

String ResourceSpawn::getPoolSlot() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOOLSLOT__);

		String _return_getPoolSlot;
		method.executeWithAsciiReturn(_return_getPoolSlot);
		return _return_getPoolSlot;
	} else {
		return _implementation->getPoolSlot();
	}
}

bool ResourceSpawn::isEnergy() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISENERGY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isEnergy();
	}
}

String ResourceSpawn::getZoneRestriction() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETZONERESTRICTION__);

		String _return_getZoneRestriction;
		method.executeWithAsciiReturn(_return_getZoneRestriction);
		return _return_getZoneRestriction;
	} else {
		return _implementation->getZoneRestriction();
	}
}

int ResourceSpawn::getSurveyToolType() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSURVEYTOOLTYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSurveyToolType();
	}
}

int ResourceSpawn::getSpawnMapSize() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPAWNMAPSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSpawnMapSize();
	}
}

void ResourceSpawn::extractResource(const String& zoneName, int units) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXTRACTRESOURCE__STRING_INT_);
		method.addAsciiParameter(zoneName);
		method.addSignedIntParameter(units);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->extractResource(zoneName, units);
	}
}

Reference<ResourceContainer* > ResourceSpawn::createResource(int units) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATERESOURCE__INT_);
		method.addSignedIntParameter(units);

		return static_cast<ResourceContainer*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->createResource(units);
	}
}

String ResourceSpawn::getSpawnMapZone(int i) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPAWNMAPZONE__INT_);
		method.addSignedIntParameter(i);

		String _return_getSpawnMapZone;
		method.executeWithAsciiReturn(_return_getSpawnMapZone);
		return _return_getSpawnMapZone;
	} else {
		return _implementation->getSpawnMapZone(i);
	}
}

bool ResourceSpawn::isUnknownType() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUNKNOWNTYPE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isUnknownType();
	}
}

void ResourceSpawn::createSpawnMaps(bool jtl, int minpool, int maxpool, const String& zonerestriction, Vector<String>& activeZones) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->createSpawnMaps(jtl, minpool, maxpool, zonerestriction, activeZones);
	}
}

unsigned int ResourceSpawn::getPlanetCRC() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLANETCRC__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getPlanetCRC();
	}
}

float ResourceSpawn::getDensityAt(const String& zoneName, float x, float y) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDENSITYAT__STRING_FLOAT_FLOAT_);
		method.addAsciiParameter(zoneName);
		method.addFloatParameter(x);
		method.addFloatParameter(y);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getDensityAt(zoneName, x, y);
	}
}

bool ResourceSpawn::inShift() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INSHIFT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->inShift();
	}
}

int ResourceSpawn::getAttributeAndValue(String& attribute, int index) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEANDVALUE__STRING_INT_);
		method.addAsciiParameter(attribute);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAttributeAndValue(attribute, index);
	}
}

int ResourceSpawn::getAttributeValue(int index) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEVALUE__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAttributeValue(index);
	}
}

int ResourceSpawn::getValueOf(int index) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVALUEOF__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getValueOf(index);
	}
}

int ResourceSpawn::getValueOf(const String& attribute) const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVALUEOF__STRING_);
		method.addAsciiParameter(attribute);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getValueOf(attribute);
	}
}

void ResourceSpawn::addStatsToDeedListBox(SuiListBox* suil) {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSTATSTODEEDLISTBOX__SUILISTBOX_);
		method.addObjectParameter(suil);

		method.executeWithVoidReturn();
	} else {
		_implementation->addStatsToDeedListBox(suil);
	}
}

void ResourceSpawn::print() const {
	ResourceSpawnImplementation* _implementation = static_cast<ResourceSpawnImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PRINT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->print();
	}
}

DistributedObjectServant* ResourceSpawn::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* ResourceSpawn::_getImplementationForRead() const {
	return _impl;
}

void ResourceSpawn::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ResourceSpawnImplementation
 */

ResourceSpawnImplementation::ResourceSpawnImplementation(DummyConstructorParameter* param) : SceneObjectImplementation(param) {
	_initializeImplementation();
}


ResourceSpawnImplementation::~ResourceSpawnImplementation() {
	ResourceSpawnImplementation::finalize();
}


void ResourceSpawnImplementation::_initializeImplementation() {
	_setClassHelper(ResourceSpawnHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ResourceSpawnImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<ResourceSpawn*>(stub);
	SceneObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ResourceSpawnImplementation::_getStub() {
	return _this.get();
}

ResourceSpawnImplementation::operator const ResourceSpawn*() {
	return _this.get();
}

void ResourceSpawnImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ResourceSpawnImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ResourceSpawnImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ResourceSpawnImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ResourceSpawnImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ResourceSpawnImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ResourceSpawnImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ResourceSpawnImplementation::_serializationHelperMethod() {
	SceneObjectImplementation::_serializationHelperMethod();

	_setClassName("ResourceSpawn");

}

void ResourceSpawnImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ResourceSpawnImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ResourceSpawnImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x64bf9f27: //ResourceSpawn.spawnType
		TypeInfo<String >::parseFromBinaryStream(&spawnType, stream);
		return true;

	case 0xc830962b: //ResourceSpawn.spawnName
		TypeInfo<String >::parseFromBinaryStream(&spawnName, stream);
		return true;

	case 0x4c6462c0: //ResourceSpawn.spawnClasses
		TypeInfo<Vector<String> >::parseFromBinaryStream(&spawnClasses, stream);
		return true;

	case 0x975988f9: //ResourceSpawn.stfSpawnClasses
		TypeInfo<Vector<String> >::parseFromBinaryStream(&stfSpawnClasses, stream);
		return true;

	case 0x18da759d: //ResourceSpawn.spawnAttributes
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&spawnAttributes, stream);
		return true;

	case 0xb1bc58cd: //ResourceSpawn.poolSlot
		TypeInfo<String >::parseFromBinaryStream(&poolSlot, stream);
		return true;

	case 0x8e0ca674: //ResourceSpawn.spawnPool
		TypeInfo<int >::parseFromBinaryStream(&spawnPool, stream);
		return true;

	case 0x895b3fce: //ResourceSpawn.zoneRestriction
		TypeInfo<String >::parseFromBinaryStream(&zoneRestriction, stream);
		return true;

	case 0x7f76595d: //ResourceSpawn.surveyToolType
		TypeInfo<int >::parseFromBinaryStream(&surveyToolType, stream);
		return true;

	case 0x6458e9e6: //ResourceSpawn.containerCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&containerCRC, stream);
		return true;

	case 0x309fa8e6: //ResourceSpawn.spawned
		TypeInfo<unsigned long long >::parseFromBinaryStream(&spawned, stream);
		return true;

	case 0xa5f8c907: //ResourceSpawn.despawned
		TypeInfo<unsigned long long >::parseFromBinaryStream(&despawned, stream);
		return true;

	case 0xf3f48ab3: //ResourceSpawn.spawnMaps
		TypeInfo<SpawnMap >::parseFromBinaryStream(&spawnMaps, stream);
		return true;

	case 0xad93bc4: //ResourceSpawn.maxUnitsSpawned
		TypeInfo<unsigned long long >::parseFromBinaryStream(&maxUnitsSpawned, stream);
		return true;

	case 0x4443a30e: //ResourceSpawn.unitsInCirculation
		TypeInfo<unsigned long long >::parseFromBinaryStream(&unitsInCirculation, stream);
		return true;

	case 0xcc6e7c3f: //ResourceSpawn.containerReferenceCount
		TypeInfo<int >::parseFromBinaryStream(&containerReferenceCount, stream);
		return true;

	case 0xef3b250a: //ResourceSpawn.dbDestroyed
		TypeInfo<bool >::parseFromBinaryStream(&dbDestroyed, stream);
		return true;

	case 0x1e6aab53: //ResourceSpawn.energy
		TypeInfo<bool >::parseFromBinaryStream(&energy, stream);
		return true;

	}

	return false;
}

void ResourceSpawnImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ResourceSpawnImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ResourceSpawnImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x64bf9f27; //ResourceSpawn.spawnType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&spawnType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc830962b; //ResourceSpawn.spawnName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&spawnName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4c6462c0; //ResourceSpawn.spawnClasses
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&spawnClasses, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x975988f9; //ResourceSpawn.stfSpawnClasses
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&stfSpawnClasses, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x18da759d; //ResourceSpawn.spawnAttributes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&spawnAttributes, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb1bc58cd; //ResourceSpawn.poolSlot
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&poolSlot, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8e0ca674; //ResourceSpawn.spawnPool
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&spawnPool, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x895b3fce; //ResourceSpawn.zoneRestriction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&zoneRestriction, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7f76595d; //ResourceSpawn.surveyToolType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&surveyToolType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6458e9e6; //ResourceSpawn.containerCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&containerCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x309fa8e6; //ResourceSpawn.spawned
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&spawned, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa5f8c907; //ResourceSpawn.despawned
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&despawned, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf3f48ab3; //ResourceSpawn.spawnMaps
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SpawnMap >::toBinaryStream(&spawnMaps, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xad93bc4; //ResourceSpawn.maxUnitsSpawned
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&maxUnitsSpawned, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4443a30e; //ResourceSpawn.unitsInCirculation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&unitsInCirculation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcc6e7c3f; //ResourceSpawn.containerReferenceCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&containerReferenceCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xef3b250a; //ResourceSpawn.dbDestroyed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&dbDestroyed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1e6aab53; //ResourceSpawn.energy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&energy, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void ResourceSpawnImplementation::writeJSON(nlohmann::json& j) {
	SceneObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["spawnType"] = spawnType;

	thisObject["spawnName"] = spawnName;

	thisObject["spawnClasses"] = spawnClasses;

	thisObject["stfSpawnClasses"] = stfSpawnClasses;

	thisObject["spawnAttributes"] = spawnAttributes;

	thisObject["poolSlot"] = poolSlot;

	thisObject["spawnPool"] = spawnPool;

	thisObject["zoneRestriction"] = zoneRestriction;

	thisObject["surveyToolType"] = surveyToolType;

	thisObject["containerCRC"] = containerCRC;

	thisObject["spawned"] = spawned;

	thisObject["despawned"] = despawned;

	thisObject["spawnMaps"] = spawnMaps;

	thisObject["maxUnitsSpawned"] = maxUnitsSpawned;

	thisObject["unitsInCirculation"] = unitsInCirculation;

	thisObject["containerReferenceCount"] = containerReferenceCount;

	thisObject["dbDestroyed"] = dbDestroyed;

	thisObject["energy"] = energy;

	j["ResourceSpawn"] = thisObject;
}

ResourceSpawnImplementation::ResourceSpawnImplementation() {
	_initializeImplementation();
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawnType = "";
	spawnType = "";
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawnPool = 0;
	spawnPool = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		poolSlot = "";
	poolSlot = "";
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawnAttributes.setAllowOverwriteInsertPlan();
	(&spawnAttributes)->setAllowOverwriteInsertPlan();
	// server/zone/objects/resource/ResourceSpawn.idl():  		containerReferenceCount = 0;
	containerReferenceCount = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		unitsInCirculation = 0;
	unitsInCirculation = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		maxUnitsSpawned = 0;
	maxUnitsSpawned = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		containerCRC = 0;
	containerCRC = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawned = 0;
	spawned = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		despawned = 0;
	despawned = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		surveyToolType = 0;
	surveyToolType = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		zoneRestriction = "";
	zoneRestriction = "";
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawnPool = 0;
	spawnPool = 0;
	// server/zone/objects/resource/ResourceSpawn.idl():  		dbDestroyed = false;
	dbDestroyed = false;
	// server/zone/objects/resource/ResourceSpawn.idl():  		energy = false;
	energy = false;
	// server/zone/objects/resource/ResourceSpawn.idl():  		setLoggingName("ResourceSpawn");
	setLoggingName("ResourceSpawn");
}

void ResourceSpawnImplementation::finalize() {
	// server/zone/objects/resource/ResourceSpawn.idl():  		Logger.info("trying to delete ResourceSpawn: " + spawnName);
	Logger::info("trying to delete ResourceSpawn: " + spawnName);
}

bool ResourceSpawnImplementation::isResourceSpawn() {
	// server/zone/objects/resource/ResourceSpawn.idl():  		return true;
	return true;
}

void ResourceSpawnImplementation::setName(const String& name) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawnName = name;
	spawnName = name;
}

void ResourceSpawnImplementation::setType(const String& type) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawnType = type;
	spawnType = type;
}

void ResourceSpawnImplementation::setSpawnPool(int pool, const String& slot) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawnPool = pool;
	spawnPool = pool;
	// server/zone/objects/resource/ResourceSpawn.idl():  		poolSlot = slot;
	poolSlot = slot;
	// server/zone/objects/resource/ResourceSpawn.idl():  	}
	if (spawnPool == 0){
	// server/zone/objects/resource/ResourceSpawn.idl():  			spawnMaps.removeAll();
	(&spawnMaps)->removeAll();
	// server/zone/objects/resource/ResourceSpawn.idl():  			poolSlot = "";
	poolSlot = "";
}
}

void ResourceSpawnImplementation::setZoneRestriction(const String& zoneName) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		zoneRestriction = zoneName;
	zoneRestriction = zoneName;
}

void ResourceSpawnImplementation::addClass(const String& newclass) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawnClasses.add(newclass);
	(&spawnClasses)->add(newclass);
}

void ResourceSpawnImplementation::addStfClass(const String& newclass) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		stfSpawnClasses.add(newclass);
	(&stfSpawnClasses)->add(newclass);
}

bool ResourceSpawnImplementation::isType(const String& type) const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		}
	for (	// server/zone/objects/resource/ResourceSpawn.idl():  		for(int i = 0;
	int i = 0;
	i < (&stfSpawnClasses)->size();
 ++i) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		}
	if ((&stfSpawnClasses)->get(i) == type)	// server/zone/objects/resource/ResourceSpawn.idl():  				return true;
	return true;
}
	// server/zone/objects/resource/ResourceSpawn.idl():  		}
	for (	// server/zone/objects/resource/ResourceSpawn.idl():  		for(int i = 0;
	int i = 0;
	i < (&spawnClasses)->size();
 ++i) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		}
	if ((&spawnClasses)->get(i) == type)	// server/zone/objects/resource/ResourceSpawn.idl():  				return true;
	return true;
}
	// server/zone/objects/resource/ResourceSpawn.idl():  		return false;
	return false;
}

void ResourceSpawnImplementation::setSurveyToolType(int type) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		surveyToolType = type;
	surveyToolType = type;
}

void ResourceSpawnImplementation::setIsEnergy(bool val) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		energy = val;
	energy = val;
}

String ResourceSpawnImplementation::getName() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return spawnName;
	return spawnName;
}

String ResourceSpawnImplementation::getType() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return spawnType;
	return spawnType;
}

String ResourceSpawnImplementation::getClass(int index) const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		}
	if (index < (&spawnClasses)->size()){
	// server/zone/objects/resource/ResourceSpawn.idl():  			return spawnClasses.get(index);
	return (&spawnClasses)->get(index);
}

	else {
	// server/zone/objects/resource/ResourceSpawn.idl():  			return "";
	return "";
}
}

String ResourceSpawnImplementation::getStfClass(int index) const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		}
	if (index < (&stfSpawnClasses)->size()){
	// server/zone/objects/resource/ResourceSpawn.idl():  			return stfSpawnClasses.get(index);
	return (&stfSpawnClasses)->get(index);
}

	else {
	// server/zone/objects/resource/ResourceSpawn.idl():  			return "";
	return "";
}
}

String ResourceSpawnImplementation::getFinalClass() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  			return "";
	if ((&spawnClasses)->size() > 1)	// server/zone/objects/resource/ResourceSpawn.idl():  			return spawnClasses.get(spawnClasses.size() - 1);
	return (&spawnClasses)->get((&spawnClasses)->size() - 1);

	else 	// server/zone/objects/resource/ResourceSpawn.idl():  			return "";
	return "";
}

void ResourceSpawnImplementation::setSpawned(unsigned long long t) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		spawned = t;
	spawned = t;
}

void ResourceSpawnImplementation::setDespawned(unsigned long long t) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		despawned = t;
	despawned = t;
}

unsigned long long ResourceSpawnImplementation::getDespawned() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return despawned;
	return despawned;
}

void ResourceSpawnImplementation::setContainerCRC(unsigned int crc) {
	// server/zone/objects/resource/ResourceSpawn.idl():  		containerCRC = crc;
	containerCRC = crc;
}

unsigned int ResourceSpawnImplementation::getContainerCRC() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return containerCRC;
	return containerCRC;
}

int ResourceSpawnImplementation::getSpawnPool() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return spawnPool;
	return spawnPool;
}

String ResourceSpawnImplementation::getPoolSlot() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return poolSlot;
	return poolSlot;
}

bool ResourceSpawnImplementation::isEnergy() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return energy;
	return energy;
}

String ResourceSpawnImplementation::getZoneRestriction() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return zoneRestriction;
	return zoneRestriction;
}

int ResourceSpawnImplementation::getSurveyToolType() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return surveyToolType;
	return surveyToolType;
}

int ResourceSpawnImplementation::getSpawnMapSize() const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return spawnMaps.size();
	return (&spawnMaps)->size();
}

int ResourceSpawnImplementation::getAttributeValue(int index) const{
	// server/zone/objects/resource/ResourceSpawn.idl():  		return spawnAttributes.get(index);
	return (&spawnAttributes)->get(index);
}

/*
 *	ResourceSpawnAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ResourceSpawnAdapter::ResourceSpawnAdapter(ResourceSpawn* obj) : SceneObjectAdapter(obj) {
}

void ResourceSpawnAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_DECREASECONTAINERREFERENCECOUNT__:
		{
			
			decreaseContainerReferenceCount();
			
		}
		break;
	case RPC_ISRESOURCESPAWN__:
		{
			
			bool _m_res = isResourceSpawn();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setName(name);
			
		}
		break;
	case RPC_SETTYPE__STRING_:
		{
			 String type; inv->getAsciiParameter(type);
			
			setType(type);
			
		}
		break;
	case RPC_SETSPAWNPOOL__INT_STRING_:
		{
			int pool = inv->getSignedIntParameter();
			 String slot; inv->getAsciiParameter(slot);
			
			setSpawnPool(pool, slot);
			
		}
		break;
	case RPC_SETZONERESTRICTION__STRING_:
		{
			 String zoneName; inv->getAsciiParameter(zoneName);
			
			setZoneRestriction(zoneName);
			
		}
		break;
	case RPC_ADDCLASS__STRING_:
		{
			 String newclass; inv->getAsciiParameter(newclass);
			
			addClass(newclass);
			
		}
		break;
	case RPC_ADDSTFCLASS__STRING_:
		{
			 String newclass; inv->getAsciiParameter(newclass);
			
			addStfClass(newclass);
			
		}
		break;
	case RPC_ADDATTRIBUTE__STRING_INT_:
		{
			 String attribute; inv->getAsciiParameter(attribute);
			int value = inv->getSignedIntParameter();
			
			addAttribute(attribute, value);
			
		}
		break;
	case RPC_ISTYPE__STRING_:
		{
			 String type; inv->getAsciiParameter(type);
			
			bool _m_res = isType(type);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETSURVEYTOOLTYPE__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			setSurveyToolType(type);
			
		}
		break;
	case RPC_SETISENERGY__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setIsEnergy(val);
			
		}
		break;
	case RPC_GETNAME__:
		{
			
			String _m_res = getName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETTYPE__:
		{
			
			String _m_res = getType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETCLASS__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			String _m_res = getClass(index);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETSTFCLASS__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			String _m_res = getStfClass(index);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETFINALCLASS__:
		{
			
			String _m_res = getFinalClass();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETFAMILYNAME__:
		{
			
			String _m_res = getFamilyName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETSURVEYMISSIONSPAWNFAMILYNAME__:
		{
			
			String _m_res = getSurveyMissionSpawnFamilyName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETSPAWNED__LONG_:
		{
			unsigned long long t = inv->getUnsignedLongParameter();
			
			setSpawned(t);
			
		}
		break;
	case RPC_SETDESPAWNED__LONG_:
		{
			unsigned long long t = inv->getUnsignedLongParameter();
			
			setDespawned(t);
			
		}
		break;
	case RPC_GETDESPAWNED__:
		{
			
			unsigned long long _m_res = getDespawned();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETCONTAINERCRC__INT_:
		{
			unsigned int crc = inv->getUnsignedIntParameter();
			
			setContainerCRC(crc);
			
		}
		break;
	case RPC_GETCONTAINERCRC__:
		{
			
			unsigned int _m_res = getContainerCRC();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETSPAWNPOOL__:
		{
			
			int _m_res = getSpawnPool();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETPOOLSLOT__:
		{
			
			String _m_res = getPoolSlot();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISENERGY__:
		{
			
			bool _m_res = isEnergy();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETZONERESTRICTION__:
		{
			
			String _m_res = getZoneRestriction();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETSURVEYTOOLTYPE__:
		{
			
			int _m_res = getSurveyToolType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSPAWNMAPSIZE__:
		{
			
			int _m_res = getSpawnMapSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_EXTRACTRESOURCE__STRING_INT_:
		{
			 String zoneName; inv->getAsciiParameter(zoneName);
			int units = inv->getSignedIntParameter();
			
			extractResource(zoneName, units);
			
		}
		break;
	case RPC_CREATERESOURCE__INT_:
		{
			int units = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = createResource(units);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETSPAWNMAPZONE__INT_:
		{
			int i = inv->getSignedIntParameter();
			
			String _m_res = getSpawnMapZone(i);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISUNKNOWNTYPE__:
		{
			
			bool _m_res = isUnknownType();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPLANETCRC__:
		{
			
			unsigned int _m_res = getPlanetCRC();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETDENSITYAT__STRING_FLOAT_FLOAT_:
		{
			 String zoneName; inv->getAsciiParameter(zoneName);
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			
			float _m_res = getDensityAt(zoneName, x, y);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_INSHIFT__:
		{
			
			bool _m_res = inShift();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETATTRIBUTEANDVALUE__STRING_INT_:
		{
			String attribute; inv->getAsciiParameter(attribute);
			int index = inv->getSignedIntParameter();
			
			int _m_res = getAttributeAndValue(attribute, index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETATTRIBUTEVALUE__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getAttributeValue(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETVALUEOF__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getValueOf(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETVALUEOF__STRING_:
		{
			 String attribute; inv->getAsciiParameter(attribute);
			
			int _m_res = getValueOf(attribute);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ADDSTATSTODEEDLISTBOX__SUILISTBOX_:
		{
			SuiListBox* suil = static_cast<SuiListBox*>(inv->getObjectParameter());
			
			addStatsToDeedListBox(suil);
			
		}
		break;
	case RPC_PRINT__:
		{
			
			print();
			
		}
		break;
	default:
		SceneObjectAdapter::invokeMethod(methid, inv);
	}
}

void ResourceSpawnAdapter::finalize() {
	(static_cast<ResourceSpawn*>(stub))->finalize();
}

void ResourceSpawnAdapter::decreaseContainerReferenceCount() {
	(static_cast<ResourceSpawn*>(stub))->decreaseContainerReferenceCount();
}

bool ResourceSpawnAdapter::isResourceSpawn() {
	return (static_cast<ResourceSpawn*>(stub))->isResourceSpawn();
}

void ResourceSpawnAdapter::setName(const String& name) {
	(static_cast<ResourceSpawn*>(stub))->setName(name);
}

void ResourceSpawnAdapter::setType(const String& type) {
	(static_cast<ResourceSpawn*>(stub))->setType(type);
}

void ResourceSpawnAdapter::setSpawnPool(int pool, const String& slot) {
	(static_cast<ResourceSpawn*>(stub))->setSpawnPool(pool, slot);
}

void ResourceSpawnAdapter::setZoneRestriction(const String& zoneName) {
	(static_cast<ResourceSpawn*>(stub))->setZoneRestriction(zoneName);
}

void ResourceSpawnAdapter::addClass(const String& newclass) {
	(static_cast<ResourceSpawn*>(stub))->addClass(newclass);
}

void ResourceSpawnAdapter::addStfClass(const String& newclass) {
	(static_cast<ResourceSpawn*>(stub))->addStfClass(newclass);
}

void ResourceSpawnAdapter::addAttribute(const String& attribute, int value) {
	(static_cast<ResourceSpawn*>(stub))->addAttribute(attribute, value);
}

bool ResourceSpawnAdapter::isType(const String& type) const {
	return (static_cast<ResourceSpawn*>(stub))->isType(type);
}

void ResourceSpawnAdapter::setSurveyToolType(int type) {
	(static_cast<ResourceSpawn*>(stub))->setSurveyToolType(type);
}

void ResourceSpawnAdapter::setIsEnergy(bool val) {
	(static_cast<ResourceSpawn*>(stub))->setIsEnergy(val);
}

String ResourceSpawnAdapter::getName() const {
	return (static_cast<ResourceSpawn*>(stub))->getName();
}

String ResourceSpawnAdapter::getType() const {
	return (static_cast<ResourceSpawn*>(stub))->getType();
}

String ResourceSpawnAdapter::getClass(int index) const {
	return (static_cast<ResourceSpawn*>(stub))->getClass(index);
}

String ResourceSpawnAdapter::getStfClass(int index) const {
	return (static_cast<ResourceSpawn*>(stub))->getStfClass(index);
}

String ResourceSpawnAdapter::getFinalClass() const {
	return (static_cast<ResourceSpawn*>(stub))->getFinalClass();
}

String ResourceSpawnAdapter::getFamilyName() const {
	return (static_cast<ResourceSpawn*>(stub))->getFamilyName();
}

String ResourceSpawnAdapter::getSurveyMissionSpawnFamilyName() const {
	return (static_cast<ResourceSpawn*>(stub))->getSurveyMissionSpawnFamilyName();
}

void ResourceSpawnAdapter::setSpawned(unsigned long long t) {
	(static_cast<ResourceSpawn*>(stub))->setSpawned(t);
}

void ResourceSpawnAdapter::setDespawned(unsigned long long t) {
	(static_cast<ResourceSpawn*>(stub))->setDespawned(t);
}

unsigned long long ResourceSpawnAdapter::getDespawned() const {
	return (static_cast<ResourceSpawn*>(stub))->getDespawned();
}

void ResourceSpawnAdapter::setContainerCRC(unsigned int crc) {
	(static_cast<ResourceSpawn*>(stub))->setContainerCRC(crc);
}

unsigned int ResourceSpawnAdapter::getContainerCRC() const {
	return (static_cast<ResourceSpawn*>(stub))->getContainerCRC();
}

int ResourceSpawnAdapter::getSpawnPool() const {
	return (static_cast<ResourceSpawn*>(stub))->getSpawnPool();
}

String ResourceSpawnAdapter::getPoolSlot() const {
	return (static_cast<ResourceSpawn*>(stub))->getPoolSlot();
}

bool ResourceSpawnAdapter::isEnergy() const {
	return (static_cast<ResourceSpawn*>(stub))->isEnergy();
}

String ResourceSpawnAdapter::getZoneRestriction() const {
	return (static_cast<ResourceSpawn*>(stub))->getZoneRestriction();
}

int ResourceSpawnAdapter::getSurveyToolType() const {
	return (static_cast<ResourceSpawn*>(stub))->getSurveyToolType();
}

int ResourceSpawnAdapter::getSpawnMapSize() const {
	return (static_cast<ResourceSpawn*>(stub))->getSpawnMapSize();
}

void ResourceSpawnAdapter::extractResource(const String& zoneName, int units) {
	(static_cast<ResourceSpawn*>(stub))->extractResource(zoneName, units);
}

Reference<ResourceContainer* > ResourceSpawnAdapter::createResource(int units) {
	return (static_cast<ResourceSpawn*>(stub))->createResource(units);
}

String ResourceSpawnAdapter::getSpawnMapZone(int i) const {
	return (static_cast<ResourceSpawn*>(stub))->getSpawnMapZone(i);
}

bool ResourceSpawnAdapter::isUnknownType() const {
	return (static_cast<ResourceSpawn*>(stub))->isUnknownType();
}

unsigned int ResourceSpawnAdapter::getPlanetCRC() const {
	return (static_cast<ResourceSpawn*>(stub))->getPlanetCRC();
}

float ResourceSpawnAdapter::getDensityAt(const String& zoneName, float x, float y) const {
	return (static_cast<ResourceSpawn*>(stub))->getDensityAt(zoneName, x, y);
}

bool ResourceSpawnAdapter::inShift() const {
	return (static_cast<ResourceSpawn*>(stub))->inShift();
}

int ResourceSpawnAdapter::getAttributeAndValue(String& attribute, int index) const {
	return (static_cast<ResourceSpawn*>(stub))->getAttributeAndValue(attribute, index);
}

int ResourceSpawnAdapter::getAttributeValue(int index) const {
	return (static_cast<ResourceSpawn*>(stub))->getAttributeValue(index);
}

int ResourceSpawnAdapter::getValueOf(int index) const {
	return (static_cast<ResourceSpawn*>(stub))->getValueOf(index);
}

int ResourceSpawnAdapter::getValueOf(const String& attribute) const {
	return (static_cast<ResourceSpawn*>(stub))->getValueOf(attribute);
}

void ResourceSpawnAdapter::addStatsToDeedListBox(SuiListBox* suil) {
	(static_cast<ResourceSpawn*>(stub))->addStatsToDeedListBox(suil);
}

void ResourceSpawnAdapter::print() const {
	(static_cast<ResourceSpawn*>(stub))->print();
}

/*
 *	ResourceSpawnHelper
 */

ResourceSpawnHelper* ResourceSpawnHelper::staticInitializer = ResourceSpawnHelper::instance();

ResourceSpawnHelper::ResourceSpawnHelper() {
	className = "ResourceSpawn";

	Core::getObjectBroker()->registerClass(className, this);
}

void ResourceSpawnHelper::finalizeHelper() {
	ResourceSpawnHelper::finalize();
}

DistributedObject* ResourceSpawnHelper::instantiateObject() {
	return new ResourceSpawn(DummyConstructorParameter::instance());
}

DistributedObjectServant* ResourceSpawnHelper::instantiateServant() {
	return new ResourceSpawnImplementation();
}

DistributedObjectPOD* ResourceSpawnHelper::instantiatePOD() {
	return new ResourceSpawnPOD();
}

DistributedObjectAdapter* ResourceSpawnHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ResourceSpawnAdapter(static_cast<ResourceSpawn*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

const char LuaResourceSpawn::className[] = "LuaResourceSpawn";

Luna<LuaResourceSpawn>::RegType LuaResourceSpawn::Register[] = {
	{ "_setObject", &LuaResourceSpawn::_setObject },
	{ "_getObject", &LuaResourceSpawn::_getObject },
	{ "fillAttributeList", &LuaResourceSpawn::fillAttributeList },
	{ "decreaseContainerReferenceCount", &LuaResourceSpawn::decreaseContainerReferenceCount },
	{ "isResourceSpawn", &LuaResourceSpawn::isResourceSpawn },
	{ "setName", &LuaResourceSpawn::setName },
	{ "setType", &LuaResourceSpawn::setType },
	{ "setSpawnPool", &LuaResourceSpawn::setSpawnPool },
	{ "setZoneRestriction", &LuaResourceSpawn::setZoneRestriction },
	{ "addClass", &LuaResourceSpawn::addClass },
	{ "addStfClass", &LuaResourceSpawn::addStfClass },
	{ "addAttribute", &LuaResourceSpawn::addAttribute },
	{ "isType", &LuaResourceSpawn::isType },
	{ "setSurveyToolType", &LuaResourceSpawn::setSurveyToolType },
	{ "setIsEnergy", &LuaResourceSpawn::setIsEnergy },
	{ "getName", &LuaResourceSpawn::getName },
	{ "getType", &LuaResourceSpawn::getType },
	{ "getClass", &LuaResourceSpawn::getClass },
	{ "getStfClass", &LuaResourceSpawn::getStfClass },
	{ "getFinalClass", &LuaResourceSpawn::getFinalClass },
	{ "getFamilyName", &LuaResourceSpawn::getFamilyName },
	{ "getSurveyMissionSpawnFamilyName", &LuaResourceSpawn::getSurveyMissionSpawnFamilyName },
	{ "setSpawned", &LuaResourceSpawn::setSpawned },
	{ "setDespawned", &LuaResourceSpawn::setDespawned },
	{ "getDespawned", &LuaResourceSpawn::getDespawned },
	{ "setContainerCRC", &LuaResourceSpawn::setContainerCRC },
	{ "getContainerCRC", &LuaResourceSpawn::getContainerCRC },
	{ "getSpawnPool", &LuaResourceSpawn::getSpawnPool },
	{ "getPoolSlot", &LuaResourceSpawn::getPoolSlot },
	{ "isEnergy", &LuaResourceSpawn::isEnergy },
	{ "getZoneRestriction", &LuaResourceSpawn::getZoneRestriction },
	{ "getSurveyToolType", &LuaResourceSpawn::getSurveyToolType },
	{ "getSpawnMapSize", &LuaResourceSpawn::getSpawnMapSize },
	{ "extractResource", &LuaResourceSpawn::extractResource },
	{ "createResource", &LuaResourceSpawn::createResource },
	{ "getSpawnMapZone", &LuaResourceSpawn::getSpawnMapZone },
	{ "isUnknownType", &LuaResourceSpawn::isUnknownType },
	{ "createSpawnMaps", &LuaResourceSpawn::createSpawnMaps },
	{ "getPlanetCRC", &LuaResourceSpawn::getPlanetCRC },
	{ "getDensityAt", &LuaResourceSpawn::getDensityAt },
	{ "inShift", &LuaResourceSpawn::inShift },
	{ "getAttributeAndValue", &LuaResourceSpawn::getAttributeAndValue },
	{ "getAttributeValue", &LuaResourceSpawn::getAttributeValue },
	{ "getValueOf", &LuaResourceSpawn::getValueOf },
	{ "addStatsToDeedListBox", &LuaResourceSpawn::addStatsToDeedListBox },
	{ "print", &LuaResourceSpawn::print },
	{ 0, 0 }
};

LuaResourceSpawn::LuaResourceSpawn(lua_State *L) {
	realObject = static_cast<ResourceSpawn*>(lua_touserdata(L, 1));
}

LuaResourceSpawn::~LuaResourceSpawn() {
}

int LuaResourceSpawn::_setObject(lua_State* L) {
	realObject = static_cast<ResourceSpawn*>(lua_touserdata(L, -1));

	return 0;
}

int LuaResourceSpawn::_getObject(lua_State* L) {
	lua_pushlightuserdata(L, realObject.get());

	return 1;
}

int LuaResourceSpawn::fillAttributeList(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				AttributeListMessage* msg = static_cast<AttributeListMessage*>(lua_touserdata(L, -2));
				CreatureObject* object = static_cast<CreatureObject*>(lua_touserdata(L, -1));

				realObject->fillAttributeList(msg, object);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:fillAttributeList(userdata, userdata)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ResourceSpawn:fillAttributeList(userdata, userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:fillAttributeList(userdata, userdata)'");
	}
	return 0;
}

int LuaResourceSpawn::decreaseContainerReferenceCount(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		realObject->decreaseContainerReferenceCount();

		return 0;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:decreaseContainerReferenceCount()'");
	}
	return 0;
}

int LuaResourceSpawn::isResourceSpawn(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		bool result = realObject->isResourceSpawn();

		lua_pushboolean(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:isResourceSpawn()'");
	}
	return 0;
}

int LuaResourceSpawn::setName(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String name = lua_tostring(L, -1);

			Locker _guard(realObject);

			realObject->setName(name);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setName(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setName(string)'");
	}
	return 0;
}

int LuaResourceSpawn::setType(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String type = lua_tostring(L, -1);

			Locker _guard(realObject);

			realObject->setType(type);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setType(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setType(string)'");
	}
	return 0;
}

int LuaResourceSpawn::setSpawnPool(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (lua_isnumber(L, -2)) {
			if (parameterCount == 2) {
				int pool = lua_tointeger(L, -2);
				const String slot = lua_tostring(L, -1);

				Locker _guard(realObject);

				realObject->setSpawnPool(pool, slot);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setSpawnPool(integer, string)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ResourceSpawn:setSpawnPool(integer, string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setSpawnPool(integer, string)'");
	}
	return 0;
}

int LuaResourceSpawn::setZoneRestriction(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String zoneName = lua_tostring(L, -1);

			Locker _guard(realObject);

			realObject->setZoneRestriction(zoneName);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setZoneRestriction(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setZoneRestriction(string)'");
	}
	return 0;
}

int LuaResourceSpawn::addClass(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String newclass = lua_tostring(L, -1);

			Locker _guard(realObject);

			realObject->addClass(newclass);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:addClass(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:addClass(string)'");
	}
	return 0;
}

int LuaResourceSpawn::addStfClass(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String newclass = lua_tostring(L, -1);

			Locker _guard(realObject);

			realObject->addStfClass(newclass);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:addStfClass(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:addStfClass(string)'");
	}
	return 0;
}

int LuaResourceSpawn::addAttribute(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (lua_isstring(L, -2)) {
			if (parameterCount == 2) {
				const String attribute = lua_tostring(L, -2);
				int value = lua_tointeger(L, -1);

				Locker _guard(realObject);

				realObject->addAttribute(attribute, value);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:addAttribute(string, integer)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ResourceSpawn:addAttribute(string, integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:addAttribute(string, integer)'");
	}
	return 0;
}

int LuaResourceSpawn::isType(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String type = lua_tostring(L, -1);

			bool result = realObject->isType(type);

			lua_pushboolean(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:isType(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:isType(string)'");
	}
	return 0;
}

int LuaResourceSpawn::setSurveyToolType(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int type = lua_tointeger(L, -1);

			Locker _guard(realObject);

			realObject->setSurveyToolType(type);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setSurveyToolType(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setSurveyToolType(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::setIsEnergy(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isboolean(L, -1)) {
		if (parameterCount == 1) {
			bool val = lua_toboolean(L, -1);

			Locker _guard(realObject);

			realObject->setIsEnergy(val);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setIsEnergy(boolean)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setIsEnergy(boolean)'");
	}
	return 0;
}

int LuaResourceSpawn::getName(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getName();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getName()'");
	}
	return 0;
}

int LuaResourceSpawn::getType(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getType();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getType()'");
	}
	return 0;
}

int LuaResourceSpawn::getClass(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int index = lua_tointeger(L, -1);

			String result = realObject->getClass(index);

			lua_pushstring(L, result.toCharArray());
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getClass(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:getClass(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::getStfClass(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int index = lua_tointeger(L, -1);

			String result = realObject->getStfClass(index);

			lua_pushstring(L, result.toCharArray());
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getStfClass(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:getStfClass(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::getFinalClass(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getFinalClass();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getFinalClass()'");
	}
	return 0;
}

int LuaResourceSpawn::getFamilyName(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getFamilyName();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getFamilyName()'");
	}
	return 0;
}

int LuaResourceSpawn::getSurveyMissionSpawnFamilyName(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getSurveyMissionSpawnFamilyName();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getSurveyMissionSpawnFamilyName()'");
	}
	return 0;
}

int LuaResourceSpawn::setSpawned(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			unsigned long long t = lua_tointeger(L, -1);

			Locker _guard(realObject);

			realObject->setSpawned(t);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setSpawned(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setSpawned(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::setDespawned(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			unsigned long long t = lua_tointeger(L, -1);

			Locker _guard(realObject);

			realObject->setDespawned(t);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setDespawned(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setDespawned(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::getDespawned(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		unsigned long long result = realObject->getDespawned();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getDespawned()'");
	}
	return 0;
}

int LuaResourceSpawn::setContainerCRC(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			unsigned int crc = lua_tointeger(L, -1);

			Locker _guard(realObject);

			realObject->setContainerCRC(crc);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:setContainerCRC(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:setContainerCRC(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::getContainerCRC(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		unsigned int result = realObject->getContainerCRC();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getContainerCRC()'");
	}
	return 0;
}

int LuaResourceSpawn::getSpawnPool(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getSpawnPool();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getSpawnPool()'");
	}
	return 0;
}

int LuaResourceSpawn::getPoolSlot(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getPoolSlot();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getPoolSlot()'");
	}
	return 0;
}

int LuaResourceSpawn::isEnergy(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		bool result = realObject->isEnergy();

		lua_pushboolean(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:isEnergy()'");
	}
	return 0;
}

int LuaResourceSpawn::getZoneRestriction(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getZoneRestriction();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getZoneRestriction()'");
	}
	return 0;
}

int LuaResourceSpawn::getSurveyToolType(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getSurveyToolType();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getSurveyToolType()'");
	}
	return 0;
}

int LuaResourceSpawn::getSpawnMapSize(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getSpawnMapSize();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getSpawnMapSize()'");
	}
	return 0;
}

int LuaResourceSpawn::extractResource(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (lua_isstring(L, -2)) {
			if (parameterCount == 2) {
				const String zoneName = lua_tostring(L, -2);
				int units = lua_tointeger(L, -1);

				Locker _guard(realObject);

				realObject->extractResource(zoneName, units);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:extractResource(string, integer)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ResourceSpawn:extractResource(string, integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:extractResource(string, integer)'");
	}
	return 0;
}

int LuaResourceSpawn::createResource(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int units = lua_tointeger(L, -1);

			Locker _guard(realObject);

			ResourceContainer* result = realObject->createResource(units);

			if (result != NULL)
				lua_pushlightuserdata(L, result);
			else
				lua_pushnil(L);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:createResource(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:createResource(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::getSpawnMapZone(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int i = lua_tointeger(L, -1);

			String result = realObject->getSpawnMapZone(i);

			lua_pushstring(L, result.toCharArray());
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getSpawnMapZone(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:getSpawnMapZone(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::isUnknownType(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		bool result = realObject->isUnknownType();

		lua_pushboolean(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:isUnknownType()'");
	}
	return 0;
}

int LuaResourceSpawn::createSpawnMaps(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	return 0;
}

int LuaResourceSpawn::getPlanetCRC(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		unsigned int result = realObject->getPlanetCRC();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getPlanetCRC()'");
	}
	return 0;
}

int LuaResourceSpawn::getDensityAt(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (lua_isnumber(L, -2)) {
			if (lua_isstring(L, -3)) {
				if (parameterCount == 3) {
					const String zoneName = lua_tostring(L, -3);
					float x = lua_tonumber(L, -2);
					float y = lua_tonumber(L, -1);

					float result = realObject->getDensityAt(zoneName, x, y);

					lua_pushnumber(L, result);
					return 1;
				} else {
					throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getDensityAt(string, number, number)'");
				}
			} else {
				throw LuaCallbackException(L, "invalid argument at 2 for lua method 'ResourceSpawn:getDensityAt(string, number, number)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ResourceSpawn:getDensityAt(string, number, number)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:getDensityAt(string, number, number)'");
	}
	return 0;
}

int LuaResourceSpawn::inShift(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		bool result = realObject->inShift();

		lua_pushboolean(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:inShift()'");
	}
	return 0;
}

int LuaResourceSpawn::getAttributeAndValue(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (lua_isstring(L, -2)) {
			if (parameterCount == 2) {
				String attribute = lua_tostring(L, -2);
				int index = lua_tointeger(L, -1);

				int result = realObject->getAttributeAndValue(attribute, index);

				lua_pushinteger(L, result);
				return 1;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getAttributeAndValue(string, integer)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ResourceSpawn:getAttributeAndValue(string, integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:getAttributeAndValue(string, integer)'");
	}
	return 0;
}

int LuaResourceSpawn::getAttributeValue(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int index = lua_tointeger(L, -1);

			int result = realObject->getAttributeValue(index);

			lua_pushinteger(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:getAttributeValue(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:getAttributeValue(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::getValueOf(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String attribute = lua_tostring(L, -1);

			int result = realObject->getValueOf(attribute);

			lua_pushinteger(L, result);
			return 1;
		}
	} else if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int index = lua_tointeger(L, -1);

			int result = realObject->getValueOf(index);

			lua_pushinteger(L, result);
			return 1;
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:getValueOf(integer)'");
	}
	return 0;
}

int LuaResourceSpawn::addStatsToDeedListBox(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (parameterCount == 1) {
			SuiListBox* suil = static_cast<SuiListBox*>(lua_touserdata(L, -1));

			realObject->addStatsToDeedListBox(suil);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:addStatsToDeedListBox(userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ResourceSpawn:addStatsToDeedListBox(userdata)'");
	}
	return 0;
}

int LuaResourceSpawn::print(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		realObject->print();

		return 0;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ResourceSpawn:print()'");
	}
	return 0;
}

/*
 *	ResourceSpawnPOD
 */

ResourceSpawnPOD::~ResourceSpawnPOD() {
	finalize();
}

ResourceSpawnPOD::ResourceSpawnPOD(void) {
	_className = "ResourceSpawn";
}


void ResourceSpawnPOD::writeJSON(nlohmann::json& j) {
	SceneObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (spawnType)
		thisObject["spawnType"] = spawnType.value();

	if (spawnName)
		thisObject["spawnName"] = spawnName.value();

	if (spawnClasses)
		thisObject["spawnClasses"] = spawnClasses.value();

	if (stfSpawnClasses)
		thisObject["stfSpawnClasses"] = stfSpawnClasses.value();

	if (spawnAttributes)
		thisObject["spawnAttributes"] = spawnAttributes.value();

	if (poolSlot)
		thisObject["poolSlot"] = poolSlot.value();

	if (spawnPool)
		thisObject["spawnPool"] = spawnPool.value();

	if (zoneRestriction)
		thisObject["zoneRestriction"] = zoneRestriction.value();

	if (surveyToolType)
		thisObject["surveyToolType"] = surveyToolType.value();

	if (containerCRC)
		thisObject["containerCRC"] = containerCRC.value();

	if (spawned)
		thisObject["spawned"] = spawned.value();

	if (despawned)
		thisObject["despawned"] = despawned.value();

	if (spawnMaps)
		thisObject["spawnMaps"] = spawnMaps.value();

	if (maxUnitsSpawned)
		thisObject["maxUnitsSpawned"] = maxUnitsSpawned.value();

	if (unitsInCirculation)
		thisObject["unitsInCirculation"] = unitsInCirculation.value();

	if (containerReferenceCount)
		thisObject["containerReferenceCount"] = containerReferenceCount.value();

	if (dbDestroyed)
		thisObject["dbDestroyed"] = dbDestroyed.value();

	if (energy)
		thisObject["energy"] = energy.value();

	j["ResourceSpawn"] = thisObject;
}


void ResourceSpawnPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ResourceSpawnPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ResourceSpawnPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (spawnType) {
	_nameHashCode = 0x64bf9f27; //ResourceSpawn.spawnType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&spawnType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spawnName) {
	_nameHashCode = 0xc830962b; //ResourceSpawn.spawnName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&spawnName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spawnClasses) {
	_nameHashCode = 0x4c6462c0; //ResourceSpawn.spawnClasses
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&spawnClasses.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (stfSpawnClasses) {
	_nameHashCode = 0x975988f9; //ResourceSpawn.stfSpawnClasses
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&stfSpawnClasses.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spawnAttributes) {
	_nameHashCode = 0x18da759d; //ResourceSpawn.spawnAttributes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&spawnAttributes.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (poolSlot) {
	_nameHashCode = 0xb1bc58cd; //ResourceSpawn.poolSlot
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&poolSlot.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spawnPool) {
	_nameHashCode = 0x8e0ca674; //ResourceSpawn.spawnPool
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&spawnPool.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (zoneRestriction) {
	_nameHashCode = 0x895b3fce; //ResourceSpawn.zoneRestriction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&zoneRestriction.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (surveyToolType) {
	_nameHashCode = 0x7f76595d; //ResourceSpawn.surveyToolType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&surveyToolType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (containerCRC) {
	_nameHashCode = 0x6458e9e6; //ResourceSpawn.containerCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&containerCRC.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spawned) {
	_nameHashCode = 0x309fa8e6; //ResourceSpawn.spawned
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&spawned.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (despawned) {
	_nameHashCode = 0xa5f8c907; //ResourceSpawn.despawned
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&despawned.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spawnMaps) {
	_nameHashCode = 0xf3f48ab3; //ResourceSpawn.spawnMaps
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SpawnMap >::toBinaryStream(&spawnMaps.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxUnitsSpawned) {
	_nameHashCode = 0xad93bc4; //ResourceSpawn.maxUnitsSpawned
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&maxUnitsSpawned.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (unitsInCirculation) {
	_nameHashCode = 0x4443a30e; //ResourceSpawn.unitsInCirculation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&unitsInCirculation.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (containerReferenceCount) {
	_nameHashCode = 0xcc6e7c3f; //ResourceSpawn.containerReferenceCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&containerReferenceCount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dbDestroyed) {
	_nameHashCode = 0xef3b250a; //ResourceSpawn.dbDestroyed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&dbDestroyed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (energy) {
	_nameHashCode = 0x1e6aab53; //ResourceSpawn.energy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&energy.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool ResourceSpawnPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x64bf9f27: //ResourceSpawn.spawnType
		{
			String _mnspawnType;
			TypeInfo<String >::parseFromBinaryStream(&_mnspawnType, stream);
			spawnType = std::move(_mnspawnType);
		}
		return true;

	case 0xc830962b: //ResourceSpawn.spawnName
		{
			String _mnspawnName;
			TypeInfo<String >::parseFromBinaryStream(&_mnspawnName, stream);
			spawnName = std::move(_mnspawnName);
		}
		return true;

	case 0x4c6462c0: //ResourceSpawn.spawnClasses
		{
			Vector<String> _mnspawnClasses;
			TypeInfo<Vector<String> >::parseFromBinaryStream(&_mnspawnClasses, stream);
			spawnClasses = std::move(_mnspawnClasses);
		}
		return true;

	case 0x975988f9: //ResourceSpawn.stfSpawnClasses
		{
			Vector<String> _mnstfSpawnClasses;
			TypeInfo<Vector<String> >::parseFromBinaryStream(&_mnstfSpawnClasses, stream);
			stfSpawnClasses = std::move(_mnstfSpawnClasses);
		}
		return true;

	case 0x18da759d: //ResourceSpawn.spawnAttributes
		{
			VectorMap<String, int> _mnspawnAttributes;
			TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&_mnspawnAttributes, stream);
			spawnAttributes = std::move(_mnspawnAttributes);
		}
		return true;

	case 0xb1bc58cd: //ResourceSpawn.poolSlot
		{
			String _mnpoolSlot;
			TypeInfo<String >::parseFromBinaryStream(&_mnpoolSlot, stream);
			poolSlot = std::move(_mnpoolSlot);
		}
		return true;

	case 0x8e0ca674: //ResourceSpawn.spawnPool
		{
			int _mnspawnPool;
			TypeInfo<int >::parseFromBinaryStream(&_mnspawnPool, stream);
			spawnPool = std::move(_mnspawnPool);
		}
		return true;

	case 0x895b3fce: //ResourceSpawn.zoneRestriction
		{
			String _mnzoneRestriction;
			TypeInfo<String >::parseFromBinaryStream(&_mnzoneRestriction, stream);
			zoneRestriction = std::move(_mnzoneRestriction);
		}
		return true;

	case 0x7f76595d: //ResourceSpawn.surveyToolType
		{
			int _mnsurveyToolType;
			TypeInfo<int >::parseFromBinaryStream(&_mnsurveyToolType, stream);
			surveyToolType = std::move(_mnsurveyToolType);
		}
		return true;

	case 0x6458e9e6: //ResourceSpawn.containerCRC
		{
			unsigned int _mncontainerCRC;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mncontainerCRC, stream);
			containerCRC = std::move(_mncontainerCRC);
		}
		return true;

	case 0x309fa8e6: //ResourceSpawn.spawned
		{
			unsigned long long _mnspawned;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnspawned, stream);
			spawned = std::move(_mnspawned);
		}
		return true;

	case 0xa5f8c907: //ResourceSpawn.despawned
		{
			unsigned long long _mndespawned;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mndespawned, stream);
			despawned = std::move(_mndespawned);
		}
		return true;

	case 0xf3f48ab3: //ResourceSpawn.spawnMaps
		{
			SpawnMap _mnspawnMaps;
			TypeInfo<SpawnMap >::parseFromBinaryStream(&_mnspawnMaps, stream);
			spawnMaps = std::move(_mnspawnMaps);
		}
		return true;

	case 0xad93bc4: //ResourceSpawn.maxUnitsSpawned
		{
			unsigned long long _mnmaxUnitsSpawned;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnmaxUnitsSpawned, stream);
			maxUnitsSpawned = std::move(_mnmaxUnitsSpawned);
		}
		return true;

	case 0x4443a30e: //ResourceSpawn.unitsInCirculation
		{
			unsigned long long _mnunitsInCirculation;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnunitsInCirculation, stream);
			unitsInCirculation = std::move(_mnunitsInCirculation);
		}
		return true;

	case 0xcc6e7c3f: //ResourceSpawn.containerReferenceCount
		{
			int _mncontainerReferenceCount;
			TypeInfo<int >::parseFromBinaryStream(&_mncontainerReferenceCount, stream);
			containerReferenceCount = std::move(_mncontainerReferenceCount);
		}
		return true;

	case 0xef3b250a: //ResourceSpawn.dbDestroyed
		{
			bool _mndbDestroyed;
			TypeInfo<bool >::parseFromBinaryStream(&_mndbDestroyed, stream);
			dbDestroyed = std::move(_mndbDestroyed);
		}
		return true;

	case 0x1e6aab53: //ResourceSpawn.energy
		{
			bool _mnenergy;
			TypeInfo<bool >::parseFromBinaryStream(&_mnenergy, stream);
			energy = std::move(_mnenergy);
		}
		return true;

	}

	return false;
}

void ResourceSpawnPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ResourceSpawnPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ResourceSpawnPOD::writeObjectCompact(ObjectOutputStream* stream) {
	SceneObjectPOD::writeObjectCompact(stream);

	TypeInfo<String >::toBinaryStream(&spawnType.value(), stream);

	TypeInfo<String >::toBinaryStream(&spawnName.value(), stream);

	TypeInfo<Vector<String> >::toBinaryStream(&spawnClasses.value(), stream);

	TypeInfo<Vector<String> >::toBinaryStream(&stfSpawnClasses.value(), stream);

	TypeInfo<VectorMap<String, int> >::toBinaryStream(&spawnAttributes.value(), stream);

	TypeInfo<String >::toBinaryStream(&poolSlot.value(), stream);

	TypeInfo<int >::toBinaryStream(&spawnPool.value(), stream);

	TypeInfo<String >::toBinaryStream(&zoneRestriction.value(), stream);

	TypeInfo<int >::toBinaryStream(&surveyToolType.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&containerCRC.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&spawned.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&despawned.value(), stream);

	TypeInfo<SpawnMap >::toBinaryStream(&spawnMaps.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&maxUnitsSpawned.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&unitsInCirculation.value(), stream);

	TypeInfo<int >::toBinaryStream(&containerReferenceCount.value(), stream);

	TypeInfo<bool >::toBinaryStream(&dbDestroyed.value(), stream);

	TypeInfo<bool >::toBinaryStream(&energy.value(), stream);


}

