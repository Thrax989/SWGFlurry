/*
 *	autogen/server/zone/objects/tangible/misc/ContractCrate.cpp generated by engine3 IDL compiler 0.70
 */

#include "ContractCrate.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/Zone.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/ZoneServer.h"

/*
 *	ContractCrateStub
 */

enum {RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_,RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_,RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_,RPC_CHECKCONTAINERPERMISSION__CREATUREOBJECT_SHORT_,RPC_PARSEDRAFTSCHEMATIC__STRING_,RPC_SETREQUIREDITEM__STRING_,RPC_SETAMOUNTNEEDED__INT_,RPC_GETCRATEDIFFICULTY__,RPC_GETAMOUNTNEEDED__,RPC_SETCRATEDIFFICULTY__INT_,RPC_SETXPTYPE__STRING_,RPC_GETXPTYPE__,RPC_GETXPAMOUNT__,RPC_ISCOMPLETED__};

ContractCrate::ContractCrate() : TangibleObject(DummyConstructorParameter::instance()) {
	ContractCrateImplementation* _implementation = new ContractCrateImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("ContractCrate");
}

ContractCrate::ContractCrate(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("ContractCrate");
}

ContractCrate::~ContractCrate() {
}



void ContractCrate::fillAttributeList(AttributeListMessage* msg, CreatureObject* player) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, player);
	}
}

int ContractCrate::canAddObject(SceneObject* object, int containmentType, String& errorDescription) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_);
		method.addObjectParameter(object);
		method.addSignedIntParameter(containmentType);
		method.addAsciiParameter(errorDescription);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->canAddObject(object, containmentType, errorDescription);
	}
}

int ContractCrate::notifyObjectInserted(SceneObject* object) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObjectInserted(object);
	}
}

int ContractCrate::notifyObjectRemoved(SceneObject* object) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObjectRemoved(object);
	}
}

byte ContractCrate::checkContainerPermission(CreatureObject* player, unsigned short permission) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKCONTAINERPERMISSION__CREATUREOBJECT_SHORT_);
		method.addObjectParameter(player);
		method.addUnsignedShortParameter(permission);

		return method.executeWithByteReturn();
	} else {
		return _implementation->checkContainerPermission(player, permission);
	}
}

void ContractCrate::parseDraftSchematic(const String& schematic) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PARSEDRAFTSCHEMATIC__STRING_);
		method.addAsciiParameter(schematic);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->parseDraftSchematic(schematic);
	}
}

void ContractCrate::setRequiredItem(const String& item) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETREQUIREDITEM__STRING_);
		method.addAsciiParameter(item);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRequiredItem(item);
	}
}

void ContractCrate::setAmountNeeded(int amt) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAMOUNTNEEDED__INT_);
		method.addSignedIntParameter(amt);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAmountNeeded(amt);
	}
}

int ContractCrate::getCrateDifficulty() const {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCRATEDIFFICULTY__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCrateDifficulty();
	}
}

int ContractCrate::getAmountNeeded() const {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAMOUNTNEEDED__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAmountNeeded();
	}
}

void ContractCrate::setCrateDifficulty(int diff) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCRATEDIFFICULTY__INT_);
		method.addSignedIntParameter(diff);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCrateDifficulty(diff);
	}
}

void ContractCrate::setXpType(const String& type) {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETXPTYPE__STRING_);
		method.addAsciiParameter(type);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setXpType(type);
	}
}

String ContractCrate::getXpType() const {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETXPTYPE__);

		String _return_getXpType;
		method.executeWithAsciiReturn(_return_getXpType);
		return _return_getXpType;
	} else {
		return _implementation->getXpType();
	}
}

int ContractCrate::getXpAmount() const {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETXPAMOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getXpAmount();
	}
}

bool ContractCrate::isCompleted() {
	ContractCrateImplementation* _implementation = static_cast<ContractCrateImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCOMPLETED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCompleted();
	}
}

DistributedObjectServant* ContractCrate::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* ContractCrate::_getImplementationForRead() const {
	return _impl;
}

void ContractCrate::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ContractCrateImplementation
 */

ContractCrateImplementation::ContractCrateImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


ContractCrateImplementation::~ContractCrateImplementation() {
}


void ContractCrateImplementation::finalize() {
}

void ContractCrateImplementation::_initializeImplementation() {
	_setClassHelper(ContractCrateHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ContractCrateImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<ContractCrate*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ContractCrateImplementation::_getStub() {
	return _this.get();
}

ContractCrateImplementation::operator const ContractCrate*() {
	return _this.get();
}

void ContractCrateImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ContractCrateImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ContractCrateImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ContractCrateImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ContractCrateImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ContractCrateImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ContractCrateImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ContractCrateImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("ContractCrate");

}

void ContractCrateImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ContractCrateImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ContractCrateImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x2ac9f30b: //ContractCrate.requiredItem
		TypeInfo<String >::parseFromBinaryStream(&requiredItem, stream);
		return true;

	case 0x32f3e3f5: //ContractCrate.xpType
		TypeInfo<String >::parseFromBinaryStream(&xpType, stream);
		return true;

	case 0x45c407aa: //ContractCrate.itemName
		TypeInfo<String >::parseFromBinaryStream(&itemName, stream);
		return true;

	case 0x1c68ae3e: //ContractCrate.amountNeeded
		TypeInfo<int >::parseFromBinaryStream(&amountNeeded, stream);
		return true;

	case 0x511f90da: //ContractCrate.currentAmount
		TypeInfo<int >::parseFromBinaryStream(&currentAmount, stream);
		return true;

	case 0x9894425f: //ContractCrate.xpAmount
		TypeInfo<int >::parseFromBinaryStream(&xpAmount, stream);
		return true;

	case 0xa6c5400f: //ContractCrate.crateDifficulty
		TypeInfo<int >::parseFromBinaryStream(&crateDifficulty, stream);
		return true;

	}

	return false;
}

void ContractCrateImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ContractCrateImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ContractCrateImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x2ac9f30b; //ContractCrate.requiredItem
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&requiredItem, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x32f3e3f5; //ContractCrate.xpType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&xpType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x45c407aa; //ContractCrate.itemName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&itemName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1c68ae3e; //ContractCrate.amountNeeded
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&amountNeeded, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x511f90da; //ContractCrate.currentAmount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&currentAmount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9894425f; //ContractCrate.xpAmount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&xpAmount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa6c5400f; //ContractCrate.crateDifficulty
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&crateDifficulty, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void ContractCrateImplementation::writeJSON(nlohmann::json& j) {
	TangibleObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["requiredItem"] = requiredItem;

	thisObject["xpType"] = xpType;

	thisObject["itemName"] = itemName;

	thisObject["amountNeeded"] = amountNeeded;

	thisObject["currentAmount"] = currentAmount;

	thisObject["xpAmount"] = xpAmount;

	thisObject["crateDifficulty"] = crateDifficulty;

	j["ContractCrate"] = thisObject;
}

ContractCrateImplementation::ContractCrateImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		setLoggingName("ContractCrate");
	setLoggingName("ContractCrate");
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		requiredItem = "";
	requiredItem = "";
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		xpType = "";
	xpType = "";
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		itemName = "";
	itemName = "";
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		xpAmount = 0;
	xpAmount = 0;
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		amountNeeded = 0;
	amountNeeded = 0;
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		currentAmount = 0;
	currentAmount = 0;
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		crateDifficulty = 0;
	crateDifficulty = 0;
}

void ContractCrateImplementation::setRequiredItem(const String& item) {
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		requiredItem = item;
	requiredItem = item;
}

void ContractCrateImplementation::setAmountNeeded(int amt) {
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		amountNeeded = amt;
	amountNeeded = amt;
}

int ContractCrateImplementation::getCrateDifficulty() const{
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		return crateDifficulty;
	return crateDifficulty;
}

int ContractCrateImplementation::getAmountNeeded() const{
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		return amountNeeded;
	return amountNeeded;
}

void ContractCrateImplementation::setCrateDifficulty(int diff) {
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		crateDifficulty = diff;
	crateDifficulty = diff;
}

void ContractCrateImplementation::setXpType(const String& type) {
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		xpType = type;
	xpType = type;
}

String ContractCrateImplementation::getXpType() const{
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		return xpType;
	return xpType;
}

int ContractCrateImplementation::getXpAmount() const{
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		return xpAmount;
	return xpAmount;
}

bool ContractCrateImplementation::isCompleted() {
	// server/zone/objects/tangible/misc/ContractCrate.idl():  		return currentAmount == amountNeeded;
	return currentAmount == amountNeeded;
}

/*
 *	ContractCrateAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ContractCrateAdapter::ContractCrateAdapter(ContractCrate* obj) : TangibleObjectAdapter(obj) {
}

void ContractCrateAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_CANADDOBJECT__SCENEOBJECT_INT_STRING_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			int containmentType = inv->getSignedIntParameter();
			String errorDescription; inv->getAsciiParameter(errorDescription);
			
			int _m_res = canAddObject(object, containmentType, errorDescription);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYOBJECTINSERTED__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			int _m_res = notifyObjectInserted(object);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYOBJECTREMOVED__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			int _m_res = notifyObjectRemoved(object);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CHECKCONTAINERPERMISSION__CREATUREOBJECT_SHORT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned short permission = inv->getUnsignedShortParameter();
			
			byte _m_res = checkContainerPermission(player, permission);
			resp->insertByte(_m_res);
		}
		break;
	case RPC_PARSEDRAFTSCHEMATIC__STRING_:
		{
			 String schematic; inv->getAsciiParameter(schematic);
			
			parseDraftSchematic(schematic);
			
		}
		break;
	case RPC_SETREQUIREDITEM__STRING_:
		{
			 String item; inv->getAsciiParameter(item);
			
			setRequiredItem(item);
			
		}
		break;
	case RPC_SETAMOUNTNEEDED__INT_:
		{
			int amt = inv->getSignedIntParameter();
			
			setAmountNeeded(amt);
			
		}
		break;
	case RPC_GETCRATEDIFFICULTY__:
		{
			
			int _m_res = getCrateDifficulty();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETAMOUNTNEEDED__:
		{
			
			int _m_res = getAmountNeeded();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETCRATEDIFFICULTY__INT_:
		{
			int diff = inv->getSignedIntParameter();
			
			setCrateDifficulty(diff);
			
		}
		break;
	case RPC_SETXPTYPE__STRING_:
		{
			 String type; inv->getAsciiParameter(type);
			
			setXpType(type);
			
		}
		break;
	case RPC_GETXPTYPE__:
		{
			
			String _m_res = getXpType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETXPAMOUNT__:
		{
			
			int _m_res = getXpAmount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISCOMPLETED__:
		{
			
			bool _m_res = isCompleted();
			resp->insertBoolean(_m_res);
		}
		break;
	default:
		TangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

int ContractCrateAdapter::canAddObject(SceneObject* object, int containmentType, String& errorDescription) {
	return (static_cast<ContractCrate*>(stub))->canAddObject(object, containmentType, errorDescription);
}

int ContractCrateAdapter::notifyObjectInserted(SceneObject* object) {
	return (static_cast<ContractCrate*>(stub))->notifyObjectInserted(object);
}

int ContractCrateAdapter::notifyObjectRemoved(SceneObject* object) {
	return (static_cast<ContractCrate*>(stub))->notifyObjectRemoved(object);
}

byte ContractCrateAdapter::checkContainerPermission(CreatureObject* player, unsigned short permission) {
	return (static_cast<ContractCrate*>(stub))->checkContainerPermission(player, permission);
}

void ContractCrateAdapter::parseDraftSchematic(const String& schematic) {
	(static_cast<ContractCrate*>(stub))->parseDraftSchematic(schematic);
}

void ContractCrateAdapter::setRequiredItem(const String& item) {
	(static_cast<ContractCrate*>(stub))->setRequiredItem(item);
}

void ContractCrateAdapter::setAmountNeeded(int amt) {
	(static_cast<ContractCrate*>(stub))->setAmountNeeded(amt);
}

int ContractCrateAdapter::getCrateDifficulty() const {
	return (static_cast<ContractCrate*>(stub))->getCrateDifficulty();
}

int ContractCrateAdapter::getAmountNeeded() const {
	return (static_cast<ContractCrate*>(stub))->getAmountNeeded();
}

void ContractCrateAdapter::setCrateDifficulty(int diff) {
	(static_cast<ContractCrate*>(stub))->setCrateDifficulty(diff);
}

void ContractCrateAdapter::setXpType(const String& type) {
	(static_cast<ContractCrate*>(stub))->setXpType(type);
}

String ContractCrateAdapter::getXpType() const {
	return (static_cast<ContractCrate*>(stub))->getXpType();
}

int ContractCrateAdapter::getXpAmount() const {
	return (static_cast<ContractCrate*>(stub))->getXpAmount();
}

bool ContractCrateAdapter::isCompleted() {
	return (static_cast<ContractCrate*>(stub))->isCompleted();
}

/*
 *	ContractCrateHelper
 */

ContractCrateHelper* ContractCrateHelper::staticInitializer = ContractCrateHelper::instance();

ContractCrateHelper::ContractCrateHelper() {
	className = "ContractCrate";

	Core::getObjectBroker()->registerClass(className, this);
}

void ContractCrateHelper::finalizeHelper() {
	ContractCrateHelper::finalize();
}

DistributedObject* ContractCrateHelper::instantiateObject() {
	return new ContractCrate(DummyConstructorParameter::instance());
}

DistributedObjectServant* ContractCrateHelper::instantiateServant() {
	return new ContractCrateImplementation();
}

DistributedObjectPOD* ContractCrateHelper::instantiatePOD() {
	return new ContractCratePOD();
}

DistributedObjectAdapter* ContractCrateHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ContractCrateAdapter(static_cast<ContractCrate*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

const char LuaContractCrate::className[] = "LuaContractCrate";

Luna<LuaContractCrate>::RegType LuaContractCrate::Register[] = {
	{ "_setObject", &LuaContractCrate::_setObject },
	{ "_getObject", &LuaContractCrate::_getObject },
	{ "fillAttributeList", &LuaContractCrate::fillAttributeList },
	{ "canAddObject", &LuaContractCrate::canAddObject },
	{ "notifyObjectInserted", &LuaContractCrate::notifyObjectInserted },
	{ "notifyObjectRemoved", &LuaContractCrate::notifyObjectRemoved },
	{ "checkContainerPermission", &LuaContractCrate::checkContainerPermission },
	{ "parseDraftSchematic", &LuaContractCrate::parseDraftSchematic },
	{ "setRequiredItem", &LuaContractCrate::setRequiredItem },
	{ "setAmountNeeded", &LuaContractCrate::setAmountNeeded },
	{ "getCrateDifficulty", &LuaContractCrate::getCrateDifficulty },
	{ "getAmountNeeded", &LuaContractCrate::getAmountNeeded },
	{ "setCrateDifficulty", &LuaContractCrate::setCrateDifficulty },
	{ "setXpType", &LuaContractCrate::setXpType },
	{ "getXpType", &LuaContractCrate::getXpType },
	{ "getXpAmount", &LuaContractCrate::getXpAmount },
	{ "isCompleted", &LuaContractCrate::isCompleted },
	{ 0, 0 }
};

LuaContractCrate::LuaContractCrate(lua_State *L) {
	realObject = static_cast<ContractCrate*>(lua_touserdata(L, 1));
}

LuaContractCrate::~LuaContractCrate() {
}

int LuaContractCrate::_setObject(lua_State* L) {
	realObject = static_cast<ContractCrate*>(lua_touserdata(L, -1));

	return 0;
}

int LuaContractCrate::_getObject(lua_State* L) {
	lua_pushlightuserdata(L, realObject.get());

	return 1;
}

int LuaContractCrate::fillAttributeList(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				AttributeListMessage* msg = static_cast<AttributeListMessage*>(lua_touserdata(L, -2));
				CreatureObject* player = static_cast<CreatureObject*>(lua_touserdata(L, -1));

				realObject->fillAttributeList(msg, player);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:fillAttributeList(userdata, userdata)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ContractCrate:fillAttributeList(userdata, userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:fillAttributeList(userdata, userdata)'");
	}
	return 0;
}

int LuaContractCrate::canAddObject(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (lua_isnumber(L, -2)) {
			if (lua_isuserdata(L, -3)) {
				if (parameterCount == 3) {
					SceneObject* object = static_cast<SceneObject*>(lua_touserdata(L, -3));
					int containmentType = lua_tointeger(L, -2);
					String errorDescription = lua_tostring(L, -1);

					int result = realObject->canAddObject(object, containmentType, errorDescription);

					lua_pushinteger(L, result);
					return 1;
				} else {
					throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:canAddObject(userdata, integer, string)'");
				}
			} else {
				throw LuaCallbackException(L, "invalid argument at 2 for lua method 'ContractCrate:canAddObject(userdata, integer, string)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ContractCrate:canAddObject(userdata, integer, string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:canAddObject(userdata, integer, string)'");
	}
	return 0;
}

int LuaContractCrate::notifyObjectInserted(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (parameterCount == 1) {
			SceneObject* object = static_cast<SceneObject*>(lua_touserdata(L, -1));

			int result = realObject->notifyObjectInserted(object);

			lua_pushinteger(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:notifyObjectInserted(userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:notifyObjectInserted(userdata)'");
	}
	return 0;
}

int LuaContractCrate::notifyObjectRemoved(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (parameterCount == 1) {
			SceneObject* object = static_cast<SceneObject*>(lua_touserdata(L, -1));

			int result = realObject->notifyObjectRemoved(object);

			lua_pushinteger(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:notifyObjectRemoved(userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:notifyObjectRemoved(userdata)'");
	}
	return 0;
}

int LuaContractCrate::checkContainerPermission(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				CreatureObject* player = static_cast<CreatureObject*>(lua_touserdata(L, -2));
				unsigned short permission = lua_tointeger(L, -1);

				byte result = realObject->checkContainerPermission(player, permission);

				lua_pushinteger(L, result);
				return 1;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:checkContainerPermission(userdata, integer)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'ContractCrate:checkContainerPermission(userdata, integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:checkContainerPermission(userdata, integer)'");
	}
	return 0;
}

int LuaContractCrate::parseDraftSchematic(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String schematic = lua_tostring(L, -1);

			Locker _guard(realObject);

			realObject->parseDraftSchematic(schematic);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:parseDraftSchematic(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:parseDraftSchematic(string)'");
	}
	return 0;
}

int LuaContractCrate::setRequiredItem(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String item = lua_tostring(L, -1);

			Locker _guard(realObject);

			realObject->setRequiredItem(item);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:setRequiredItem(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:setRequiredItem(string)'");
	}
	return 0;
}

int LuaContractCrate::setAmountNeeded(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int amt = lua_tointeger(L, -1);

			Locker _guard(realObject);

			realObject->setAmountNeeded(amt);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:setAmountNeeded(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:setAmountNeeded(integer)'");
	}
	return 0;
}

int LuaContractCrate::getCrateDifficulty(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getCrateDifficulty();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:getCrateDifficulty()'");
	}
	return 0;
}

int LuaContractCrate::getAmountNeeded(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getAmountNeeded();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:getAmountNeeded()'");
	}
	return 0;
}

int LuaContractCrate::setCrateDifficulty(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			int diff = lua_tointeger(L, -1);

			Locker _guard(realObject);

			realObject->setCrateDifficulty(diff);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:setCrateDifficulty(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:setCrateDifficulty(integer)'");
	}
	return 0;
}

int LuaContractCrate::setXpType(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String type = lua_tostring(L, -1);

			Locker _guard(realObject);

			realObject->setXpType(type);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:setXpType(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'ContractCrate:setXpType(string)'");
	}
	return 0;
}

int LuaContractCrate::getXpType(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		String result = realObject->getXpType();

		lua_pushstring(L, result.toCharArray());
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:getXpType()'");
	}
	return 0;
}

int LuaContractCrate::getXpAmount(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getXpAmount();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:getXpAmount()'");
	}
	return 0;
}

int LuaContractCrate::isCompleted(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		bool result = realObject->isCompleted();

		lua_pushboolean(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'ContractCrate:isCompleted()'");
	}
	return 0;
}

/*
 *	ContractCratePOD
 */

ContractCratePOD::~ContractCratePOD() {
	finalize();
}

ContractCratePOD::ContractCratePOD(void) {
	_className = "ContractCrate";
}


void ContractCratePOD::writeJSON(nlohmann::json& j) {
	TangibleObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (requiredItem)
		thisObject["requiredItem"] = requiredItem.value();

	if (xpType)
		thisObject["xpType"] = xpType.value();

	if (itemName)
		thisObject["itemName"] = itemName.value();

	if (amountNeeded)
		thisObject["amountNeeded"] = amountNeeded.value();

	if (currentAmount)
		thisObject["currentAmount"] = currentAmount.value();

	if (xpAmount)
		thisObject["xpAmount"] = xpAmount.value();

	if (crateDifficulty)
		thisObject["crateDifficulty"] = crateDifficulty.value();

	j["ContractCrate"] = thisObject;
}


void ContractCratePOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ContractCratePOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ContractCratePOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (requiredItem) {
	_nameHashCode = 0x2ac9f30b; //ContractCrate.requiredItem
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&requiredItem.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (xpType) {
	_nameHashCode = 0x32f3e3f5; //ContractCrate.xpType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&xpType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (itemName) {
	_nameHashCode = 0x45c407aa; //ContractCrate.itemName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&itemName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (amountNeeded) {
	_nameHashCode = 0x1c68ae3e; //ContractCrate.amountNeeded
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&amountNeeded.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (currentAmount) {
	_nameHashCode = 0x511f90da; //ContractCrate.currentAmount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&currentAmount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (xpAmount) {
	_nameHashCode = 0x9894425f; //ContractCrate.xpAmount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&xpAmount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (crateDifficulty) {
	_nameHashCode = 0xa6c5400f; //ContractCrate.crateDifficulty
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&crateDifficulty.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool ContractCratePOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x2ac9f30b: //ContractCrate.requiredItem
		{
			String _mnrequiredItem;
			TypeInfo<String >::parseFromBinaryStream(&_mnrequiredItem, stream);
			requiredItem = std::move(_mnrequiredItem);
		}
		return true;

	case 0x32f3e3f5: //ContractCrate.xpType
		{
			String _mnxpType;
			TypeInfo<String >::parseFromBinaryStream(&_mnxpType, stream);
			xpType = std::move(_mnxpType);
		}
		return true;

	case 0x45c407aa: //ContractCrate.itemName
		{
			String _mnitemName;
			TypeInfo<String >::parseFromBinaryStream(&_mnitemName, stream);
			itemName = std::move(_mnitemName);
		}
		return true;

	case 0x1c68ae3e: //ContractCrate.amountNeeded
		{
			int _mnamountNeeded;
			TypeInfo<int >::parseFromBinaryStream(&_mnamountNeeded, stream);
			amountNeeded = std::move(_mnamountNeeded);
		}
		return true;

	case 0x511f90da: //ContractCrate.currentAmount
		{
			int _mncurrentAmount;
			TypeInfo<int >::parseFromBinaryStream(&_mncurrentAmount, stream);
			currentAmount = std::move(_mncurrentAmount);
		}
		return true;

	case 0x9894425f: //ContractCrate.xpAmount
		{
			int _mnxpAmount;
			TypeInfo<int >::parseFromBinaryStream(&_mnxpAmount, stream);
			xpAmount = std::move(_mnxpAmount);
		}
		return true;

	case 0xa6c5400f: //ContractCrate.crateDifficulty
		{
			int _mncrateDifficulty;
			TypeInfo<int >::parseFromBinaryStream(&_mncrateDifficulty, stream);
			crateDifficulty = std::move(_mncrateDifficulty);
		}
		return true;

	}

	return false;
}

void ContractCratePOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ContractCratePOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ContractCratePOD::writeObjectCompact(ObjectOutputStream* stream) {
	TangibleObjectPOD::writeObjectCompact(stream);

	TypeInfo<String >::toBinaryStream(&requiredItem.value(), stream);

	TypeInfo<String >::toBinaryStream(&xpType.value(), stream);

	TypeInfo<String >::toBinaryStream(&itemName.value(), stream);

	TypeInfo<int >::toBinaryStream(&amountNeeded.value(), stream);

	TypeInfo<int >::toBinaryStream(&currentAmount.value(), stream);

	TypeInfo<int >::toBinaryStream(&xpAmount.value(), stream);

	TypeInfo<int >::toBinaryStream(&crateDifficulty.value(), stream);


}

