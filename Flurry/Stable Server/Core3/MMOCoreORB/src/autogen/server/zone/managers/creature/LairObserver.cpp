/*
 *	autogen/server/zone/managers/creature/LairObserver.cpp generated by engine3 IDL compiler 0.70
 */

#include "LairObserver.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/managers/creature/HealLairObserverEvent.h"

/*
 *	LairObserverStub
 */

enum {RPC_NOTIFYOBSERVEREVENT__INT_OBSERVABLE_MANAGEDOBJECT_LONG_ = 2459089691,RPC_NOTIFYDESTRUCTION__TANGIBLEOBJECT_TANGIBLEOBJECT_INT_,RPC_CHECKFORNEWSPAWNS__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_,RPC_HEALLAIR__TANGIBLEOBJECT_TANGIBLEOBJECT_,RPC_CHECKFORHEAL__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_,RPC_DOAGGRO__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_,RPC_ISLAIROBSERVER__,RPC_GETLIVINGCREATURECOUNT__,RPC_GETMOBTYPE__,RPC_GETSPAWNNUMBER__};

LairObserver::LairObserver() : SpawnObserver(DummyConstructorParameter::instance()) {
	LairObserverImplementation* _implementation = new LairObserverImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("LairObserver");
}

LairObserver::LairObserver(DummyConstructorParameter* param) : SpawnObserver(param) {
	_setClassName("LairObserver");
}

LairObserver::~LairObserver() {
}



int LairObserver::notifyObserverEvent(unsigned int eventType, Observable* observable, ManagedObject* arg1, long long arg2) {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBSERVEREVENT__INT_OBSERVABLE_MANAGEDOBJECT_LONG_);
		method.addUnsignedIntParameter(eventType);
		method.addObjectParameter(observable);
		method.addObjectParameter(arg1);
		method.addSignedLongParameter(arg2);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObserverEvent(eventType, observable, arg1, arg2);
	}
}

void LairObserver::notifyDestruction(TangibleObject* lair, TangibleObject* attacker, int condition) {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYDESTRUCTION__TANGIBLEOBJECT_TANGIBLEOBJECT_INT_);
		method.addObjectParameter(lair);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(condition);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyDestruction(lair, attacker, condition);
	}
}

bool LairObserver::checkForNewSpawns(TangibleObject* lair, TangibleObject* attacker, bool forceSpawn) {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKFORNEWSPAWNS__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_);
		method.addObjectParameter(lair);
		method.addObjectParameter(attacker);
		method.addBooleanParameter(forceSpawn);

		return method.executeWithBooleanReturn();
	} else {
		assert((lair == NULL) || lair->isLockedByCurrentThread());
		return _implementation->checkForNewSpawns(lair, attacker, forceSpawn);
	}
}

void LairObserver::healLair(TangibleObject* lair, TangibleObject* attacker) {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALLAIR__TANGIBLEOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(lair);
		method.addObjectParameter(attacker);

		method.executeWithVoidReturn();
	} else {
		_implementation->healLair(lair, attacker);
	}
}

void LairObserver::checkForHeal(TangibleObject* lair, TangibleObject* attacker, bool forceNewUpdate) {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKFORHEAL__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_);
		method.addObjectParameter(lair);
		method.addObjectParameter(attacker);
		method.addBooleanParameter(forceNewUpdate);

		method.executeWithVoidReturn();
	} else {
		_implementation->checkForHeal(lair, attacker, forceNewUpdate);
	}
}

void LairObserver::doAggro(TangibleObject* lair, TangibleObject* attacker, bool allAttack) {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOAGGRO__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_);
		method.addObjectParameter(lair);
		method.addObjectParameter(attacker);
		method.addBooleanParameter(allAttack);

		method.executeWithVoidReturn();
	} else {
		_implementation->doAggro(lair, attacker, allAttack);
	}
}

bool LairObserver::isLairObserver() {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLAIROBSERVER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLairObserver();
	}
}

int LairObserver::getLivingCreatureCount() {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLIVINGCREATURECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getLivingCreatureCount();
	}
}

int LairObserver::getMobType() {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOBTYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMobType();
	}
}

int LairObserver::getSpawnNumber() {
	LairObserverImplementation* _implementation = static_cast<LairObserverImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPAWNNUMBER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSpawnNumber();
	}
}

DistributedObjectServant* LairObserver::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* LairObserver::_getImplementationForRead() const {
	return _impl;
}

void LairObserver::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	LairObserverImplementation
 */

LairObserverImplementation::LairObserverImplementation(DummyConstructorParameter* param) : SpawnObserverImplementation(param) {
	_initializeImplementation();
}


LairObserverImplementation::~LairObserverImplementation() {
}


void LairObserverImplementation::finalize() {
}

void LairObserverImplementation::_initializeImplementation() {
	_setClassHelper(LairObserverHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void LairObserverImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<LairObserver*>(stub);
	SpawnObserverImplementation::_setStub(stub);
}

DistributedObjectStub* LairObserverImplementation::_getStub() {
	return _this.get();
}

LairObserverImplementation::operator const LairObserver*() {
	return _this.get();
}

void LairObserverImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void LairObserverImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void LairObserverImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void LairObserverImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void LairObserverImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void LairObserverImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void LairObserverImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void LairObserverImplementation::_serializationHelperMethod() {
	SpawnObserverImplementation::_serializationHelperMethod();

	_setClassName("LairObserver");

}

void LairObserverImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(LairObserverImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool LairObserverImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SpawnObserverImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x21ede828: //LairObserver.spawnNumber
		TypeInfo<AtomicInteger >::parseFromBinaryStream(&spawnNumber, stream);
		return true;

	}

	return false;
}

void LairObserverImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = LairObserverImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int LairObserverImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SpawnObserverImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x21ede828; //LairObserver.spawnNumber
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AtomicInteger >::toBinaryStream(&spawnNumber, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

LairObserverImplementation::LairObserverImplementation() : SpawnObserverImplementation() {
	_initializeImplementation();
	// server/zone/managers/creature/LairObserver.idl():  		Logger.setLoggingName("LairObserver");
	Logger::setLoggingName("LairObserver");
	// server/zone/managers/creature/LairObserver.idl():  		healLairEvent = null;
	healLairEvent = NULL;
	// server/zone/managers/creature/LairObserver.idl():  		spawnNumber.set(0);
	(&spawnNumber)->set(0);
}

bool LairObserverImplementation::isLairObserver() {
	// server/zone/managers/creature/LairObserver.idl():  		return true;
	return true;
}

int LairObserverImplementation::getMobType() {
	// server/zone/managers/creature/LairObserver.idl():  		return super.lairTemplate.getMobType();
	return SpawnObserverImplementation::lairTemplate->getMobType();
}

int LairObserverImplementation::getSpawnNumber() {
	// server/zone/managers/creature/LairObserver.idl():  		return spawnNumber.get();
	return (&spawnNumber)->get();
}

/*
 *	LairObserverAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


LairObserverAdapter::LairObserverAdapter(LairObserver* obj) : SpawnObserverAdapter(obj) {
}

void LairObserverAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_NOTIFYOBSERVEREVENT__INT_OBSERVABLE_MANAGEDOBJECT_LONG_:
		{
			unsigned int eventType = inv->getUnsignedIntParameter();
			Observable* observable = static_cast<Observable*>(inv->getObjectParameter());
			ManagedObject* arg1 = static_cast<ManagedObject*>(inv->getObjectParameter());
			long long arg2 = inv->getSignedLongParameter();
			
			int _m_res = notifyObserverEvent(eventType, observable, arg1, arg2);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYDESTRUCTION__TANGIBLEOBJECT_TANGIBLEOBJECT_INT_:
		{
			TangibleObject* lair = static_cast<TangibleObject*>(inv->getObjectParameter());
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int condition = inv->getSignedIntParameter();
			
			notifyDestruction(lair, attacker, condition);
			
		}
		break;
	case RPC_CHECKFORNEWSPAWNS__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_:
		{
			TangibleObject* lair = static_cast<TangibleObject*>(inv->getObjectParameter());
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			bool forceSpawn = inv->getBooleanParameter();
			
			bool _m_res = checkForNewSpawns(lair, attacker, forceSpawn);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HEALLAIR__TANGIBLEOBJECT_TANGIBLEOBJECT_:
		{
			TangibleObject* lair = static_cast<TangibleObject*>(inv->getObjectParameter());
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			healLair(lair, attacker);
			
		}
		break;
	case RPC_CHECKFORHEAL__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_:
		{
			TangibleObject* lair = static_cast<TangibleObject*>(inv->getObjectParameter());
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			bool forceNewUpdate = inv->getBooleanParameter();
			
			checkForHeal(lair, attacker, forceNewUpdate);
			
		}
		break;
	case RPC_DOAGGRO__TANGIBLEOBJECT_TANGIBLEOBJECT_BOOL_:
		{
			TangibleObject* lair = static_cast<TangibleObject*>(inv->getObjectParameter());
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			bool allAttack = inv->getBooleanParameter();
			
			doAggro(lair, attacker, allAttack);
			
		}
		break;
	case RPC_ISLAIROBSERVER__:
		{
			
			bool _m_res = isLairObserver();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETLIVINGCREATURECOUNT__:
		{
			
			int _m_res = getLivingCreatureCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMOBTYPE__:
		{
			
			int _m_res = getMobType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSPAWNNUMBER__:
		{
			
			int _m_res = getSpawnNumber();
			resp->insertSignedInt(_m_res);
		}
		break;
	default:
		SpawnObserverAdapter::invokeMethod(methid, inv);
	}
}

int LairObserverAdapter::notifyObserverEvent(unsigned int eventType, Observable* observable, ManagedObject* arg1, long long arg2) {
	return (static_cast<LairObserver*>(stub))->notifyObserverEvent(eventType, observable, arg1, arg2);
}

void LairObserverAdapter::notifyDestruction(TangibleObject* lair, TangibleObject* attacker, int condition) {
	(static_cast<LairObserver*>(stub))->notifyDestruction(lair, attacker, condition);
}

bool LairObserverAdapter::checkForNewSpawns(TangibleObject* lair, TangibleObject* attacker, bool forceSpawn) {
	return (static_cast<LairObserver*>(stub))->checkForNewSpawns(lair, attacker, forceSpawn);
}

void LairObserverAdapter::healLair(TangibleObject* lair, TangibleObject* attacker) {
	(static_cast<LairObserver*>(stub))->healLair(lair, attacker);
}

void LairObserverAdapter::checkForHeal(TangibleObject* lair, TangibleObject* attacker, bool forceNewUpdate) {
	(static_cast<LairObserver*>(stub))->checkForHeal(lair, attacker, forceNewUpdate);
}

void LairObserverAdapter::doAggro(TangibleObject* lair, TangibleObject* attacker, bool allAttack) {
	(static_cast<LairObserver*>(stub))->doAggro(lair, attacker, allAttack);
}

bool LairObserverAdapter::isLairObserver() {
	return (static_cast<LairObserver*>(stub))->isLairObserver();
}

int LairObserverAdapter::getLivingCreatureCount() {
	return (static_cast<LairObserver*>(stub))->getLivingCreatureCount();
}

int LairObserverAdapter::getMobType() {
	return (static_cast<LairObserver*>(stub))->getMobType();
}

int LairObserverAdapter::getSpawnNumber() {
	return (static_cast<LairObserver*>(stub))->getSpawnNumber();
}

/*
 *	LairObserverHelper
 */

LairObserverHelper* LairObserverHelper::staticInitializer = LairObserverHelper::instance();

LairObserverHelper::LairObserverHelper() {
	className = "LairObserver";

	Core::getObjectBroker()->registerClass(className, this);
}

void LairObserverHelper::finalizeHelper() {
	LairObserverHelper::finalize();
}

DistributedObject* LairObserverHelper::instantiateObject() {
	return new LairObserver(DummyConstructorParameter::instance());
}

DistributedObjectServant* LairObserverHelper::instantiateServant() {
	return new LairObserverImplementation();
}

DistributedObjectPOD* LairObserverHelper::instantiatePOD() {
	return new LairObserverPOD();
}

DistributedObjectAdapter* LairObserverHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new LairObserverAdapter(static_cast<LairObserver*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	LairObserverPOD
 */

LairObserverPOD::~LairObserverPOD() {
}

LairObserverPOD::LairObserverPOD(void) {
	_className = "LairObserver";
}


void LairObserverPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = LairObserverPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int LairObserverPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SpawnObserverPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (spawnNumber) {
	_nameHashCode = 0x21ede828; //LairObserver.spawnNumber
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AtomicInteger >::toBinaryStream(&spawnNumber.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool LairObserverPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SpawnObserverPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x21ede828: //LairObserver.spawnNumber
		{
			AtomicInteger _mnspawnNumber;
			TypeInfo<AtomicInteger >::parseFromBinaryStream(&_mnspawnNumber, stream);
			spawnNumber = std::move(_mnspawnNumber);
		}
		return true;

	}

	return false;
}

void LairObserverPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(LairObserverPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void LairObserverPOD::writeObjectCompact(ObjectOutputStream* stream) {
	SpawnObserverPOD::writeObjectCompact(stream);

	TypeInfo<AtomicInteger >::toBinaryStream(&spawnNumber.value(), stream);


}

