/*
 *	autogen/server/zone/managers/player/PlayerManager.cpp generated by engine3 IDL compiler 0.70
 */

#include "PlayerManager.h"

#include "server/zone/ZoneProcessServer.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/ZoneServer.h"

#include "server/zone/objects/tangible/wearables/ArmorObject.h"

#include "server/zone/objects/player/PlayerObject.h"

#include "server/zone/objects/structure/StructureObject.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/creature/ai/Creature.h"

#include "server/zone/objects/tangible/tool/CraftingStation.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/login/account/Account.h"

#include "server/zone/CloseObjectsVector.h"

#include "server/zone/ZoneClientSession.h"

#include "server/zone/objects/player/events/OnlinePlayerLogTask.h"

/*
 *	PlayerManagerStub
 */

enum {RPC_LOADNAMEMAP__ = 2324343300,RPC_FINALIZE__,RPC_KICKUSER__STRING_STRING_STRING_BOOL_,RPC_SETFIRSTNAME__CREATUREOBJECT_STRING_,RPC_SETLASTNAME__CREATUREOBJECT_STRING_BOOL_,RPC_NOTIFYOBSERVEREVENT__INT_OBSERVABLE_MANAGEDOBJECT_LONG_,RPC_NOTIFYDESTRUCTION__TANGIBLEOBJECT_TANGIBLEOBJECT_INT_BOOL_,RPC_SHOULDRESCHEDULECORPSEDESTRUCTION__CREATUREOBJECT_CREATUREOBJECT_,RPC_RESCHEDULECORPSEDESTRUCTION__CREATUREOBJECT_CREATUREOBJECT_,RPC_CANGROUPMEMBERHARVESTCORPSE__CREATUREOBJECT_CREATURE_,RPC_KILLPLAYER__TANGIBLEOBJECT_CREATUREOBJECT_INT_BOOL_,RPC_CALCULATEINCAPACITATIONTIMER__CREATUREOBJECT_INT_,RPC_CHECKENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_,RPC_APPLYENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_,RPC_REMOVEENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_,RPC_AWARDBADGE__PLAYEROBJECT_INT_,RPC_SETEXPERIENCEMULTIPLIER__FLOAT_,RPC_AWARDEXPERIENCE__CREATUREOBJECT_STRING_INT_BOOL_FLOAT_BOOL_,RPC_HANDLEABORTTRADEMESSAGE__CREATUREOBJECT_,RPC_HANDLEADDITEMTOTRADEWINDOW__CREATUREOBJECT_LONG_,RPC_HANDLEGIVEMONEYMESSAGE__CREATUREOBJECT_INT_,RPC_HANDLEACCEPTTRANSACTIONMESSAGE__CREATUREOBJECT_,RPC_HANDLEUNACCEPTTRANSACTIONMESSAGE__CREATUREOBJECT_,RPC_HANDLEVERIFYTRADEMESSAGE__CREATUREOBJECT_,RPC_CHECKTRADEITEMS__CREATUREOBJECT_CREATUREOBJECT_,RPC_GETINRANGESTRUCTUREWITHADMINRIGHTS__CREATUREOBJECT_LONG_,RPC_GETINRANGEOWNEDSTRUCTURE__CREATUREOBJECT_FLOAT_,RPC_SENDBATTLEFATIGUEMESSAGE__CREATUREOBJECT_CREATUREOBJECT_,RPC_STOPWATCH__CREATUREOBJECT_LONG_BOOL_BOOL_BOOL_BOOL_,RPC_STOPLISTEN__CREATUREOBJECT_LONG_BOOL_BOOL_BOOL_BOOL_,RPC_STARTWATCH__CREATUREOBJECT_LONG_,RPC_STARTLISTEN__CREATUREOBJECT_LONG_,RPC_LOOTALL__CREATUREOBJECT_CREATUREOBJECT_,RPC_PROPOSEUNITY__CREATUREOBJECT_CREATUREOBJECT_SCENEOBJECT_,RPC_DENYUNITY__CREATUREOBJECT_,RPC_ACCEPTUNITY__CREATUREOBJECT_,RPC_COMPLETEUNITY__CREATUREOBJECT_LONG_,RPC_PROMPTDIVORCE__CREATUREOBJECT_,RPC_GRANTDIVORCE__CREATUREOBJECT_,RPC_CLAIMVETERANREWARDS__CREATUREOBJECT_,RPC_GETELIGIBLEMILESTONE__PLAYEROBJECT_ACCOUNT_,RPC_GETFIRSTINELIGIBLEMILESTONE__PLAYEROBJECT_ACCOUNT_,RPC_CANCELVETERANREWARDSESSION__CREATUREOBJECT_,RPC_CONFIRMVETERANREWARD__CREATUREOBJECT_INT_,RPC_GENERATEVETERANREWARD__CREATUREOBJECT_,RPC_HEALENHANCE__CREATUREOBJECT_CREATUREOBJECT_BYTE_INT_FLOAT_INT_,RPC_CALCULATEPLAYERLEVEL__CREATUREOBJECT_,RPC_CALCULATEPLAYERLEVEL__CREATUREOBJECT_STRING_,RPC_SENDLOGINMESSAGE__CREATUREOBJECT_,RPC_RESENDLOGINMESSAGETOALL__,RPC_SENDACTIVATECLONEREQUEST__CREATUREOBJECT_INT_,RPC_ISVALIDCLOSESTCLONER__CREATUREOBJECT_SCENEOBJECT_,RPC_SENDPLAYERTOCLONER__CREATUREOBJECT_LONG_INT_,RPC_EJECTPLAYERFROMBUILDING__CREATUREOBJECT_,RPC_CHECKEXISTENTNAMEINDATABASE__STRING_,RPC_CREATETUTORIALBUILDING__CREATUREOBJECT_,RPC_CREATESKIPPEDTUTORIALBUILDING__CREATUREOBJECT_,RPC_CHECKSPEEDHACKSECONDTEST__CREATUREOBJECT_FLOAT_FLOAT_FLOAT_INT_SCENEOBJECT_,RPC_EXISTSNAME__STRING_,RPC_EXISTSPLAYERCREATUREOID__LONG_,RPC_GETOBJECTID__STRING_,RPC_GETPLAYERNAME__LONG_,RPC_GETPLAYER__STRING_,RPC_UPDATEPERMISSIONLEVEL__CREATUREOBJECT_INT_,RPC_UPDATEPERMISSIONNAME__CREATUREOBJECT_INT_,RPC_ADDPLAYER__CREATUREOBJECT_,RPC_REMOVEPLAYER__STRING_,RPC_REMOVEPLAYER__LONG_,RPC_CONTAINSPLAYER__STRING_,RPC_SENDADMINJEDILIST__CREATUREOBJECT_,RPC_SENDADMINFRSLIST__CREATUREOBJECT_,RPC_SENDADMINLIST__CREATUREOBJECT_,RPC_GETNEARBYCRAFTINGSTATION__CREATUREOBJECT_INT_,RPC_FINISHHOLOGRIND__CREATUREOBJECT_,RPC_BANACCOUNT__PLAYEROBJECT_ACCOUNT_INT_STRING_,RPC_UNBANACCOUNT__PLAYEROBJECT_ACCOUNT_STRING_,RPC_BANFROMGALAXY__PLAYEROBJECT_ACCOUNT_INT_INT_STRING_,RPC_UNBANFROMGALAXY__PLAYEROBJECT_ACCOUNT_INT_STRING_,RPC_BANCHARACTER__PLAYEROBJECT_ACCOUNT_STRING_INT_INT_STRING_,RPC_UNBANCHARACTER__PLAYEROBJECT_ACCOUNT_STRING_INT_STRING_,RPC_CLEAROWNEDSTRUCTURESPERMISSIONS__CREATUREOBJECT_,RPC_PROMPTTEACHABLESKILLS__CREATUREOBJECT_SCENEOBJECT_,RPC_DECREASEONLINECHARCOUNT__ZONECLIENTSESSION_,RPC_INCREASEONLINECHARCOUNTIFPOSSIBLE__ZONECLIENTSESSION_,RPC_DISCONNECTALLPLAYERS__,RPC_FIXHAM__CREATUREOBJECT_,RPC_FIXBUFFSKILLMODS__CREATUREOBJECT_,RPC_GETPLAYERQUESTID__STRING_,RPC_GETPLAYERQUESTPARENT__INT_,RPC_GETTOTALPLAYERQUESTS__,RPC_GETCLEANUPCHARACTERCOUNT__,RPC_CLEANUPCHARACTERS__,RPC_SHOULDDELETECHARACTER__LONG_INT_,RPC_DOBURSTRUN__CREATUREOBJECT_FLOAT_FLOAT_,RPC_ENHANCECHARACTER__CREATUREOBJECT_,RPC_DOENHANCECHARACTER__INT_CREATUREOBJECT_INT_INT_INT_BYTE_,RPC_GETBASESTOREDCREATUREPETS__,RPC_GETBASESTOREDFACTIONPETS__,RPC_GETBASESTOREDDROIDS__,RPC_GETBASESTOREDVEHICLES__,RPC_GETBASESTOREDSHIPS__,RPC_GETNUMVETERANREWARDMILESTONES__,RPC_GETVETERANREWARDMILESTONE__INT_,RPC_GETNUMJUKEBOXSONGS__,RPC_SETONLINECHARACTERSPERACCOUNT__INT_,RPC_UPDATEPVPKILLCOUNT__CREATUREOBJECT_,RPC_GETSPECIESXPMODIFIER__STRING_STRING_,RPC_UNLOCKFRSFORTESTING__CREATUREOBJECT_INT_,RPC_UPDATEONLINEPLAYERS__,RPC_STOPONLINEPLAYERLOGTASK__};

PlayerManager::PlayerManager(ZoneServer* zoneServer, ZoneProcessServer* impl, bool trackOnlineUsers) : Observer(DummyConstructorParameter::instance()) {
	PlayerManagerImplementation* _implementation = new PlayerManagerImplementation(zoneServer, impl, trackOnlineUsers);
	_impl = _implementation;
	_implementation->_initializeImplementation();
	_impl->_setStub(this);
	_setClassName("PlayerManager");
}

PlayerManager::PlayerManager(DummyConstructorParameter* param) : Observer(param) {
	_setClassName("PlayerManager");
}

PlayerManager::~PlayerManager() {
}



void PlayerManager::loadNameMap() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOADNAMEMAP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->loadNameMap();
	}
}

void PlayerManager::sendStartingLocationsTo(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->sendStartingLocationsTo(player);
	}
}

StartingLocation* PlayerManager::getStartingLocation(const String& city) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getStartingLocation(city);
	}
}

bool PlayerManager::kickUser(const String& name, const String& admin, String& reason, bool doBan) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_KICKUSER__STRING_STRING_STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addAsciiParameter(admin);
		method.addAsciiParameter(reason);
		method.addBooleanParameter(doBan);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->kickUser(name, admin, reason, doBan);
	}
}

bool PlayerManager::createPlayer(ClientCreateCharacterCallback* callback) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->createPlayer(callback);
	}
}

bool PlayerManager::checkPlayerName(ClientCreateCharacterCallback* callback) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->checkPlayerName(callback);
	}
}

String PlayerManager::setFirstName(CreatureObject* creature, const String& newFirstName) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFIRSTNAME__CREATUREOBJECT_STRING_);
		method.addObjectParameter(creature);
		method.addAsciiParameter(newFirstName);

		String _return_setFirstName;
		method.executeWithAsciiReturn(_return_setFirstName);
		return _return_setFirstName;
	} else {
		return _implementation->setFirstName(creature, newFirstName);
	}
}

String PlayerManager::setLastName(CreatureObject* creature, const String& newLastName, bool skipVerify) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTNAME__CREATUREOBJECT_STRING_BOOL_);
		method.addObjectParameter(creature);
		method.addAsciiParameter(newLastName);
		method.addBooleanParameter(skipVerify);

		String _return_setLastName;
		method.executeWithAsciiReturn(_return_setLastName);
		return _return_setLastName;
	} else {
		return _implementation->setLastName(creature, newLastName, skipVerify);
	}
}

int PlayerManager::notifyObserverEvent(unsigned int eventType, Observable* observable, ManagedObject* arg1, long long arg2) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBSERVEREVENT__INT_OBSERVABLE_MANAGEDOBJECT_LONG_);
		method.addUnsignedIntParameter(eventType);
		method.addObjectParameter(observable);
		method.addObjectParameter(arg1);
		method.addSignedLongParameter(arg2);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObserverEvent(eventType, observable, arg1, arg2);
	}
}

int PlayerManager::notifyDestruction(TangibleObject* destructor, TangibleObject* destructedObject, int condition, bool isCombatAction) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYDESTRUCTION__TANGIBLEOBJECT_TANGIBLEOBJECT_INT_BOOL_);
		method.addObjectParameter(destructor);
		method.addObjectParameter(destructedObject);
		method.addSignedIntParameter(condition);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert((destructor == NULL) || destructor->isLockedByCurrentThread());
		assert((destructedObject == NULL) || destructedObject->isLockedByCurrentThread());
		return _implementation->notifyDestruction(destructor, destructedObject, condition, isCombatAction);
	}
}

bool PlayerManager::shouldRescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SHOULDRESCHEDULECORPSEDESTRUCTION__CREATUREOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(ai);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->shouldRescheduleCorpseDestruction(player, ai);
	}
}

void PlayerManager::rescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESCHEDULECORPSEDESTRUCTION__CREATUREOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(ai);

		method.executeWithVoidReturn();
	} else {
		_implementation->rescheduleCorpseDestruction(player, ai);
	}
}

bool PlayerManager::canGroupMemberHarvestCorpse(CreatureObject* player, Creature* creature) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANGROUPMEMBERHARVESTCORPSE__CREATUREOBJECT_CREATURE_);
		method.addObjectParameter(player);
		method.addObjectParameter(creature);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canGroupMemberHarvestCorpse(player, creature);
	}
}

void PlayerManager::killPlayer(TangibleObject* attacker, CreatureObject* player, int typeofdeath, bool isCombatAction) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_KILLPLAYER__TANGIBLEOBJECT_CREATUREOBJECT_INT_BOOL_);
		method.addObjectParameter(attacker);
		method.addObjectParameter(player);
		method.addSignedIntParameter(typeofdeath);
		method.addBooleanParameter(isCombatAction);

		method.executeWithVoidReturn();
	} else {
		_implementation->killPlayer(attacker, player, typeofdeath, isCombatAction);
	}
}

byte PlayerManager::calculateIncapacitationTimer(CreatureObject* player, int condition) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEINCAPACITATIONTIMER__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(condition);

		return method.executeWithByteReturn();
	} else {
		return _implementation->calculateIncapacitationTimer(player, condition);
	}
}

bool PlayerManager::checkEncumbrancies(CreatureObject* player, ArmorObject* armor) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(armor);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkEncumbrancies(player, armor);
	}
}

void PlayerManager::applyEncumbrancies(CreatureObject* player, ArmorObject* armor) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(armor);

		method.executeWithVoidReturn();
	} else {
		_implementation->applyEncumbrancies(player, armor);
	}
}

void PlayerManager::removeEncumbrancies(CreatureObject* player, ArmorObject* armor) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(armor);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeEncumbrancies(player, armor);
	}
}

void PlayerManager::awardBadge(PlayerObject* ghost, unsigned int badge) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AWARDBADGE__PLAYEROBJECT_INT_);
		method.addObjectParameter(ghost);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else {
		_implementation->awardBadge(ghost, badge);
	}
}

void PlayerManager::awardBadge(PlayerObject* ghost, const Badge* badge) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->awardBadge(ghost, badge);
	}
}

void PlayerManager::setExperienceMultiplier(float globalMultiplier) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETEXPERIENCEMULTIPLIER__FLOAT_);
		method.addFloatParameter(globalMultiplier);

		method.executeWithVoidReturn();
	} else {
		_implementation->setExperienceMultiplier(globalMultiplier);
	}
}

int PlayerManager::awardExperience(CreatureObject* player, const String& xpType, int amount, bool sendSystemMessage, float localMultiplier, bool applyModifiers) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AWARDEXPERIENCE__CREATUREOBJECT_STRING_INT_BOOL_FLOAT_BOOL_);
		method.addObjectParameter(player);
		method.addAsciiParameter(xpType);
		method.addSignedIntParameter(amount);
		method.addBooleanParameter(sendSystemMessage);
		method.addFloatParameter(localMultiplier);
		method.addBooleanParameter(applyModifiers);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->awardExperience(player, xpType, amount, sendSystemMessage, localMultiplier, applyModifiers);
	}
}

SortedVector<ManagedReference<SceneObject* > > PlayerManager::getInsurableItems(CreatureObject* player, bool onlyInsurable) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInsurableItems(player, onlyInsurable);
	}
}

void PlayerManager::addInsurableItemsRecursive(SceneObject* obj, SortedVector<ManagedReference<SceneObject* > >* items, bool onlyInsurable) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addInsurableItemsRecursive(obj, items, onlyInsurable);
	}
}

void PlayerManager::handleAbortTradeMessage(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEABORTTRADEMESSAGE__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->handleAbortTradeMessage(player);
	}
}

void PlayerManager::handleAddItemToTradeWindow(CreatureObject* player, unsigned long long itemID) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEADDITEMTOTRADEWINDOW__CREATUREOBJECT_LONG_);
		method.addObjectParameter(player);
		method.addUnsignedLongParameter(itemID);

		method.executeWithVoidReturn();
	} else {
		_implementation->handleAddItemToTradeWindow(player, itemID);
	}
}

void PlayerManager::handleGiveMoneyMessage(CreatureObject* player, unsigned int value) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEGIVEMONEYMESSAGE__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addUnsignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->handleGiveMoneyMessage(player, value);
	}
}

void PlayerManager::handleAcceptTransactionMessage(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEACCEPTTRANSACTIONMESSAGE__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->handleAcceptTransactionMessage(player);
	}
}

void PlayerManager::handleUnAcceptTransactionMessage(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEUNACCEPTTRANSACTIONMESSAGE__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->handleUnAcceptTransactionMessage(player);
	}
}

void PlayerManager::handleVerifyTradeMessage(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEVERIFYTRADEMESSAGE__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->handleVerifyTradeMessage(player);
	}
}

bool PlayerManager::checkTradeItems(CreatureObject* player, CreatureObject* receiver) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKTRADEITEMS__CREATUREOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(receiver);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkTradeItems(player, receiver);
	}
}

SceneObject* PlayerManager::getInRangeStructureWithAdminRights(CreatureObject* creature, unsigned long long targetID) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINRANGESTRUCTUREWITHADMINRIGHTS__CREATUREOBJECT_LONG_);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(targetID);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getInRangeStructureWithAdminRights(creature, targetID);
	}
}

StructureObject* PlayerManager::getInRangeOwnedStructure(CreatureObject* creature, float range) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINRANGEOWNEDSTRUCTURE__CREATUREOBJECT_FLOAT_);
		method.addObjectParameter(creature);
		method.addFloatParameter(range);

		return static_cast<StructureObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getInRangeOwnedStructure(creature, range);
	}
}

void PlayerManager::sendBattleFatigueMessage(CreatureObject* player, CreatureObject* target) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBATTLEFATIGUEMESSAGE__CREATUREOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(target);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBattleFatigueMessage(player, target);
	}
}

void PlayerManager::stopWatch(CreatureObject* creature, unsigned long long entid, bool doSendPackets, bool forced, bool doLock, bool outOfRange) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPWATCH__CREATUREOBJECT_LONG_BOOL_BOOL_BOOL_BOOL_);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(entid);
		method.addBooleanParameter(doSendPackets);
		method.addBooleanParameter(forced);
		method.addBooleanParameter(doLock);
		method.addBooleanParameter(outOfRange);

		method.executeWithVoidReturn();
	} else {
		_implementation->stopWatch(creature, entid, doSendPackets, forced, doLock, outOfRange);
	}
}

void PlayerManager::stopListen(CreatureObject* creature, unsigned long long entid, bool doSendPackets, bool forced, bool doLock, bool outOfRange) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPLISTEN__CREATUREOBJECT_LONG_BOOL_BOOL_BOOL_BOOL_);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(entid);
		method.addBooleanParameter(doSendPackets);
		method.addBooleanParameter(forced);
		method.addBooleanParameter(doLock);
		method.addBooleanParameter(outOfRange);

		method.executeWithVoidReturn();
	} else {
		_implementation->stopListen(creature, entid, doSendPackets, forced, doLock, outOfRange);
	}
}

void PlayerManager::startWatch(CreatureObject* creature, unsigned long long entid) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTWATCH__CREATUREOBJECT_LONG_);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(entid);

		method.executeWithVoidReturn();
	} else {
		_implementation->startWatch(creature, entid);
	}
}

void PlayerManager::startListen(CreatureObject* creature, unsigned long long entid) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTLISTEN__CREATUREOBJECT_LONG_);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(entid);

		method.executeWithVoidReturn();
	} else {
		_implementation->startListen(creature, entid);
	}
}

void PlayerManager::lootAll(CreatureObject* player, CreatureObject* creature) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOOTALL__CREATUREOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->lootAll(player, creature);
	}
}

void PlayerManager::proposeUnity(CreatureObject* askingPlayer, CreatureObject* respondingPlayer, SceneObject* askingPlayerRing) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PROPOSEUNITY__CREATUREOBJECT_CREATUREOBJECT_SCENEOBJECT_);
		method.addObjectParameter(askingPlayer);
		method.addObjectParameter(respondingPlayer);
		method.addObjectParameter(askingPlayerRing);

		method.executeWithVoidReturn();
	} else {
		_implementation->proposeUnity(askingPlayer, respondingPlayer, askingPlayerRing);
	}
}

void PlayerManager::denyUnity(CreatureObject* respondingPlayer) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DENYUNITY__CREATUREOBJECT_);
		method.addObjectParameter(respondingPlayer);

		method.executeWithVoidReturn();
	} else {
		_implementation->denyUnity(respondingPlayer);
	}
}

void PlayerManager::acceptUnity(CreatureObject* respondingPlayer) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACCEPTUNITY__CREATUREOBJECT_);
		method.addObjectParameter(respondingPlayer);

		method.executeWithVoidReturn();
	} else {
		_implementation->acceptUnity(respondingPlayer);
	}
}

void PlayerManager::completeUnity(CreatureObject* respondingPlayer, unsigned long long respondingPlayerRing) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETEUNITY__CREATUREOBJECT_LONG_);
		method.addObjectParameter(respondingPlayer);
		method.addUnsignedLongParameter(respondingPlayerRing);

		method.executeWithVoidReturn();
	} else {
		_implementation->completeUnity(respondingPlayer, respondingPlayerRing);
	}
}

void PlayerManager::promptDivorce(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PROMPTDIVORCE__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->promptDivorce(player);
	}
}

void PlayerManager::grantDivorce(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GRANTDIVORCE__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert((player == NULL) || player->isLockedByCurrentThread());
		_implementation->grantDivorce(player);
	}
}

void PlayerManager::claimVeteranRewards(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLAIMVETERANREWARDS__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->claimVeteranRewards(player);
	}
}

int PlayerManager::getEligibleMilestone(PlayerObject* playerGhost, Account* account) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETELIGIBLEMILESTONE__PLAYEROBJECT_ACCOUNT_);
		method.addObjectParameter(playerGhost);
		method.addObjectParameter(account);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getEligibleMilestone(playerGhost, account);
	}
}

int PlayerManager::getFirstIneligibleMilestone(PlayerObject* playerGhost, Account* account) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFIRSTINELIGIBLEMILESTONE__PLAYEROBJECT_ACCOUNT_);
		method.addObjectParameter(playerGhost);
		method.addObjectParameter(account);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFirstIneligibleMilestone(playerGhost, account);
	}
}

void PlayerManager::cancelVeteranRewardSession(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCELVETERANREWARDSESSION__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->cancelVeteranRewardSession(player);
	}
}

void PlayerManager::confirmVeteranReward(CreatureObject* player, int itemIndex) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONFIRMVETERANREWARD__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(itemIndex);

		method.executeWithVoidReturn();
	} else {
		_implementation->confirmVeteranReward(player, itemIndex);
	}
}

void PlayerManager::generateVeteranReward(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GENERATEVETERANREWARD__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->generateVeteranReward(player);
	}
}

int PlayerManager::healEnhance(CreatureObject* enhancer, CreatureObject* patient, byte attribute, int buffvalue, float duration, int absorption) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALENHANCE__CREATUREOBJECT_CREATUREOBJECT_BYTE_INT_FLOAT_INT_);
		method.addObjectParameter(enhancer);
		method.addObjectParameter(patient);
		method.addByteParameter(attribute);
		method.addSignedIntParameter(buffvalue);
		method.addFloatParameter(duration);
		method.addSignedIntParameter(absorption);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->healEnhance(enhancer, patient, attribute, buffvalue, duration, absorption);
	}
}

void PlayerManager::disseminateExperience(TangibleObject* destructedObject, ThreatMap* threatMap, SynchronizedVector<ManagedReference<CreatureObject* > >* lairSpawnedCreatures, Zone* lairZone) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->disseminateExperience(destructedObject, threatMap, lairSpawnedCreatures, lairZone);
	}
}

int PlayerManager::calculatePlayerLevel(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEPLAYERLEVEL__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->calculatePlayerLevel(player);
	}
}

int PlayerManager::calculatePlayerLevel(CreatureObject* player, String& xpType) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEPLAYERLEVEL__CREATUREOBJECT_STRING_);
		method.addObjectParameter(player);
		method.addAsciiParameter(xpType);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->calculatePlayerLevel(player, xpType);
	}
}

void PlayerManager::sendLoginMessage(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDLOGINMESSAGE__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendLoginMessage(player);
	}
}

void PlayerManager::resendLoginMessageToAll() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESENDLOGINMESSAGETOALL__);

		method.executeWithVoidReturn();
	} else {
		_implementation->resendLoginMessageToAll();
	}
}

void PlayerManager::sendActivateCloneRequest(CreatureObject* player, int typeofdeath) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDACTIVATECLONEREQUEST__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(typeofdeath);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendActivateCloneRequest(player, typeofdeath);
	}
}

bool PlayerManager::isValidClosestCloner(CreatureObject* player, SceneObject* cloner) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISVALIDCLOSESTCLONER__CREATUREOBJECT_SCENEOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(cloner);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isValidClosestCloner(player, cloner);
	}
}

void PlayerManager::sendPlayerToCloner(CreatureObject* player, unsigned long long clonerID, int typeofdeath) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDPLAYERTOCLONER__CREATUREOBJECT_LONG_INT_);
		method.addObjectParameter(player);
		method.addUnsignedLongParameter(clonerID);
		method.addSignedIntParameter(typeofdeath);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendPlayerToCloner(player, clonerID, typeofdeath);
	}
}

void PlayerManager::ejectPlayerFromBuilding(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EJECTPLAYERFROMBUILDING__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->ejectPlayerFromBuilding(player);
	}
}

bool PlayerManager::checkExistentNameInDatabase(const String& firstName) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKEXISTENTNAMEINDATABASE__STRING_);
		method.addAsciiParameter(firstName);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkExistentNameInDatabase(firstName);
	}
}

void PlayerManager::createTutorialBuilding(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATETUTORIALBUILDING__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->createTutorialBuilding(player);
	}
}

void PlayerManager::createSkippedTutorialBuilding(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATESKIPPEDTUTORIALBUILDING__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->createSkippedTutorialBuilding(player);
	}
}

void PlayerManager::updateSwimmingState(CreatureObject* player, float newZ, IntersectionResults* intersections, CloseObjectsVector* closeObjects) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updateSwimmingState(player, newZ, intersections, closeObjects);
	}
}

int PlayerManager::checkSpeedHackFirstTest(CreatureObject* player, float parsedSpeed, ValidatedPosition& teleportPosition, float errorMultiplier) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->checkSpeedHackFirstTest(player, parsedSpeed, teleportPosition, errorMultiplier);
	}
}

int PlayerManager::checkSpeedHackSecondTest(CreatureObject* player, float newX, float newZ, float newY, unsigned int newStamp, SceneObject* newParent) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKSPEEDHACKSECONDTEST__CREATUREOBJECT_FLOAT_FLOAT_FLOAT_INT_SCENEOBJECT_);
		method.addObjectParameter(player);
		method.addFloatParameter(newX);
		method.addFloatParameter(newZ);
		method.addFloatParameter(newY);
		method.addUnsignedIntParameter(newStamp);
		method.addObjectParameter(newParent);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->checkSpeedHackSecondTest(player, newX, newZ, newY, newStamp, newParent);
	}
}

bool PlayerManager::existsName(const String& name) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXISTSNAME__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->existsName(name);
	}
}

bool PlayerManager::existsPlayerCreatureOID(unsigned long long oid) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EXISTSPLAYERCREATUREOID__LONG_);
		method.addUnsignedLongParameter(oid);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->existsPlayerCreatureOID(oid);
	}
}

unsigned long long PlayerManager::getObjectID(const String& name) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOBJECTID__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getObjectID(name);
	}
}

String PlayerManager::getPlayerName(unsigned long long oid) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLAYERNAME__LONG_);
		method.addUnsignedLongParameter(oid);

		String _return_getPlayerName;
		method.executeWithAsciiReturn(_return_getPlayerName);
		return _return_getPlayerName;
	} else {
		return _implementation->getPlayerName(oid);
	}
}

Reference<CreatureObject* > PlayerManager::getPlayer(const String& name) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLAYER__STRING_);
		method.addAsciiParameter(name);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getPlayer(name);
	}
}

void PlayerManager::updatePermissionLevel(CreatureObject* player, int adminLevel) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPERMISSIONLEVEL__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(adminLevel);

		method.executeWithVoidReturn();
	} else {
		_implementation->updatePermissionLevel(player, adminLevel);
	}
}

void PlayerManager::updatePermissionName(CreatureObject* player, int adminLevel) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPERMISSIONNAME__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(adminLevel);

		method.executeWithVoidReturn();
	} else {
		_implementation->updatePermissionName(player, adminLevel);
	}
}

void PlayerManager::addPlayer(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPLAYER__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->addPlayer(player);
	}
}

void PlayerManager::removePlayer(const String& playerName) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEPLAYER__STRING_);
		method.addAsciiParameter(playerName);

		method.executeWithVoidReturn();
	} else {
		_implementation->removePlayer(playerName);
	}
}

void PlayerManager::removePlayer(unsigned long long playerID) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEPLAYER__LONG_);
		method.addUnsignedLongParameter(playerID);

		method.executeWithVoidReturn();
	} else {
		_implementation->removePlayer(playerID);
	}
}

bool PlayerManager::containsPlayer(const String& playerName) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONTAINSPLAYER__STRING_);
		method.addAsciiParameter(playerName);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->containsPlayer(playerName);
	}
}

void PlayerManager::sendAdminJediList(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDADMINJEDILIST__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendAdminJediList(player);
	}
}

void PlayerManager::sendAdminFRSList(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDADMINFRSLIST__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendAdminFRSList(player);
	}
}

void PlayerManager::sendAdminList(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDADMINLIST__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendAdminList(player);
	}
}

VectorMap<String, int> PlayerManager::generateAdminList() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->generateAdminList();
	}
}

CraftingStation* PlayerManager::getNearbyCraftingStation(CreatureObject* player, int type) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNEARBYCRAFTINGSTATION__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(type);

		return static_cast<CraftingStation*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getNearbyCraftingStation(player, type);
	}
}

void PlayerManager::finishHologrind(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FINISHHOLOGRIND__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->finishHologrind(player);
	}
}

String PlayerManager::banAccount(PlayerObject* admin, Account* account, unsigned int seconds, const String& reason) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BANACCOUNT__PLAYEROBJECT_ACCOUNT_INT_STRING_);
		method.addObjectParameter(admin);
		method.addObjectParameter(account);
		method.addUnsignedIntParameter(seconds);
		method.addAsciiParameter(reason);

		String _return_banAccount;
		method.executeWithAsciiReturn(_return_banAccount);
		return _return_banAccount;
	} else {
		return _implementation->banAccount(admin, account, seconds, reason);
	}
}

String PlayerManager::unbanAccount(PlayerObject* admin, Account* account, const String& reason) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNBANACCOUNT__PLAYEROBJECT_ACCOUNT_STRING_);
		method.addObjectParameter(admin);
		method.addObjectParameter(account);
		method.addAsciiParameter(reason);

		String _return_unbanAccount;
		method.executeWithAsciiReturn(_return_unbanAccount);
		return _return_unbanAccount;
	} else {
		return _implementation->unbanAccount(admin, account, reason);
	}
}

String PlayerManager::banFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, unsigned int seconds, const String& reason) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BANFROMGALAXY__PLAYEROBJECT_ACCOUNT_INT_INT_STRING_);
		method.addObjectParameter(admin);
		method.addObjectParameter(account);
		method.addUnsignedIntParameter(galaxy);
		method.addUnsignedIntParameter(seconds);
		method.addAsciiParameter(reason);

		String _return_banFromGalaxy;
		method.executeWithAsciiReturn(_return_banFromGalaxy);
		return _return_banFromGalaxy;
	} else {
		return _implementation->banFromGalaxy(admin, account, galaxy, seconds, reason);
	}
}

String PlayerManager::unbanFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, const String& reason) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNBANFROMGALAXY__PLAYEROBJECT_ACCOUNT_INT_STRING_);
		method.addObjectParameter(admin);
		method.addObjectParameter(account);
		method.addUnsignedIntParameter(galaxy);
		method.addAsciiParameter(reason);

		String _return_unbanFromGalaxy;
		method.executeWithAsciiReturn(_return_unbanFromGalaxy);
		return _return_unbanFromGalaxy;
	} else {
		return _implementation->unbanFromGalaxy(admin, account, galaxy, reason);
	}
}

String PlayerManager::banCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, unsigned int seconds, const String& reason) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BANCHARACTER__PLAYEROBJECT_ACCOUNT_STRING_INT_INT_STRING_);
		method.addObjectParameter(admin);
		method.addObjectParameter(account);
		method.addAsciiParameter(name);
		method.addUnsignedIntParameter(galaxyID);
		method.addUnsignedIntParameter(seconds);
		method.addAsciiParameter(reason);

		String _return_banCharacter;
		method.executeWithAsciiReturn(_return_banCharacter);
		return _return_banCharacter;
	} else {
		return _implementation->banCharacter(admin, account, name, galaxyID, seconds, reason);
	}
}

String PlayerManager::unbanCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, const String& reason) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNBANCHARACTER__PLAYEROBJECT_ACCOUNT_STRING_INT_STRING_);
		method.addObjectParameter(admin);
		method.addObjectParameter(account);
		method.addAsciiParameter(name);
		method.addUnsignedIntParameter(galaxyID);
		method.addAsciiParameter(reason);

		String _return_unbanCharacter;
		method.executeWithAsciiReturn(_return_unbanCharacter);
		return _return_unbanCharacter;
	} else {
		return _implementation->unbanCharacter(admin, account, name, galaxyID, reason);
	}
}

void PlayerManager::clearOwnedStructuresPermissions(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEAROWNEDSTRUCTURESPERMISSIONS__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearOwnedStructuresPermissions(player);
	}
}

bool PlayerManager::promptTeachableSkills(CreatureObject* teacher, SceneObject* target) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PROMPTTEACHABLESKILLS__CREATUREOBJECT_SCENEOBJECT_);
		method.addObjectParameter(teacher);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->promptTeachableSkills(teacher, target);
	}
}

void PlayerManager::decreaseOnlineCharCount(ZoneClientSession* client) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEONLINECHARCOUNT__ZONECLIENTSESSION_);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else {
		_implementation->decreaseOnlineCharCount(client);
	}
}

bool PlayerManager::increaseOnlineCharCountIfPossible(ZoneClientSession* client) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREASEONLINECHARCOUNTIFPOSSIBLE__ZONECLIENTSESSION_);
		method.addObjectParameter(client);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->increaseOnlineCharCountIfPossible(client);
	}
}

void PlayerManager::disconnectAllPlayers() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DISCONNECTALLPLAYERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->disconnectAllPlayers();
	}
}

void PlayerManager::fixHAM(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FIXHAM__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->fixHAM(player);
	}
}

void PlayerManager::fixBuffSkillMods(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FIXBUFFSKILLMODS__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->fixBuffSkillMods(player);
	}
}

JSONSerializationType PlayerManager::basePlayerLogEntry(CreatureObject* creature, PlayerObject* ghost) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->basePlayerLogEntry(creature, ghost);
	}
}

void PlayerManager::writePlayerLogEntry(JSONSerializationType& logEntry) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->writePlayerLogEntry(logEntry);
	}
}

void PlayerManager::writePlayerLog(CreatureObject* creature, PlayerObject* ghost, const String& msg, int logLevelType) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->writePlayerLog(creature, ghost, msg, logLevelType);
	}
}

void PlayerManager::writePlayerLog(PlayerObject* ghost, const String& msg, int logLevelType) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->writePlayerLog(ghost, msg, logLevelType);
	}
}

void PlayerManager::writePlayerLog(CreatureObject* creature, const String& msg, int logLevelType) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->writePlayerLog(creature, msg, logLevelType);
	}
}

int PlayerManager::getPlayerQuestID(const String& name) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLAYERQUESTID__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPlayerQuestID(name);
	}
}

String PlayerManager::getPlayerQuestParent(int questID) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLAYERQUESTPARENT__INT_);
		method.addSignedIntParameter(questID);

		String _return_getPlayerQuestParent;
		method.executeWithAsciiReturn(_return_getPlayerQuestParent);
		return _return_getPlayerQuestParent;
	} else {
		return _implementation->getPlayerQuestParent(questID);
	}
}

int PlayerManager::getTotalPlayerQuests() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTOTALPLAYERQUESTS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getTotalPlayerQuests();
	}
}

QuestInfo* PlayerManager::getQuestInfo(int questID) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getQuestInfo(questID);
	}
}

bool PlayerManager::offerTeaching(CreatureObject* teacher, CreatureObject* student, Skill* skill) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->offerTeaching(teacher, student, skill);
	}
}

bool PlayerManager::acceptTeachingOffer(CreatureObject* teacher, CreatureObject* student, Skill* skill) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->acceptTeachingOffer(teacher, student, skill);
	}
}

SortedVector<String> PlayerManager::getTeachableSkills(CreatureObject* teacher, CreatureObject* student) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTeachableSkills(teacher, student);
	}
}

OnlineZoneClientMap* PlayerManager::getOnlineZoneClientMap() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getOnlineZoneClientMap();
	}
}

void PlayerManager::getCleanupCharacterCount() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLEANUPCHARACTERCOUNT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->getCleanupCharacterCount();
	}
}

void PlayerManager::cleanupCharacters() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEANUPCHARACTERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->cleanupCharacters();
	}
}

bool PlayerManager::shouldDeleteCharacter(unsigned long long characterID, int galaxyID) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SHOULDDELETECHARACTER__LONG_INT_);
		method.addUnsignedLongParameter(characterID);
		method.addSignedIntParameter(galaxyID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->shouldDeleteCharacter(characterID, galaxyID);
	}
}

bool PlayerManager::doBurstRun(CreatureObject* player, float hamModifier, float cooldownModifier) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOBURSTRUN__CREATUREOBJECT_FLOAT_FLOAT_);
		method.addObjectParameter(player);
		method.addFloatParameter(hamModifier);
		method.addFloatParameter(cooldownModifier);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->doBurstRun(player, hamModifier, cooldownModifier);
	}
}

void PlayerManager::enhanceCharacter(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENHANCECHARACTER__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->enhanceCharacter(player);
	}
}

bool PlayerManager::doEnhanceCharacter(unsigned int crc, CreatureObject* player, int amount, int duration, int buffType, byte attribute) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOENHANCECHARACTER__INT_CREATUREOBJECT_INT_INT_INT_BYTE_);
		method.addUnsignedIntParameter(crc);
		method.addObjectParameter(player);
		method.addSignedIntParameter(amount);
		method.addSignedIntParameter(duration);
		method.addSignedIntParameter(buffType);
		method.addByteParameter(attribute);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->doEnhanceCharacter(crc, player, amount, duration, buffType, attribute);
	}
}

int PlayerManager::getBaseStoredCreaturePets() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASESTOREDCREATUREPETS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseStoredCreaturePets();
	}
}

int PlayerManager::getBaseStoredFactionPets() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASESTOREDFACTIONPETS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseStoredFactionPets();
	}
}

int PlayerManager::getBaseStoredDroids() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASESTOREDDROIDS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseStoredDroids();
	}
}

int PlayerManager::getBaseStoredVehicles() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASESTOREDVEHICLES__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseStoredVehicles();
	}
}

int PlayerManager::getBaseStoredShips() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASESTOREDSHIPS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseStoredShips();
	}
}

int PlayerManager::getNumVeteranRewardMilestones() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNUMVETERANREWARDMILESTONES__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getNumVeteranRewardMilestones();
	}
}

int PlayerManager::getVeteranRewardMilestone(int index) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVETERANREWARDMILESTONE__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getVeteranRewardMilestone(index);
	}
}

JukeboxSong* PlayerManager::getJukeboxSong(int index) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getJukeboxSong(index);
	}
}

int PlayerManager::getNumJukeboxSongs() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNUMJUKEBOXSONGS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getNumJukeboxSongs();
	}
}

void PlayerManager::setOnlineCharactersPerAccount(int count) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETONLINECHARACTERSPERACCOUNT__INT_);
		method.addSignedIntParameter(count);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOnlineCharactersPerAccount(count);
	}
}

void PlayerManager::doPvpDeathRatingUpdate(CreatureObject* player, ThreatMap* threatMap) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert((player == NULL) || player->isLockedByCurrentThread());
		_implementation->doPvpDeathRatingUpdate(player, threatMap);
	}
}

void PlayerManager::updatePvPKillCount(CreatureObject* player) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPVPKILLCOUNT__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->updatePvPKillCount(player);
	}
}

float PlayerManager::getSpeciesXpModifier(const String& species, const String& xpType) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIESXPMODIFIER__STRING_STRING_);
		method.addAsciiParameter(species);
		method.addAsciiParameter(xpType);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSpeciesXpModifier(species, xpType);
	}
}

void PlayerManager::unlockFRSForTesting(CreatureObject* player, int councilType) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOCKFRSFORTESTING__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(councilType);

		method.executeWithVoidReturn();
	} else {
		_implementation->unlockFRSForTesting(player, councilType);
	}
}

Vector<unsigned long long> PlayerManager::getOnlinePlayerList() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getOnlinePlayerList();
	}
}

void PlayerManager::logOnlinePlayers(bool onlyWho) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->logOnlinePlayers(onlyWho);
	}
}

bool PlayerManager::rescheduleOnlinePlayerLogTask(int logSeconds) {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->rescheduleOnlinePlayerLogTask(logSeconds);
	}
}

void PlayerManager::updateOnlinePlayers() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEONLINEPLAYERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateOnlinePlayers();
	}
}

void PlayerManager::stopOnlinePlayerLogTask() {
	PlayerManagerImplementation* _implementation = static_cast<PlayerManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPONLINEPLAYERLOGTASK__);

		method.executeWithVoidReturn();
	} else {
		_implementation->stopOnlinePlayerLogTask();
	}
}

DistributedObjectServant* PlayerManager::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* PlayerManager::_getImplementationForRead() const {
	return _impl;
}

void PlayerManager::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	PlayerManagerImplementation
 */

PlayerManagerImplementation::PlayerManagerImplementation(DummyConstructorParameter* param) : ObserverImplementation(param) {
	_initializeImplementation();
}


PlayerManagerImplementation::~PlayerManagerImplementation() {
	PlayerManagerImplementation::finalize();
}


void PlayerManagerImplementation::_initializeImplementation() {
	_setClassHelper(PlayerManagerHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void PlayerManagerImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<PlayerManager*>(stub);
	ObserverImplementation::_setStub(stub);
}

DistributedObjectStub* PlayerManagerImplementation::_getStub() {
	return _this.get();
}

PlayerManagerImplementation::operator const PlayerManager*() {
	return _this.get();
}

void PlayerManagerImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void PlayerManagerImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void PlayerManagerImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void PlayerManagerImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void PlayerManagerImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void PlayerManagerImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void PlayerManagerImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void PlayerManagerImplementation::_serializationHelperMethod() {
	ObserverImplementation::_serializationHelperMethod();

	_setClassName("PlayerManager");

}

void PlayerManagerImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PlayerManagerImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool PlayerManagerImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ObserverImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xc199e00f: //PlayerManager.performanceBuff
		TypeInfo<int >::parseFromBinaryStream(&performanceBuff, stream);
		return true;

	case 0xe0ebf015: //PlayerManager.medicalBuff
		TypeInfo<int >::parseFromBinaryStream(&medicalBuff, stream);
		return true;

	case 0xf4f2a5f1: //PlayerManager.performanceDuration
		TypeInfo<int >::parseFromBinaryStream(&performanceDuration, stream);
		return true;

	case 0xe2b9cf5c: //PlayerManager.medicalDuration
		TypeInfo<int >::parseFromBinaryStream(&medicalDuration, stream);
		return true;

	case 0x20a067d7: //PlayerManager.baseStoredCreaturePets
		TypeInfo<int >::parseFromBinaryStream(&baseStoredCreaturePets, stream);
		return true;

	case 0xac12787d: //PlayerManager.baseStoredFactionPets
		TypeInfo<int >::parseFromBinaryStream(&baseStoredFactionPets, stream);
		return true;

	case 0xba4799c2: //PlayerManager.baseStoredDroids
		TypeInfo<int >::parseFromBinaryStream(&baseStoredDroids, stream);
		return true;

	case 0x903249ac: //PlayerManager.baseStoredVehicles
		TypeInfo<int >::parseFromBinaryStream(&baseStoredVehicles, stream);
		return true;

	case 0xd5b2476d: //PlayerManager.baseStoredShips
		TypeInfo<int >::parseFromBinaryStream(&baseStoredShips, stream);
		return true;

	case 0x98ad7d2d: //PlayerManager.allowSameAccountPvpRatingCredit
		TypeInfo<bool >::parseFromBinaryStream(&allowSameAccountPvpRatingCredit, stream);
		return true;

	case 0x21ee7a31: //PlayerManager.onlineCharactersPerAccount
		TypeInfo<int >::parseFromBinaryStream(&onlineCharactersPerAccount, stream);
		return true;

	case 0x35715026: //PlayerManager.xpBonusList
		TypeInfo<XpBonusList >::parseFromBinaryStream(&xpBonusList, stream);
		return true;

	case 0xcc4f885f: //PlayerManager.veteranRewardMilestones
		TypeInfo<SortedVector<int> >::parseFromBinaryStream(&veteranRewardMilestones, stream);
		return true;

	case 0xbc32fef9: //PlayerManager.veteranRewardAdditionalMilestones
		TypeInfo<int >::parseFromBinaryStream(&veteranRewardAdditionalMilestones, stream);
		return true;

	case 0xbfedc931: //PlayerManager.veteranRewards
		TypeInfo<VeteranRewardList >::parseFromBinaryStream(&veteranRewards, stream);
		return true;

	case 0x3d6a23c8: //PlayerManager.server
		TypeInfo<ManagedReference<ZoneServer* > >::parseFromBinaryStream(&server, stream);
		return true;

	case 0x66f52932: //PlayerManager.globalExpMultiplier
		TypeInfo<float >::parseFromBinaryStream(&globalExpMultiplier, stream);
		return true;

	case 0xdccf1a2f: //PlayerManager.groupExpMultiplier
		TypeInfo<float >::parseFromBinaryStream(&groupExpMultiplier, stream);
		return true;

	}

	return false;
}

void PlayerManagerImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlayerManagerImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlayerManagerImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ObserverImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xc199e00f; //PlayerManager.performanceBuff
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&performanceBuff, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe0ebf015; //PlayerManager.medicalBuff
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&medicalBuff, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf4f2a5f1; //PlayerManager.performanceDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&performanceDuration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe2b9cf5c; //PlayerManager.medicalDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&medicalDuration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x20a067d7; //PlayerManager.baseStoredCreaturePets
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredCreaturePets, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xac12787d; //PlayerManager.baseStoredFactionPets
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredFactionPets, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xba4799c2; //PlayerManager.baseStoredDroids
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredDroids, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x903249ac; //PlayerManager.baseStoredVehicles
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredVehicles, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd5b2476d; //PlayerManager.baseStoredShips
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredShips, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x98ad7d2d; //PlayerManager.allowSameAccountPvpRatingCredit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&allowSameAccountPvpRatingCredit, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x21ee7a31; //PlayerManager.onlineCharactersPerAccount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&onlineCharactersPerAccount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x35715026; //PlayerManager.xpBonusList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<XpBonusList >::toBinaryStream(&xpBonusList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcc4f885f; //PlayerManager.veteranRewardMilestones
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<int> >::toBinaryStream(&veteranRewardMilestones, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbc32fef9; //PlayerManager.veteranRewardAdditionalMilestones
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&veteranRewardAdditionalMilestones, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbfedc931; //PlayerManager.veteranRewards
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VeteranRewardList >::toBinaryStream(&veteranRewards, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3d6a23c8; //PlayerManager.server
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<ZoneServer* > >::toBinaryStream(&server, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x66f52932; //PlayerManager.globalExpMultiplier
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&globalExpMultiplier, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdccf1a2f; //PlayerManager.groupExpMultiplier
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&groupExpMultiplier, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void PlayerManagerImplementation::addPlayer(CreatureObject* player) {
	// server/zone/managers/player/PlayerManager.idl():  		nameMap.put(player);
	nameMap->put(player);
}

void PlayerManagerImplementation::removePlayer(const String& playerName) {
	// server/zone/managers/player/PlayerManager.idl():  		nameMap.remove(playerName);
	nameMap->remove(playerName);
}

void PlayerManagerImplementation::removePlayer(unsigned long long playerID) {
	// server/zone/managers/player/PlayerManager.idl():  		nameMap.remove(playerID);
	nameMap->remove(playerID);
}

bool PlayerManagerImplementation::containsPlayer(const String& playerName) {
	// server/zone/managers/player/PlayerManager.idl():  		return nameMap.containsKey(playerName);
	return nameMap->containsKey(playerName);
}

int PlayerManagerImplementation::getTotalPlayerQuests() {
	// server/zone/managers/player/PlayerManager.idl():  		return questInfo.size();
	return (&questInfo)->size();
}

QuestInfo* PlayerManagerImplementation::getQuestInfo(int questID) {
	// server/zone/managers/player/PlayerManager.idl():  		return questInfo.get(questID);
	return (&questInfo)->get(questID);
}

OnlineZoneClientMap* PlayerManagerImplementation::getOnlineZoneClientMap() {
	// server/zone/managers/player/PlayerManager.idl():  		return onlineZoneClientMap;
	return (&onlineZoneClientMap);
}

int PlayerManagerImplementation::getBaseStoredCreaturePets() {
	// server/zone/managers/player/PlayerManager.idl():  		return baseStoredCreaturePets;
	return baseStoredCreaturePets;
}

int PlayerManagerImplementation::getBaseStoredFactionPets() {
	// server/zone/managers/player/PlayerManager.idl():  		return baseStoredFactionPets;
	return baseStoredFactionPets;
}

int PlayerManagerImplementation::getBaseStoredDroids() {
	// server/zone/managers/player/PlayerManager.idl():  		return baseStoredDroids;
	return baseStoredDroids;
}

int PlayerManagerImplementation::getBaseStoredVehicles() {
	// server/zone/managers/player/PlayerManager.idl():  		return baseStoredVehicles;
	return baseStoredVehicles;
}

int PlayerManagerImplementation::getBaseStoredShips() {
	// server/zone/managers/player/PlayerManager.idl():  		return baseStoredShips;
	return baseStoredShips;
}

int PlayerManagerImplementation::getNumVeteranRewardMilestones() {
	// server/zone/managers/player/PlayerManager.idl():  		return veteranRewardMilestones.size();
	return (&veteranRewardMilestones)->size();
}

int PlayerManagerImplementation::getVeteranRewardMilestone(int index) {
	// server/zone/managers/player/PlayerManager.idl():  		return veteranRewardMilestones.get(index);
	return (&veteranRewardMilestones)->get(index);
}

JukeboxSong* PlayerManagerImplementation::getJukeboxSong(int index) {
	// server/zone/managers/player/PlayerManager.idl():  		return jukeboxSongs.get(index);
	return (&jukeboxSongs)->get(index);
}

int PlayerManagerImplementation::getNumJukeboxSongs() {
	// server/zone/managers/player/PlayerManager.idl():  		return jukeboxSongs.size();
	return (&jukeboxSongs)->size();
}

void PlayerManagerImplementation::setOnlineCharactersPerAccount(int count) {
	// server/zone/managers/player/PlayerManager.idl():  		onlineCharactersPerAccount = count;
	onlineCharactersPerAccount = count;
}

void PlayerManagerImplementation::updateOnlinePlayers() {
	// server/zone/managers/player/PlayerManager.idl():  		logOnlinePlayers(!onlinePlayersLogOnSessionChange);
	logOnlinePlayers(!onlinePlayersLogOnSessionChange);
}

/*
 *	PlayerManagerAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


PlayerManagerAdapter::PlayerManagerAdapter(PlayerManager* obj) : ObserverAdapter(obj) {
}

void PlayerManagerAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_LOADNAMEMAP__:
		{
			
			loadNameMap();
			
		}
		break;
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_KICKUSER__STRING_STRING_STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			 String admin; inv->getAsciiParameter(admin);
			String reason; inv->getAsciiParameter(reason);
			bool doBan = inv->getBooleanParameter();
			
			bool _m_res = kickUser(name, admin, reason, doBan);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETFIRSTNAME__CREATUREOBJECT_STRING_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			 String newFirstName; inv->getAsciiParameter(newFirstName);
			
			String _m_res = setFirstName(creature, newFirstName);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETLASTNAME__CREATUREOBJECT_STRING_BOOL_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			 String newLastName; inv->getAsciiParameter(newLastName);
			bool skipVerify = inv->getBooleanParameter();
			
			String _m_res = setLastName(creature, newLastName, skipVerify);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_NOTIFYOBSERVEREVENT__INT_OBSERVABLE_MANAGEDOBJECT_LONG_:
		{
			unsigned int eventType = inv->getUnsignedIntParameter();
			Observable* observable = static_cast<Observable*>(inv->getObjectParameter());
			ManagedObject* arg1 = static_cast<ManagedObject*>(inv->getObjectParameter());
			long long arg2 = inv->getSignedLongParameter();
			
			int _m_res = notifyObserverEvent(eventType, observable, arg1, arg2);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYDESTRUCTION__TANGIBLEOBJECT_TANGIBLEOBJECT_INT_BOOL_:
		{
			TangibleObject* destructor = static_cast<TangibleObject*>(inv->getObjectParameter());
			TangibleObject* destructedObject = static_cast<TangibleObject*>(inv->getObjectParameter());
			int condition = inv->getSignedIntParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = notifyDestruction(destructor, destructedObject, condition, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SHOULDRESCHEDULECORPSEDESTRUCTION__CREATUREOBJECT_CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* ai = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = shouldRescheduleCorpseDestruction(player, ai);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_RESCHEDULECORPSEDESTRUCTION__CREATUREOBJECT_CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* ai = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			rescheduleCorpseDestruction(player, ai);
			
		}
		break;
	case RPC_CANGROUPMEMBERHARVESTCORPSE__CREATUREOBJECT_CREATURE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			Creature* creature = static_cast<Creature*>(inv->getObjectParameter());
			
			bool _m_res = canGroupMemberHarvestCorpse(player, creature);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_KILLPLAYER__TANGIBLEOBJECT_CREATUREOBJECT_INT_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int typeofdeath = inv->getSignedIntParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			killPlayer(attacker, player, typeofdeath, isCombatAction);
			
		}
		break;
	case RPC_CALCULATEINCAPACITATIONTIMER__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int condition = inv->getSignedIntParameter();
			
			byte _m_res = calculateIncapacitationTimer(player, condition);
			resp->insertByte(_m_res);
		}
		break;
	case RPC_CHECKENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			ArmorObject* armor = static_cast<ArmorObject*>(inv->getObjectParameter());
			
			bool _m_res = checkEncumbrancies(player, armor);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_APPLYENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			ArmorObject* armor = static_cast<ArmorObject*>(inv->getObjectParameter());
			
			applyEncumbrancies(player, armor);
			
		}
		break;
	case RPC_REMOVEENCUMBRANCIES__CREATUREOBJECT_ARMOROBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			ArmorObject* armor = static_cast<ArmorObject*>(inv->getObjectParameter());
			
			removeEncumbrancies(player, armor);
			
		}
		break;
	case RPC_AWARDBADGE__PLAYEROBJECT_INT_:
		{
			PlayerObject* ghost = static_cast<PlayerObject*>(inv->getObjectParameter());
			unsigned int badge = inv->getUnsignedIntParameter();
			
			awardBadge(ghost, badge);
			
		}
		break;
	case RPC_SETEXPERIENCEMULTIPLIER__FLOAT_:
		{
			float globalMultiplier = inv->getFloatParameter();
			
			setExperienceMultiplier(globalMultiplier);
			
		}
		break;
	case RPC_AWARDEXPERIENCE__CREATUREOBJECT_STRING_INT_BOOL_FLOAT_BOOL_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			 String xpType; inv->getAsciiParameter(xpType);
			int amount = inv->getSignedIntParameter();
			bool sendSystemMessage = inv->getBooleanParameter();
			float localMultiplier = inv->getFloatParameter();
			bool applyModifiers = inv->getBooleanParameter();
			
			int _m_res = awardExperience(player, xpType, amount, sendSystemMessage, localMultiplier, applyModifiers);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HANDLEABORTTRADEMESSAGE__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			handleAbortTradeMessage(player);
			
		}
		break;
	case RPC_HANDLEADDITEMTOTRADEWINDOW__CREATUREOBJECT_LONG_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long itemID = inv->getUnsignedLongParameter();
			
			handleAddItemToTradeWindow(player, itemID);
			
		}
		break;
	case RPC_HANDLEGIVEMONEYMESSAGE__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned int value = inv->getUnsignedIntParameter();
			
			handleGiveMoneyMessage(player, value);
			
		}
		break;
	case RPC_HANDLEACCEPTTRANSACTIONMESSAGE__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			handleAcceptTransactionMessage(player);
			
		}
		break;
	case RPC_HANDLEUNACCEPTTRANSACTIONMESSAGE__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			handleUnAcceptTransactionMessage(player);
			
		}
		break;
	case RPC_HANDLEVERIFYTRADEMESSAGE__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			handleVerifyTradeMessage(player);
			
		}
		break;
	case RPC_CHECKTRADEITEMS__CREATUREOBJECT_CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* receiver = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = checkTradeItems(player, receiver);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETINRANGESTRUCTUREWITHADMINRIGHTS__CREATUREOBJECT_LONG_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long targetID = inv->getUnsignedLongParameter();
			
			DistributedObject* _m_res = getInRangeStructureWithAdminRights(creature, targetID);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETINRANGEOWNEDSTRUCTURE__CREATUREOBJECT_FLOAT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			float range = inv->getFloatParameter();
			
			DistributedObject* _m_res = getInRangeOwnedStructure(creature, range);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_SENDBATTLEFATIGUEMESSAGE__CREATUREOBJECT_CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendBattleFatigueMessage(player, target);
			
		}
		break;
	case RPC_STOPWATCH__CREATUREOBJECT_LONG_BOOL_BOOL_BOOL_BOOL_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long entid = inv->getUnsignedLongParameter();
			bool doSendPackets = inv->getBooleanParameter();
			bool forced = inv->getBooleanParameter();
			bool doLock = inv->getBooleanParameter();
			bool outOfRange = inv->getBooleanParameter();
			
			stopWatch(creature, entid, doSendPackets, forced, doLock, outOfRange);
			
		}
		break;
	case RPC_STOPLISTEN__CREATUREOBJECT_LONG_BOOL_BOOL_BOOL_BOOL_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long entid = inv->getUnsignedLongParameter();
			bool doSendPackets = inv->getBooleanParameter();
			bool forced = inv->getBooleanParameter();
			bool doLock = inv->getBooleanParameter();
			bool outOfRange = inv->getBooleanParameter();
			
			stopListen(creature, entid, doSendPackets, forced, doLock, outOfRange);
			
		}
		break;
	case RPC_STARTWATCH__CREATUREOBJECT_LONG_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long entid = inv->getUnsignedLongParameter();
			
			startWatch(creature, entid);
			
		}
		break;
	case RPC_STARTLISTEN__CREATUREOBJECT_LONG_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long entid = inv->getUnsignedLongParameter();
			
			startListen(creature, entid);
			
		}
		break;
	case RPC_LOOTALL__CREATUREOBJECT_CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			lootAll(player, creature);
			
		}
		break;
	case RPC_PROPOSEUNITY__CREATUREOBJECT_CREATUREOBJECT_SCENEOBJECT_:
		{
			CreatureObject* askingPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* respondingPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			SceneObject* askingPlayerRing = static_cast<SceneObject*>(inv->getObjectParameter());
			
			proposeUnity(askingPlayer, respondingPlayer, askingPlayerRing);
			
		}
		break;
	case RPC_DENYUNITY__CREATUREOBJECT_:
		{
			CreatureObject* respondingPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			denyUnity(respondingPlayer);
			
		}
		break;
	case RPC_ACCEPTUNITY__CREATUREOBJECT_:
		{
			CreatureObject* respondingPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			acceptUnity(respondingPlayer);
			
		}
		break;
	case RPC_COMPLETEUNITY__CREATUREOBJECT_LONG_:
		{
			CreatureObject* respondingPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long respondingPlayerRing = inv->getUnsignedLongParameter();
			
			completeUnity(respondingPlayer, respondingPlayerRing);
			
		}
		break;
	case RPC_PROMPTDIVORCE__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			promptDivorce(player);
			
		}
		break;
	case RPC_GRANTDIVORCE__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			grantDivorce(player);
			
		}
		break;
	case RPC_CLAIMVETERANREWARDS__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			claimVeteranRewards(player);
			
		}
		break;
	case RPC_GETELIGIBLEMILESTONE__PLAYEROBJECT_ACCOUNT_:
		{
			PlayerObject* playerGhost = static_cast<PlayerObject*>(inv->getObjectParameter());
			Account* account = static_cast<Account*>(inv->getObjectParameter());
			
			int _m_res = getEligibleMilestone(playerGhost, account);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFIRSTINELIGIBLEMILESTONE__PLAYEROBJECT_ACCOUNT_:
		{
			PlayerObject* playerGhost = static_cast<PlayerObject*>(inv->getObjectParameter());
			Account* account = static_cast<Account*>(inv->getObjectParameter());
			
			int _m_res = getFirstIneligibleMilestone(playerGhost, account);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CANCELVETERANREWARDSESSION__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			cancelVeteranRewardSession(player);
			
		}
		break;
	case RPC_CONFIRMVETERANREWARD__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int itemIndex = inv->getSignedIntParameter();
			
			confirmVeteranReward(player, itemIndex);
			
		}
		break;
	case RPC_GENERATEVETERANREWARD__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			generateVeteranReward(player);
			
		}
		break;
	case RPC_HEALENHANCE__CREATUREOBJECT_CREATUREOBJECT_BYTE_INT_FLOAT_INT_:
		{
			CreatureObject* enhancer = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* patient = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte attribute = inv->getByteParameter();
			int buffvalue = inv->getSignedIntParameter();
			float duration = inv->getFloatParameter();
			int absorption = inv->getSignedIntParameter();
			
			int _m_res = healEnhance(enhancer, patient, attribute, buffvalue, duration, absorption);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CALCULATEPLAYERLEVEL__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			int _m_res = calculatePlayerLevel(player);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CALCULATEPLAYERLEVEL__CREATUREOBJECT_STRING_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			String xpType; inv->getAsciiParameter(xpType);
			
			int _m_res = calculatePlayerLevel(player, xpType);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SENDLOGINMESSAGE__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendLoginMessage(player);
			
		}
		break;
	case RPC_RESENDLOGINMESSAGETOALL__:
		{
			
			resendLoginMessageToAll();
			
		}
		break;
	case RPC_SENDACTIVATECLONEREQUEST__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int typeofdeath = inv->getSignedIntParameter();
			
			sendActivateCloneRequest(player, typeofdeath);
			
		}
		break;
	case RPC_ISVALIDCLOSESTCLONER__CREATUREOBJECT_SCENEOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			SceneObject* cloner = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = isValidClosestCloner(player, cloner);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDPLAYERTOCLONER__CREATUREOBJECT_LONG_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long clonerID = inv->getUnsignedLongParameter();
			int typeofdeath = inv->getSignedIntParameter();
			
			sendPlayerToCloner(player, clonerID, typeofdeath);
			
		}
		break;
	case RPC_EJECTPLAYERFROMBUILDING__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			ejectPlayerFromBuilding(player);
			
		}
		break;
	case RPC_CHECKEXISTENTNAMEINDATABASE__STRING_:
		{
			 String firstName; inv->getAsciiParameter(firstName);
			
			bool _m_res = checkExistentNameInDatabase(firstName);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CREATETUTORIALBUILDING__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			createTutorialBuilding(player);
			
		}
		break;
	case RPC_CREATESKIPPEDTUTORIALBUILDING__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			createSkippedTutorialBuilding(player);
			
		}
		break;
	case RPC_CHECKSPEEDHACKSECONDTEST__CREATUREOBJECT_FLOAT_FLOAT_FLOAT_INT_SCENEOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			float newX = inv->getFloatParameter();
			float newZ = inv->getFloatParameter();
			float newY = inv->getFloatParameter();
			unsigned int newStamp = inv->getUnsignedIntParameter();
			SceneObject* newParent = static_cast<SceneObject*>(inv->getObjectParameter());
			
			int _m_res = checkSpeedHackSecondTest(player, newX, newZ, newY, newStamp, newParent);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_EXISTSNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			bool _m_res = existsName(name);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_EXISTSPLAYERCREATUREOID__LONG_:
		{
			unsigned long long oid = inv->getUnsignedLongParameter();
			
			bool _m_res = existsPlayerCreatureOID(oid);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETOBJECTID__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			unsigned long long _m_res = getObjectID(name);
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETPLAYERNAME__LONG_:
		{
			unsigned long long oid = inv->getUnsignedLongParameter();
			
			String _m_res = getPlayerName(oid);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETPLAYER__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			DistributedObject* _m_res = getPlayer(name);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_UPDATEPERMISSIONLEVEL__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int adminLevel = inv->getSignedIntParameter();
			
			updatePermissionLevel(player, adminLevel);
			
		}
		break;
	case RPC_UPDATEPERMISSIONNAME__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int adminLevel = inv->getSignedIntParameter();
			
			updatePermissionName(player, adminLevel);
			
		}
		break;
	case RPC_ADDPLAYER__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			addPlayer(player);
			
		}
		break;
	case RPC_REMOVEPLAYER__STRING_:
		{
			 String playerName; inv->getAsciiParameter(playerName);
			
			removePlayer(playerName);
			
		}
		break;
	case RPC_REMOVEPLAYER__LONG_:
		{
			unsigned long long playerID = inv->getUnsignedLongParameter();
			
			removePlayer(playerID);
			
		}
		break;
	case RPC_CONTAINSPLAYER__STRING_:
		{
			 String playerName; inv->getAsciiParameter(playerName);
			
			bool _m_res = containsPlayer(playerName);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDADMINJEDILIST__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendAdminJediList(player);
			
		}
		break;
	case RPC_SENDADMINFRSLIST__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendAdminFRSList(player);
			
		}
		break;
	case RPC_SENDADMINLIST__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendAdminList(player);
			
		}
		break;
	case RPC_GETNEARBYCRAFTINGSTATION__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int type = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getNearbyCraftingStation(player, type);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_FINISHHOLOGRIND__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			finishHologrind(player);
			
		}
		break;
	case RPC_BANACCOUNT__PLAYEROBJECT_ACCOUNT_INT_STRING_:
		{
			PlayerObject* admin = static_cast<PlayerObject*>(inv->getObjectParameter());
			Account* account = static_cast<Account*>(inv->getObjectParameter());
			unsigned int seconds = inv->getUnsignedIntParameter();
			 String reason; inv->getAsciiParameter(reason);
			
			String _m_res = banAccount(admin, account, seconds, reason);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_UNBANACCOUNT__PLAYEROBJECT_ACCOUNT_STRING_:
		{
			PlayerObject* admin = static_cast<PlayerObject*>(inv->getObjectParameter());
			Account* account = static_cast<Account*>(inv->getObjectParameter());
			 String reason; inv->getAsciiParameter(reason);
			
			String _m_res = unbanAccount(admin, account, reason);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_BANFROMGALAXY__PLAYEROBJECT_ACCOUNT_INT_INT_STRING_:
		{
			PlayerObject* admin = static_cast<PlayerObject*>(inv->getObjectParameter());
			Account* account = static_cast<Account*>(inv->getObjectParameter());
			unsigned const int galaxy = inv->getUnsignedIntParameter();
			unsigned int seconds = inv->getUnsignedIntParameter();
			 String reason; inv->getAsciiParameter(reason);
			
			String _m_res = banFromGalaxy(admin, account, galaxy, seconds, reason);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_UNBANFROMGALAXY__PLAYEROBJECT_ACCOUNT_INT_STRING_:
		{
			PlayerObject* admin = static_cast<PlayerObject*>(inv->getObjectParameter());
			Account* account = static_cast<Account*>(inv->getObjectParameter());
			unsigned const int galaxy = inv->getUnsignedIntParameter();
			 String reason; inv->getAsciiParameter(reason);
			
			String _m_res = unbanFromGalaxy(admin, account, galaxy, reason);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_BANCHARACTER__PLAYEROBJECT_ACCOUNT_STRING_INT_INT_STRING_:
		{
			PlayerObject* admin = static_cast<PlayerObject*>(inv->getObjectParameter());
			Account* account = static_cast<Account*>(inv->getObjectParameter());
			 String name; inv->getAsciiParameter(name);
			unsigned int galaxyID = inv->getUnsignedIntParameter();
			unsigned int seconds = inv->getUnsignedIntParameter();
			 String reason; inv->getAsciiParameter(reason);
			
			String _m_res = banCharacter(admin, account, name, galaxyID, seconds, reason);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_UNBANCHARACTER__PLAYEROBJECT_ACCOUNT_STRING_INT_STRING_:
		{
			PlayerObject* admin = static_cast<PlayerObject*>(inv->getObjectParameter());
			Account* account = static_cast<Account*>(inv->getObjectParameter());
			 String name; inv->getAsciiParameter(name);
			unsigned int galaxyID = inv->getUnsignedIntParameter();
			 String reason; inv->getAsciiParameter(reason);
			
			String _m_res = unbanCharacter(admin, account, name, galaxyID, reason);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_CLEAROWNEDSTRUCTURESPERMISSIONS__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			clearOwnedStructuresPermissions(player);
			
		}
		break;
	case RPC_PROMPTTEACHABLESKILLS__CREATUREOBJECT_SCENEOBJECT_:
		{
			CreatureObject* teacher = static_cast<CreatureObject*>(inv->getObjectParameter());
			SceneObject* target = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = promptTeachableSkills(teacher, target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_DECREASEONLINECHARCOUNT__ZONECLIENTSESSION_:
		{
			ZoneClientSession* client = static_cast<ZoneClientSession*>(inv->getObjectParameter());
			
			decreaseOnlineCharCount(client);
			
		}
		break;
	case RPC_INCREASEONLINECHARCOUNTIFPOSSIBLE__ZONECLIENTSESSION_:
		{
			ZoneClientSession* client = static_cast<ZoneClientSession*>(inv->getObjectParameter());
			
			bool _m_res = increaseOnlineCharCountIfPossible(client);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_DISCONNECTALLPLAYERS__:
		{
			
			disconnectAllPlayers();
			
		}
		break;
	case RPC_FIXHAM__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			fixHAM(player);
			
		}
		break;
	case RPC_FIXBUFFSKILLMODS__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			fixBuffSkillMods(player);
			
		}
		break;
	case RPC_GETPLAYERQUESTID__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			int _m_res = getPlayerQuestID(name);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETPLAYERQUESTPARENT__INT_:
		{
			int questID = inv->getSignedIntParameter();
			
			String _m_res = getPlayerQuestParent(questID);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETTOTALPLAYERQUESTS__:
		{
			
			int _m_res = getTotalPlayerQuests();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCLEANUPCHARACTERCOUNT__:
		{
			
			getCleanupCharacterCount();
			
		}
		break;
	case RPC_CLEANUPCHARACTERS__:
		{
			
			cleanupCharacters();
			
		}
		break;
	case RPC_SHOULDDELETECHARACTER__LONG_INT_:
		{
			unsigned long long characterID = inv->getUnsignedLongParameter();
			int galaxyID = inv->getSignedIntParameter();
			
			bool _m_res = shouldDeleteCharacter(characterID, galaxyID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_DOBURSTRUN__CREATUREOBJECT_FLOAT_FLOAT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			float hamModifier = inv->getFloatParameter();
			float cooldownModifier = inv->getFloatParameter();
			
			bool _m_res = doBurstRun(player, hamModifier, cooldownModifier);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ENHANCECHARACTER__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			enhanceCharacter(player);
			
		}
		break;
	case RPC_DOENHANCECHARACTER__INT_CREATUREOBJECT_INT_INT_INT_BYTE_:
		{
			unsigned int crc = inv->getUnsignedIntParameter();
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int amount = inv->getSignedIntParameter();
			int duration = inv->getSignedIntParameter();
			int buffType = inv->getSignedIntParameter();
			byte attribute = inv->getByteParameter();
			
			bool _m_res = doEnhanceCharacter(crc, player, amount, duration, buffType, attribute);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETBASESTOREDCREATUREPETS__:
		{
			
			int _m_res = getBaseStoredCreaturePets();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBASESTOREDFACTIONPETS__:
		{
			
			int _m_res = getBaseStoredFactionPets();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBASESTOREDDROIDS__:
		{
			
			int _m_res = getBaseStoredDroids();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBASESTOREDVEHICLES__:
		{
			
			int _m_res = getBaseStoredVehicles();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBASESTOREDSHIPS__:
		{
			
			int _m_res = getBaseStoredShips();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETNUMVETERANREWARDMILESTONES__:
		{
			
			int _m_res = getNumVeteranRewardMilestones();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETVETERANREWARDMILESTONE__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getVeteranRewardMilestone(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETNUMJUKEBOXSONGS__:
		{
			
			int _m_res = getNumJukeboxSongs();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETONLINECHARACTERSPERACCOUNT__INT_:
		{
			int count = inv->getSignedIntParameter();
			
			setOnlineCharactersPerAccount(count);
			
		}
		break;
	case RPC_UPDATEPVPKILLCOUNT__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			updatePvPKillCount(player);
			
		}
		break;
	case RPC_GETSPECIESXPMODIFIER__STRING_STRING_:
		{
			 String species; inv->getAsciiParameter(species);
			 String xpType; inv->getAsciiParameter(xpType);
			
			float _m_res = getSpeciesXpModifier(species, xpType);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_UNLOCKFRSFORTESTING__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int councilType = inv->getSignedIntParameter();
			
			unlockFRSForTesting(player, councilType);
			
		}
		break;
	case RPC_UPDATEONLINEPLAYERS__:
		{
			
			updateOnlinePlayers();
			
		}
		break;
	case RPC_STOPONLINEPLAYERLOGTASK__:
		{
			
			stopOnlinePlayerLogTask();
			
		}
		break;
	default:
		ObserverAdapter::invokeMethod(methid, inv);
	}
}

void PlayerManagerAdapter::loadNameMap() {
	(static_cast<PlayerManager*>(stub))->loadNameMap();
}

void PlayerManagerAdapter::finalize() {
	(static_cast<PlayerManager*>(stub))->finalize();
}

bool PlayerManagerAdapter::kickUser(const String& name, const String& admin, String& reason, bool doBan) {
	return (static_cast<PlayerManager*>(stub))->kickUser(name, admin, reason, doBan);
}

String PlayerManagerAdapter::setFirstName(CreatureObject* creature, const String& newFirstName) {
	return (static_cast<PlayerManager*>(stub))->setFirstName(creature, newFirstName);
}

String PlayerManagerAdapter::setLastName(CreatureObject* creature, const String& newLastName, bool skipVerify) {
	return (static_cast<PlayerManager*>(stub))->setLastName(creature, newLastName, skipVerify);
}

int PlayerManagerAdapter::notifyObserverEvent(unsigned int eventType, Observable* observable, ManagedObject* arg1, long long arg2) {
	return (static_cast<PlayerManager*>(stub))->notifyObserverEvent(eventType, observable, arg1, arg2);
}

int PlayerManagerAdapter::notifyDestruction(TangibleObject* destructor, TangibleObject* destructedObject, int condition, bool isCombatAction) {
	return (static_cast<PlayerManager*>(stub))->notifyDestruction(destructor, destructedObject, condition, isCombatAction);
}

bool PlayerManagerAdapter::shouldRescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai) {
	return (static_cast<PlayerManager*>(stub))->shouldRescheduleCorpseDestruction(player, ai);
}

void PlayerManagerAdapter::rescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai) {
	(static_cast<PlayerManager*>(stub))->rescheduleCorpseDestruction(player, ai);
}

bool PlayerManagerAdapter::canGroupMemberHarvestCorpse(CreatureObject* player, Creature* creature) {
	return (static_cast<PlayerManager*>(stub))->canGroupMemberHarvestCorpse(player, creature);
}

void PlayerManagerAdapter::killPlayer(TangibleObject* attacker, CreatureObject* player, int typeofdeath, bool isCombatAction) {
	(static_cast<PlayerManager*>(stub))->killPlayer(attacker, player, typeofdeath, isCombatAction);
}

byte PlayerManagerAdapter::calculateIncapacitationTimer(CreatureObject* player, int condition) {
	return (static_cast<PlayerManager*>(stub))->calculateIncapacitationTimer(player, condition);
}

bool PlayerManagerAdapter::checkEncumbrancies(CreatureObject* player, ArmorObject* armor) {
	return (static_cast<PlayerManager*>(stub))->checkEncumbrancies(player, armor);
}

void PlayerManagerAdapter::applyEncumbrancies(CreatureObject* player, ArmorObject* armor) {
	(static_cast<PlayerManager*>(stub))->applyEncumbrancies(player, armor);
}

void PlayerManagerAdapter::removeEncumbrancies(CreatureObject* player, ArmorObject* armor) {
	(static_cast<PlayerManager*>(stub))->removeEncumbrancies(player, armor);
}

void PlayerManagerAdapter::awardBadge(PlayerObject* ghost, unsigned int badge) {
	(static_cast<PlayerManager*>(stub))->awardBadge(ghost, badge);
}

void PlayerManagerAdapter::setExperienceMultiplier(float globalMultiplier) {
	(static_cast<PlayerManager*>(stub))->setExperienceMultiplier(globalMultiplier);
}

int PlayerManagerAdapter::awardExperience(CreatureObject* player, const String& xpType, int amount, bool sendSystemMessage, float localMultiplier, bool applyModifiers) {
	return (static_cast<PlayerManager*>(stub))->awardExperience(player, xpType, amount, sendSystemMessage, localMultiplier, applyModifiers);
}

void PlayerManagerAdapter::handleAbortTradeMessage(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->handleAbortTradeMessage(player);
}

void PlayerManagerAdapter::handleAddItemToTradeWindow(CreatureObject* player, unsigned long long itemID) {
	(static_cast<PlayerManager*>(stub))->handleAddItemToTradeWindow(player, itemID);
}

void PlayerManagerAdapter::handleGiveMoneyMessage(CreatureObject* player, unsigned int value) {
	(static_cast<PlayerManager*>(stub))->handleGiveMoneyMessage(player, value);
}

void PlayerManagerAdapter::handleAcceptTransactionMessage(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->handleAcceptTransactionMessage(player);
}

void PlayerManagerAdapter::handleUnAcceptTransactionMessage(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->handleUnAcceptTransactionMessage(player);
}

void PlayerManagerAdapter::handleVerifyTradeMessage(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->handleVerifyTradeMessage(player);
}

bool PlayerManagerAdapter::checkTradeItems(CreatureObject* player, CreatureObject* receiver) {
	return (static_cast<PlayerManager*>(stub))->checkTradeItems(player, receiver);
}

SceneObject* PlayerManagerAdapter::getInRangeStructureWithAdminRights(CreatureObject* creature, unsigned long long targetID) {
	return (static_cast<PlayerManager*>(stub))->getInRangeStructureWithAdminRights(creature, targetID);
}

StructureObject* PlayerManagerAdapter::getInRangeOwnedStructure(CreatureObject* creature, float range) {
	return (static_cast<PlayerManager*>(stub))->getInRangeOwnedStructure(creature, range);
}

void PlayerManagerAdapter::sendBattleFatigueMessage(CreatureObject* player, CreatureObject* target) {
	(static_cast<PlayerManager*>(stub))->sendBattleFatigueMessage(player, target);
}

void PlayerManagerAdapter::stopWatch(CreatureObject* creature, unsigned long long entid, bool doSendPackets, bool forced, bool doLock, bool outOfRange) {
	(static_cast<PlayerManager*>(stub))->stopWatch(creature, entid, doSendPackets, forced, doLock, outOfRange);
}

void PlayerManagerAdapter::stopListen(CreatureObject* creature, unsigned long long entid, bool doSendPackets, bool forced, bool doLock, bool outOfRange) {
	(static_cast<PlayerManager*>(stub))->stopListen(creature, entid, doSendPackets, forced, doLock, outOfRange);
}

void PlayerManagerAdapter::startWatch(CreatureObject* creature, unsigned long long entid) {
	(static_cast<PlayerManager*>(stub))->startWatch(creature, entid);
}

void PlayerManagerAdapter::startListen(CreatureObject* creature, unsigned long long entid) {
	(static_cast<PlayerManager*>(stub))->startListen(creature, entid);
}

void PlayerManagerAdapter::lootAll(CreatureObject* player, CreatureObject* creature) {
	(static_cast<PlayerManager*>(stub))->lootAll(player, creature);
}

void PlayerManagerAdapter::proposeUnity(CreatureObject* askingPlayer, CreatureObject* respondingPlayer, SceneObject* askingPlayerRing) {
	(static_cast<PlayerManager*>(stub))->proposeUnity(askingPlayer, respondingPlayer, askingPlayerRing);
}

void PlayerManagerAdapter::denyUnity(CreatureObject* respondingPlayer) {
	(static_cast<PlayerManager*>(stub))->denyUnity(respondingPlayer);
}

void PlayerManagerAdapter::acceptUnity(CreatureObject* respondingPlayer) {
	(static_cast<PlayerManager*>(stub))->acceptUnity(respondingPlayer);
}

void PlayerManagerAdapter::completeUnity(CreatureObject* respondingPlayer, unsigned long long respondingPlayerRing) {
	(static_cast<PlayerManager*>(stub))->completeUnity(respondingPlayer, respondingPlayerRing);
}

void PlayerManagerAdapter::promptDivorce(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->promptDivorce(player);
}

void PlayerManagerAdapter::grantDivorce(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->grantDivorce(player);
}

void PlayerManagerAdapter::claimVeteranRewards(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->claimVeteranRewards(player);
}

int PlayerManagerAdapter::getEligibleMilestone(PlayerObject* playerGhost, Account* account) {
	return (static_cast<PlayerManager*>(stub))->getEligibleMilestone(playerGhost, account);
}

int PlayerManagerAdapter::getFirstIneligibleMilestone(PlayerObject* playerGhost, Account* account) {
	return (static_cast<PlayerManager*>(stub))->getFirstIneligibleMilestone(playerGhost, account);
}

void PlayerManagerAdapter::cancelVeteranRewardSession(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->cancelVeteranRewardSession(player);
}

void PlayerManagerAdapter::confirmVeteranReward(CreatureObject* player, int itemIndex) {
	(static_cast<PlayerManager*>(stub))->confirmVeteranReward(player, itemIndex);
}

void PlayerManagerAdapter::generateVeteranReward(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->generateVeteranReward(player);
}

int PlayerManagerAdapter::healEnhance(CreatureObject* enhancer, CreatureObject* patient, byte attribute, int buffvalue, float duration, int absorption) {
	return (static_cast<PlayerManager*>(stub))->healEnhance(enhancer, patient, attribute, buffvalue, duration, absorption);
}

int PlayerManagerAdapter::calculatePlayerLevel(CreatureObject* player) {
	return (static_cast<PlayerManager*>(stub))->calculatePlayerLevel(player);
}

int PlayerManagerAdapter::calculatePlayerLevel(CreatureObject* player, String& xpType) {
	return (static_cast<PlayerManager*>(stub))->calculatePlayerLevel(player, xpType);
}

void PlayerManagerAdapter::sendLoginMessage(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->sendLoginMessage(player);
}

void PlayerManagerAdapter::resendLoginMessageToAll() {
	(static_cast<PlayerManager*>(stub))->resendLoginMessageToAll();
}

void PlayerManagerAdapter::sendActivateCloneRequest(CreatureObject* player, int typeofdeath) {
	(static_cast<PlayerManager*>(stub))->sendActivateCloneRequest(player, typeofdeath);
}

bool PlayerManagerAdapter::isValidClosestCloner(CreatureObject* player, SceneObject* cloner) {
	return (static_cast<PlayerManager*>(stub))->isValidClosestCloner(player, cloner);
}

void PlayerManagerAdapter::sendPlayerToCloner(CreatureObject* player, unsigned long long clonerID, int typeofdeath) {
	(static_cast<PlayerManager*>(stub))->sendPlayerToCloner(player, clonerID, typeofdeath);
}

void PlayerManagerAdapter::ejectPlayerFromBuilding(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->ejectPlayerFromBuilding(player);
}

bool PlayerManagerAdapter::checkExistentNameInDatabase(const String& firstName) {
	return (static_cast<PlayerManager*>(stub))->checkExistentNameInDatabase(firstName);
}

void PlayerManagerAdapter::createTutorialBuilding(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->createTutorialBuilding(player);
}

void PlayerManagerAdapter::createSkippedTutorialBuilding(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->createSkippedTutorialBuilding(player);
}

int PlayerManagerAdapter::checkSpeedHackSecondTest(CreatureObject* player, float newX, float newZ, float newY, unsigned int newStamp, SceneObject* newParent) {
	return (static_cast<PlayerManager*>(stub))->checkSpeedHackSecondTest(player, newX, newZ, newY, newStamp, newParent);
}

bool PlayerManagerAdapter::existsName(const String& name) {
	return (static_cast<PlayerManager*>(stub))->existsName(name);
}

bool PlayerManagerAdapter::existsPlayerCreatureOID(unsigned long long oid) {
	return (static_cast<PlayerManager*>(stub))->existsPlayerCreatureOID(oid);
}

unsigned long long PlayerManagerAdapter::getObjectID(const String& name) {
	return (static_cast<PlayerManager*>(stub))->getObjectID(name);
}

String PlayerManagerAdapter::getPlayerName(unsigned long long oid) {
	return (static_cast<PlayerManager*>(stub))->getPlayerName(oid);
}

Reference<CreatureObject* > PlayerManagerAdapter::getPlayer(const String& name) {
	return (static_cast<PlayerManager*>(stub))->getPlayer(name);
}

void PlayerManagerAdapter::updatePermissionLevel(CreatureObject* player, int adminLevel) {
	(static_cast<PlayerManager*>(stub))->updatePermissionLevel(player, adminLevel);
}

void PlayerManagerAdapter::updatePermissionName(CreatureObject* player, int adminLevel) {
	(static_cast<PlayerManager*>(stub))->updatePermissionName(player, adminLevel);
}

void PlayerManagerAdapter::addPlayer(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->addPlayer(player);
}

void PlayerManagerAdapter::removePlayer(const String& playerName) {
	(static_cast<PlayerManager*>(stub))->removePlayer(playerName);
}

void PlayerManagerAdapter::removePlayer(unsigned long long playerID) {
	(static_cast<PlayerManager*>(stub))->removePlayer(playerID);
}

bool PlayerManagerAdapter::containsPlayer(const String& playerName) {
	return (static_cast<PlayerManager*>(stub))->containsPlayer(playerName);
}

void PlayerManagerAdapter::sendAdminJediList(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->sendAdminJediList(player);
}

void PlayerManagerAdapter::sendAdminFRSList(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->sendAdminFRSList(player);
}

void PlayerManagerAdapter::sendAdminList(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->sendAdminList(player);
}

CraftingStation* PlayerManagerAdapter::getNearbyCraftingStation(CreatureObject* player, int type) {
	return (static_cast<PlayerManager*>(stub))->getNearbyCraftingStation(player, type);
}

void PlayerManagerAdapter::finishHologrind(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->finishHologrind(player);
}

String PlayerManagerAdapter::banAccount(PlayerObject* admin, Account* account, unsigned int seconds, const String& reason) {
	return (static_cast<PlayerManager*>(stub))->banAccount(admin, account, seconds, reason);
}

String PlayerManagerAdapter::unbanAccount(PlayerObject* admin, Account* account, const String& reason) {
	return (static_cast<PlayerManager*>(stub))->unbanAccount(admin, account, reason);
}

String PlayerManagerAdapter::banFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, unsigned int seconds, const String& reason) {
	return (static_cast<PlayerManager*>(stub))->banFromGalaxy(admin, account, galaxy, seconds, reason);
}

String PlayerManagerAdapter::unbanFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, const String& reason) {
	return (static_cast<PlayerManager*>(stub))->unbanFromGalaxy(admin, account, galaxy, reason);
}

String PlayerManagerAdapter::banCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, unsigned int seconds, const String& reason) {
	return (static_cast<PlayerManager*>(stub))->banCharacter(admin, account, name, galaxyID, seconds, reason);
}

String PlayerManagerAdapter::unbanCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, const String& reason) {
	return (static_cast<PlayerManager*>(stub))->unbanCharacter(admin, account, name, galaxyID, reason);
}

void PlayerManagerAdapter::clearOwnedStructuresPermissions(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->clearOwnedStructuresPermissions(player);
}

bool PlayerManagerAdapter::promptTeachableSkills(CreatureObject* teacher, SceneObject* target) {
	return (static_cast<PlayerManager*>(stub))->promptTeachableSkills(teacher, target);
}

void PlayerManagerAdapter::decreaseOnlineCharCount(ZoneClientSession* client) {
	(static_cast<PlayerManager*>(stub))->decreaseOnlineCharCount(client);
}

bool PlayerManagerAdapter::increaseOnlineCharCountIfPossible(ZoneClientSession* client) {
	return (static_cast<PlayerManager*>(stub))->increaseOnlineCharCountIfPossible(client);
}

void PlayerManagerAdapter::disconnectAllPlayers() {
	(static_cast<PlayerManager*>(stub))->disconnectAllPlayers();
}

void PlayerManagerAdapter::fixHAM(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->fixHAM(player);
}

void PlayerManagerAdapter::fixBuffSkillMods(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->fixBuffSkillMods(player);
}

int PlayerManagerAdapter::getPlayerQuestID(const String& name) {
	return (static_cast<PlayerManager*>(stub))->getPlayerQuestID(name);
}

String PlayerManagerAdapter::getPlayerQuestParent(int questID) {
	return (static_cast<PlayerManager*>(stub))->getPlayerQuestParent(questID);
}

int PlayerManagerAdapter::getTotalPlayerQuests() {
	return (static_cast<PlayerManager*>(stub))->getTotalPlayerQuests();
}

void PlayerManagerAdapter::getCleanupCharacterCount() {
	(static_cast<PlayerManager*>(stub))->getCleanupCharacterCount();
}

void PlayerManagerAdapter::cleanupCharacters() {
	(static_cast<PlayerManager*>(stub))->cleanupCharacters();
}

bool PlayerManagerAdapter::shouldDeleteCharacter(unsigned long long characterID, int galaxyID) {
	return (static_cast<PlayerManager*>(stub))->shouldDeleteCharacter(characterID, galaxyID);
}

bool PlayerManagerAdapter::doBurstRun(CreatureObject* player, float hamModifier, float cooldownModifier) {
	return (static_cast<PlayerManager*>(stub))->doBurstRun(player, hamModifier, cooldownModifier);
}

void PlayerManagerAdapter::enhanceCharacter(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->enhanceCharacter(player);
}

bool PlayerManagerAdapter::doEnhanceCharacter(unsigned int crc, CreatureObject* player, int amount, int duration, int buffType, byte attribute) {
	return (static_cast<PlayerManager*>(stub))->doEnhanceCharacter(crc, player, amount, duration, buffType, attribute);
}

int PlayerManagerAdapter::getBaseStoredCreaturePets() {
	return (static_cast<PlayerManager*>(stub))->getBaseStoredCreaturePets();
}

int PlayerManagerAdapter::getBaseStoredFactionPets() {
	return (static_cast<PlayerManager*>(stub))->getBaseStoredFactionPets();
}

int PlayerManagerAdapter::getBaseStoredDroids() {
	return (static_cast<PlayerManager*>(stub))->getBaseStoredDroids();
}

int PlayerManagerAdapter::getBaseStoredVehicles() {
	return (static_cast<PlayerManager*>(stub))->getBaseStoredVehicles();
}

int PlayerManagerAdapter::getBaseStoredShips() {
	return (static_cast<PlayerManager*>(stub))->getBaseStoredShips();
}

int PlayerManagerAdapter::getNumVeteranRewardMilestones() {
	return (static_cast<PlayerManager*>(stub))->getNumVeteranRewardMilestones();
}

int PlayerManagerAdapter::getVeteranRewardMilestone(int index) {
	return (static_cast<PlayerManager*>(stub))->getVeteranRewardMilestone(index);
}

int PlayerManagerAdapter::getNumJukeboxSongs() {
	return (static_cast<PlayerManager*>(stub))->getNumJukeboxSongs();
}

void PlayerManagerAdapter::setOnlineCharactersPerAccount(int count) {
	(static_cast<PlayerManager*>(stub))->setOnlineCharactersPerAccount(count);
}

void PlayerManagerAdapter::updatePvPKillCount(CreatureObject* player) {
	(static_cast<PlayerManager*>(stub))->updatePvPKillCount(player);
}

float PlayerManagerAdapter::getSpeciesXpModifier(const String& species, const String& xpType) {
	return (static_cast<PlayerManager*>(stub))->getSpeciesXpModifier(species, xpType);
}

void PlayerManagerAdapter::unlockFRSForTesting(CreatureObject* player, int councilType) {
	(static_cast<PlayerManager*>(stub))->unlockFRSForTesting(player, councilType);
}

void PlayerManagerAdapter::updateOnlinePlayers() {
	(static_cast<PlayerManager*>(stub))->updateOnlinePlayers();
}

void PlayerManagerAdapter::stopOnlinePlayerLogTask() {
	(static_cast<PlayerManager*>(stub))->stopOnlinePlayerLogTask();
}

/*
 *	PlayerManagerHelper
 */

PlayerManagerHelper* PlayerManagerHelper::staticInitializer = PlayerManagerHelper::instance();

PlayerManagerHelper::PlayerManagerHelper() {
	className = "PlayerManager";

	Core::getObjectBroker()->registerClass(className, this);
}

void PlayerManagerHelper::finalizeHelper() {
	PlayerManagerHelper::finalize();
}

DistributedObject* PlayerManagerHelper::instantiateObject() {
	return new PlayerManager(DummyConstructorParameter::instance());
}

DistributedObjectServant* PlayerManagerHelper::instantiateServant() {
	return new PlayerManagerImplementation(DummyConstructorParameter::instance());
}

DistributedObjectPOD* PlayerManagerHelper::instantiatePOD() {
	return new PlayerManagerPOD();
}

DistributedObjectAdapter* PlayerManagerHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new PlayerManagerAdapter(static_cast<PlayerManager*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	PlayerManagerPOD
 */

PlayerManagerPOD::~PlayerManagerPOD() {
	finalize();
}

PlayerManagerPOD::PlayerManagerPOD(void) {
	_className = "PlayerManager";
}


void PlayerManagerPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlayerManagerPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlayerManagerPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ObserverPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (performanceBuff) {
	_nameHashCode = 0xc199e00f; //PlayerManager.performanceBuff
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&performanceBuff.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (medicalBuff) {
	_nameHashCode = 0xe0ebf015; //PlayerManager.medicalBuff
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&medicalBuff.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (performanceDuration) {
	_nameHashCode = 0xf4f2a5f1; //PlayerManager.performanceDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&performanceDuration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (medicalDuration) {
	_nameHashCode = 0xe2b9cf5c; //PlayerManager.medicalDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&medicalDuration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (baseStoredCreaturePets) {
	_nameHashCode = 0x20a067d7; //PlayerManager.baseStoredCreaturePets
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredCreaturePets.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (baseStoredFactionPets) {
	_nameHashCode = 0xac12787d; //PlayerManager.baseStoredFactionPets
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredFactionPets.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (baseStoredDroids) {
	_nameHashCode = 0xba4799c2; //PlayerManager.baseStoredDroids
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredDroids.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (baseStoredVehicles) {
	_nameHashCode = 0x903249ac; //PlayerManager.baseStoredVehicles
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredVehicles.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (baseStoredShips) {
	_nameHashCode = 0xd5b2476d; //PlayerManager.baseStoredShips
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&baseStoredShips.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (allowSameAccountPvpRatingCredit) {
	_nameHashCode = 0x98ad7d2d; //PlayerManager.allowSameAccountPvpRatingCredit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&allowSameAccountPvpRatingCredit.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (onlineCharactersPerAccount) {
	_nameHashCode = 0x21ee7a31; //PlayerManager.onlineCharactersPerAccount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&onlineCharactersPerAccount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (xpBonusList) {
	_nameHashCode = 0x35715026; //PlayerManager.xpBonusList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<XpBonusList >::toBinaryStream(&xpBonusList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (veteranRewardMilestones) {
	_nameHashCode = 0xcc4f885f; //PlayerManager.veteranRewardMilestones
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<int> >::toBinaryStream(&veteranRewardMilestones.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (veteranRewardAdditionalMilestones) {
	_nameHashCode = 0xbc32fef9; //PlayerManager.veteranRewardAdditionalMilestones
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&veteranRewardAdditionalMilestones.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (veteranRewards) {
	_nameHashCode = 0xbfedc931; //PlayerManager.veteranRewards
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VeteranRewardList >::toBinaryStream(&veteranRewards.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (server) {
	_nameHashCode = 0x3d6a23c8; //PlayerManager.server
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<ZoneServerPOD* > >::toBinaryStream(&server.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (globalExpMultiplier) {
	_nameHashCode = 0x66f52932; //PlayerManager.globalExpMultiplier
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&globalExpMultiplier.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (groupExpMultiplier) {
	_nameHashCode = 0xdccf1a2f; //PlayerManager.groupExpMultiplier
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&groupExpMultiplier.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool PlayerManagerPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ObserverPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xc199e00f: //PlayerManager.performanceBuff
		{
			int _mnperformanceBuff;
			TypeInfo<int >::parseFromBinaryStream(&_mnperformanceBuff, stream);
			performanceBuff = std::move(_mnperformanceBuff);
		}
		return true;

	case 0xe0ebf015: //PlayerManager.medicalBuff
		{
			int _mnmedicalBuff;
			TypeInfo<int >::parseFromBinaryStream(&_mnmedicalBuff, stream);
			medicalBuff = std::move(_mnmedicalBuff);
		}
		return true;

	case 0xf4f2a5f1: //PlayerManager.performanceDuration
		{
			int _mnperformanceDuration;
			TypeInfo<int >::parseFromBinaryStream(&_mnperformanceDuration, stream);
			performanceDuration = std::move(_mnperformanceDuration);
		}
		return true;

	case 0xe2b9cf5c: //PlayerManager.medicalDuration
		{
			int _mnmedicalDuration;
			TypeInfo<int >::parseFromBinaryStream(&_mnmedicalDuration, stream);
			medicalDuration = std::move(_mnmedicalDuration);
		}
		return true;

	case 0x20a067d7: //PlayerManager.baseStoredCreaturePets
		{
			int _mnbaseStoredCreaturePets;
			TypeInfo<int >::parseFromBinaryStream(&_mnbaseStoredCreaturePets, stream);
			baseStoredCreaturePets = std::move(_mnbaseStoredCreaturePets);
		}
		return true;

	case 0xac12787d: //PlayerManager.baseStoredFactionPets
		{
			int _mnbaseStoredFactionPets;
			TypeInfo<int >::parseFromBinaryStream(&_mnbaseStoredFactionPets, stream);
			baseStoredFactionPets = std::move(_mnbaseStoredFactionPets);
		}
		return true;

	case 0xba4799c2: //PlayerManager.baseStoredDroids
		{
			int _mnbaseStoredDroids;
			TypeInfo<int >::parseFromBinaryStream(&_mnbaseStoredDroids, stream);
			baseStoredDroids = std::move(_mnbaseStoredDroids);
		}
		return true;

	case 0x903249ac: //PlayerManager.baseStoredVehicles
		{
			int _mnbaseStoredVehicles;
			TypeInfo<int >::parseFromBinaryStream(&_mnbaseStoredVehicles, stream);
			baseStoredVehicles = std::move(_mnbaseStoredVehicles);
		}
		return true;

	case 0xd5b2476d: //PlayerManager.baseStoredShips
		{
			int _mnbaseStoredShips;
			TypeInfo<int >::parseFromBinaryStream(&_mnbaseStoredShips, stream);
			baseStoredShips = std::move(_mnbaseStoredShips);
		}
		return true;

	case 0x98ad7d2d: //PlayerManager.allowSameAccountPvpRatingCredit
		{
			bool _mnallowSameAccountPvpRatingCredit;
			TypeInfo<bool >::parseFromBinaryStream(&_mnallowSameAccountPvpRatingCredit, stream);
			allowSameAccountPvpRatingCredit = std::move(_mnallowSameAccountPvpRatingCredit);
		}
		return true;

	case 0x21ee7a31: //PlayerManager.onlineCharactersPerAccount
		{
			int _mnonlineCharactersPerAccount;
			TypeInfo<int >::parseFromBinaryStream(&_mnonlineCharactersPerAccount, stream);
			onlineCharactersPerAccount = std::move(_mnonlineCharactersPerAccount);
		}
		return true;

	case 0x35715026: //PlayerManager.xpBonusList
		{
			XpBonusList _mnxpBonusList;
			TypeInfo<XpBonusList >::parseFromBinaryStream(&_mnxpBonusList, stream);
			xpBonusList = std::move(_mnxpBonusList);
		}
		return true;

	case 0xcc4f885f: //PlayerManager.veteranRewardMilestones
		{
			SortedVector<int> _mnveteranRewardMilestones;
			TypeInfo<SortedVector<int> >::parseFromBinaryStream(&_mnveteranRewardMilestones, stream);
			veteranRewardMilestones = std::move(_mnveteranRewardMilestones);
		}
		return true;

	case 0xbc32fef9: //PlayerManager.veteranRewardAdditionalMilestones
		{
			int _mnveteranRewardAdditionalMilestones;
			TypeInfo<int >::parseFromBinaryStream(&_mnveteranRewardAdditionalMilestones, stream);
			veteranRewardAdditionalMilestones = std::move(_mnveteranRewardAdditionalMilestones);
		}
		return true;

	case 0xbfedc931: //PlayerManager.veteranRewards
		{
			VeteranRewardList _mnveteranRewards;
			TypeInfo<VeteranRewardList >::parseFromBinaryStream(&_mnveteranRewards, stream);
			veteranRewards = std::move(_mnveteranRewards);
		}
		return true;

	case 0x3d6a23c8: //PlayerManager.server
		{
			ManagedReference<ZoneServerPOD* > _mnserver;
			TypeInfo<ManagedReference<ZoneServerPOD* > >::parseFromBinaryStream(&_mnserver, stream);
			server = std::move(_mnserver);
		}
		return true;

	case 0x66f52932: //PlayerManager.globalExpMultiplier
		{
			float _mnglobalExpMultiplier;
			TypeInfo<float >::parseFromBinaryStream(&_mnglobalExpMultiplier, stream);
			globalExpMultiplier = std::move(_mnglobalExpMultiplier);
		}
		return true;

	case 0xdccf1a2f: //PlayerManager.groupExpMultiplier
		{
			float _mngroupExpMultiplier;
			TypeInfo<float >::parseFromBinaryStream(&_mngroupExpMultiplier, stream);
			groupExpMultiplier = std::move(_mngroupExpMultiplier);
		}
		return true;

	}

	return false;
}

void PlayerManagerPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PlayerManagerPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void PlayerManagerPOD::writeObjectCompact(ObjectOutputStream* stream) {
	ObserverPOD::writeObjectCompact(stream);

	TypeInfo<int >::toBinaryStream(&performanceBuff.value(), stream);

	TypeInfo<int >::toBinaryStream(&medicalBuff.value(), stream);

	TypeInfo<int >::toBinaryStream(&performanceDuration.value(), stream);

	TypeInfo<int >::toBinaryStream(&medicalDuration.value(), stream);

	TypeInfo<int >::toBinaryStream(&baseStoredCreaturePets.value(), stream);

	TypeInfo<int >::toBinaryStream(&baseStoredFactionPets.value(), stream);

	TypeInfo<int >::toBinaryStream(&baseStoredDroids.value(), stream);

	TypeInfo<int >::toBinaryStream(&baseStoredVehicles.value(), stream);

	TypeInfo<int >::toBinaryStream(&baseStoredShips.value(), stream);

	TypeInfo<bool >::toBinaryStream(&allowSameAccountPvpRatingCredit.value(), stream);

	TypeInfo<int >::toBinaryStream(&onlineCharactersPerAccount.value(), stream);

	TypeInfo<XpBonusList >::toBinaryStream(&xpBonusList.value(), stream);

	TypeInfo<SortedVector<int> >::toBinaryStream(&veteranRewardMilestones.value(), stream);

	TypeInfo<int >::toBinaryStream(&veteranRewardAdditionalMilestones.value(), stream);

	TypeInfo<VeteranRewardList >::toBinaryStream(&veteranRewards.value(), stream);

	TypeInfo<ManagedReference<ZoneServerPOD* > >::toBinaryStream(&server.value(), stream);

	TypeInfo<float >::toBinaryStream(&globalExpMultiplier.value(), stream);

	TypeInfo<float >::toBinaryStream(&groupExpMultiplier.value(), stream);


}

