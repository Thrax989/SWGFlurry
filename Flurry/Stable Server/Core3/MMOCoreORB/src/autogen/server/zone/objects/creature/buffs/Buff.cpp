/*
 *	autogen/server/zone/objects/creature/buffs/Buff.cpp generated by engine3 IDL compiler 0.70
 */

#include "Buff.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/creature/buffs/BuffDurationEvent.h"

/*
 *	BuffStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 837587754,RPC_NOTIFYLOADFROMDATABASE__,RPC_LOADBUFFDURATIONEVENT__CREATUREOBJECT_,RPC_INIT__,RPC_SENDTO__CREATUREOBJECT_,RPC_SENDDESTROYTO__CREATUREOBJECT_,RPC_ACTIVATE__BOOL_,RPC_DEACTIVATE__BOOL_,RPC_ACTIVATE__,RPC_DEACTIVATE__,RPC_CHECKRENEW__,RPC_APPLYATTRIBUTEMODIFIERS__,RPC_APPLYSKILLMODIFIERS__,RPC_APPLYSTATES__,RPC_APPLYALLMODIFIERS__,RPC_REMOVEATTRIBUTEMODIFIERS__,RPC_REMOVESKILLMODIFIERS__,RPC_REMOVESTATES__,RPC_REMOVEALLMODIFIERS__,RPC_CLEARBUFFEVENT__,RPC_SETBUFFEVENTNULL__,RPC_SCHEDULEBUFFEVENT__,RPC_RENEW__FLOAT_,RPC_PARSEATTRIBUTEMODIFIERSTRING__STRING_,RPC_PARSESKILLMODIFIERSTRING__STRING_,RPC_GETATTRIBUTEMODIFIERSTRING__,RPC_GETSKILLMODIFIERSTRING__,RPC_GETTIMELEFT__,RPC_SETATTRIBUTEMODIFIER__BYTE_INT_,RPC_SETSKILLMODIFIER__STRING_INT_,RPC_ADDSTATE__LONG_,RPC_SETSPEEDMULTIPLIERMOD__FLOAT_,RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_,RPC_GETSPEEDMULTIPLIERMOD__,RPC_GETACCELERATIONMULTIPLIERMOD__,RPC_SETFILLATTRIBUTESONBUFF__BOOL_,RPC_GETBUFFNAME__,RPC_GETBUFFCRC__,RPC_GETBUFFDURATION__,RPC_GETBUFFTYPE__,RPC_GETATTRIBUTEMODIFIERVALUE__BYTE_,RPC_GETSKILLMODIFIERVALUE__STRING_,RPC_ISACTIVE__,RPC_ISSPICEBUFF__,RPC_ISATTRIBUTEBUFF__,RPC_SETSPAMCOLOR__BYTE_,RPC_SETBROADCASTSPAM__BOOL_,RPC_SETSTARTFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_,RPC_SETENDFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_,RPC_ADDSECONDARYBUFFCRC__LONG_,RPC_COMPARETO__BUFF_,RPC_HASMODS__,RPC_SETMODSAPPLIED__BOOL_,RPC_REMOVEONCLEARBUFFS__};

Buff::Buff(CreatureObject* creo, unsigned int buffcrc, float duration, int bufftype, unsigned long long secondaryCRC) : ManagedObject(DummyConstructorParameter::instance()) {
	BuffImplementation* _implementation = new BuffImplementation(creo, buffcrc, duration, bufftype, secondaryCRC);
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("Buff");
}

Buff::Buff(DummyConstructorParameter* param) : ManagedObject(param) {
	_setClassName("Buff");
}

Buff::~Buff() {
}



void Buff::initializeTransientMembers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void Buff::notifyLoadFromDatabase() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

void Buff::loadBuffDurationEvent(CreatureObject* creo) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOADBUFFDURATIONEVENT__CREATUREOBJECT_);
		method.addObjectParameter(creo);

		method.executeWithVoidReturn();
	} else {
		_implementation->loadBuffDurationEvent(creo);
	}
}

void Buff::init() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INIT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->init();
	}
}

void Buff::sendTo(CreatureObject* player) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendTo(player);
	}
}

void Buff::sendDestroyTo(CreatureObject* player) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDDESTROYTO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendDestroyTo(player);
	}
}

void Buff::activate(bool applyModifiers) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATE__BOOL_);
		method.addBooleanParameter(applyModifiers);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activate(applyModifiers);
	}
}

void Buff::deactivate(bool removeModifiers) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DEACTIVATE__BOOL_);
		method.addBooleanParameter(removeModifiers);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->deactivate(removeModifiers);
	}
}

void Buff::activate() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->activate();
	}
}

void Buff::deactivate() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DEACTIVATE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->deactivate();
	}
}

bool Buff::checkRenew() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKRENEW__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkRenew();
	}
}

VectorMap<String, int>* Buff::getSkillModifiers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSkillModifiers();
	}
}

void Buff::applyAttributeModifiers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYATTRIBUTEMODIFIERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->applyAttributeModifiers();
	}
}

void Buff::applySkillModifiers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYSKILLMODIFIERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->applySkillModifiers();
	}
}

void Buff::applyStates() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYSTATES__);

		method.executeWithVoidReturn();
	} else {
		_implementation->applyStates();
	}
}

void Buff::applyAllModifiers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYALLMODIFIERS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->applyAllModifiers();
	}
}

void Buff::removeAttributeModifiers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEATTRIBUTEMODIFIERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeAttributeModifiers();
	}
}

void Buff::removeSkillModifiers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLMODIFIERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSkillModifiers();
	}
}

void Buff::removeStates() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESTATES__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeStates();
	}
}

void Buff::removeAllModifiers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEALLMODIFIERS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeAllModifiers();
	}
}

void Buff::clearBuffEvent() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARBUFFEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearBuffEvent();
	}
}

void Buff::setBuffEventNull() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBUFFEVENTNULL__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBuffEventNull();
	}
}

void Buff::scheduleBuffEvent() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEBUFFEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->scheduleBuffEvent();
	}
}

void Buff::renew(float newDuration) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RENEW__FLOAT_);
		method.addFloatParameter(newDuration);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->renew(newDuration);
	}
}

void Buff::parseAttributeModifierString(const String& modifierstring) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PARSEATTRIBUTEMODIFIERSTRING__STRING_);
		method.addAsciiParameter(modifierstring);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->parseAttributeModifierString(modifierstring);
	}
}

void Buff::parseSkillModifierString(const String& modifierstring) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PARSESKILLMODIFIERSTRING__STRING_);
		method.addAsciiParameter(modifierstring);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->parseSkillModifierString(modifierstring);
	}
}

String Buff::getAttributeModifierString() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEMODIFIERSTRING__);

		String _return_getAttributeModifierString;
		method.executeWithAsciiReturn(_return_getAttributeModifierString);
		return _return_getAttributeModifierString;
	} else {
		return _implementation->getAttributeModifierString();
	}
}

String Buff::getSkillModifierString() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLMODIFIERSTRING__);

		String _return_getSkillModifierString;
		method.executeWithAsciiReturn(_return_getSkillModifierString);
		return _return_getSkillModifierString;
	} else {
		return _implementation->getSkillModifierString();
	}
}

float Buff::getTimeLeft() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTIMELEFT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getTimeLeft();
	}
}

void Buff::setAttributeModifier(byte attribute, int value) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETATTRIBUTEMODIFIER__BYTE_INT_);
		method.addByteParameter(attribute);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAttributeModifier(attribute, value);
	}
}

void Buff::setSkillModifier(const String& modname, int value) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSKILLMODIFIER__STRING_INT_);
		method.addAsciiParameter(modname);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSkillModifier(modname, value);
	}
}

void Buff::addState(unsigned long long option) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSTATE__LONG_);
		method.addUnsignedLongParameter(option);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addState(option);
	}
}

void Buff::setSpeedMultiplierMod(float multiplier) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDMULTIPLIERMOD__FLOAT_);
		method.addFloatParameter(multiplier);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSpeedMultiplierMod(multiplier);
	}
}

void Buff::setAccelerationMultiplierMod(float multiplier) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_);
		method.addFloatParameter(multiplier);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAccelerationMultiplierMod(multiplier);
	}
}

float Buff::getSpeedMultiplierMod() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPEEDMULTIPLIERMOD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSpeedMultiplierMod();
	}
}

float Buff::getAccelerationMultiplierMod() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCELERATIONMULTIPLIERMOD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAccelerationMultiplierMod();
	}
}

void Buff::setFillAttributesOnBuff(bool val) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFILLATTRIBUTESONBUFF__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setFillAttributesOnBuff(val);
	}
}

String Buff::getBuffName() const {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBUFFNAME__);

		String _return_getBuffName;
		method.executeWithAsciiReturn(_return_getBuffName);
		return _return_getBuffName;
	} else {
		return _implementation->getBuffName();
	}
}

unsigned int Buff::getBuffCRC() const {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBUFFCRC__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getBuffCRC();
	}
}

float Buff::getBuffDuration() const {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBUFFDURATION__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getBuffDuration();
	}
}

int Buff::getBuffType() const {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBUFFTYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBuffType();
	}
}

VectorMap<byte, int>* Buff::getAttributeModifiers() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAttributeModifiers();
	}
}

int Buff::getAttributeModifierValue(byte attribute) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEMODIFIERVALUE__BYTE_);
		method.addByteParameter(attribute);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAttributeModifierValue(attribute);
	}
}

int Buff::getSkillModifierValue(const String& modname) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLMODIFIERVALUE__STRING_);
		method.addAsciiParameter(modname);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSkillModifierValue(modname);
	}
}

bool Buff::isActive() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISACTIVE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isActive();
	}
}

bool Buff::isSpiceBuff() const {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPICEBUFF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSpiceBuff();
	}
}

bool Buff::isAttributeBuff() const {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTRIBUTEBUFF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttributeBuff();
	}
}

void Buff::setStartMessage(StringIdChatParameter& start) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setStartMessage(start);
	}
}

void Buff::setEndMessage(StringIdChatParameter& end) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setEndMessage(end);
	}
}

void Buff::setStartSpam(StringIdChatParameter& start) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setStartSpam(start);
	}
}

void Buff::setEndSpam(StringIdChatParameter& end) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setEndSpam(end);
	}
}

void Buff::setSpamColor(byte color) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPAMCOLOR__BYTE_);
		method.addByteParameter(color);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSpamColor(color);
	}
}

void Buff::setBroadcastSpam(bool value) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBROADCASTSPAM__BOOL_);
		method.addBooleanParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBroadcastSpam(value);
	}
}

void Buff::setStartFlyText(const String& file, const String& aux, byte red, byte green, byte blue) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTARTFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_);
		method.addAsciiParameter(file);
		method.addAsciiParameter(aux);
		method.addByteParameter(red);
		method.addByteParameter(green);
		method.addByteParameter(blue);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setStartFlyText(file, aux, red, green, blue);
	}
}

void Buff::setEndFlyText(const String& file, const String& aux, byte red, byte green, byte blue) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETENDFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_);
		method.addAsciiParameter(file);
		method.addAsciiParameter(aux);
		method.addByteParameter(red);
		method.addByteParameter(green);
		method.addByteParameter(blue);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setEndFlyText(file, aux, red, green, blue);
	}
}

void Buff::addSecondaryBuffCRC(unsigned long long secondaryCRC) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSECONDARYBUFFCRC__LONG_);
		method.addUnsignedLongParameter(secondaryCRC);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addSecondaryBuffCRC(secondaryCRC);
	}
}

Time Buff::getTimeApplied() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTimeApplied();
	}
}

int Buff::compareTo(Buff* obj) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPARETO__BUFF_);
		method.addObjectParameter(obj);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->compareTo(obj);
	}
}

Vector<unsigned long long>* Buff::getSecondaryBuffCRCs() {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSecondaryBuffCRCs();
	}
}

bool Buff::hasMods() const {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASMODS__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasMods();
	}
}

void Buff::setModsApplied(bool applied) {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMODSAPPLIED__BOOL_);
		method.addBooleanParameter(applied);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setModsApplied(applied);
	}
}

bool Buff::removeOnClearBuffs() const {
	BuffImplementation* _implementation = static_cast<BuffImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEONCLEARBUFFS__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->removeOnClearBuffs();
	}
}

DistributedObjectServant* Buff::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* Buff::_getImplementationForRead() const {
	return _impl;
}

void Buff::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	BuffImplementation
 */

BuffImplementation::BuffImplementation(DummyConstructorParameter* param) : ManagedObjectImplementation(param) {
	_initializeImplementation();
}


BuffImplementation::~BuffImplementation() {
}


void BuffImplementation::finalize() {
}

void BuffImplementation::_initializeImplementation() {
	_setClassHelper(BuffHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void BuffImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<Buff*>(stub);
	ManagedObjectImplementation::_setStub(stub);
}

DistributedObjectStub* BuffImplementation::_getStub() {
	return _this.get();
}

BuffImplementation::operator const Buff*() {
	return _this.get();
}

void BuffImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void BuffImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void BuffImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void BuffImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void BuffImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void BuffImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void BuffImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void BuffImplementation::_serializationHelperMethod() {
	ManagedObjectImplementation::_serializationHelperMethod();

	_setClassName("Buff");

}

void BuffImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(BuffImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool BuffImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ManagedObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xa921f788: //Buff.creature
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&creature, stream);
		return true;

	case 0xf0e7f402: //Buff.timeApplied
		TypeInfo<Time >::parseFromBinaryStream(&timeApplied, stream);
		return true;

	case 0x7006427e: //Buff.attributeModifiers
		TypeInfo<VectorMap<byte, int> >::parseFromBinaryStream(&attributeModifiers, stream);
		return true;

	case 0xa139fa26: //Buff.skillModifiers
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&skillModifiers, stream);
		return true;

	case 0x7f68d91a: //Buff.states
		TypeInfo<Vector<unsigned long long> >::parseFromBinaryStream(&states, stream);
		return true;

	case 0x7a50e1dc: //Buff.modsApplied
		TypeInfo<bool >::parseFromBinaryStream(&modsApplied, stream);
		return true;

	case 0x234d15c8: //Buff.buffName
		TypeInfo<String >::parseFromBinaryStream(&buffName, stream);
		return true;

	case 0x3ca26af4: //Buff.buffDuration
		TypeInfo<float >::parseFromBinaryStream(&buffDuration, stream);
		return true;

	case 0xf78c9c7c: //Buff.buffCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&buffCRC, stream);
		return true;

	case 0x8fc21cc4: //Buff.buffType
		TypeInfo<int >::parseFromBinaryStream(&buffType, stream);
		return true;

	case 0x4ac65add: //Buff.fillAttributesOnBuff
		TypeInfo<bool >::parseFromBinaryStream(&fillAttributesOnBuff, stream);
		return true;

	case 0x14f05dca: //Buff.startMessage
		TypeInfo<StringIdChatParameter >::parseFromBinaryStream(&startMessage, stream);
		return true;

	case 0xc3d8eea6: //Buff.endMessage
		TypeInfo<StringIdChatParameter >::parseFromBinaryStream(&endMessage, stream);
		return true;

	case 0xd5f8d81e: //Buff.startSpam
		TypeInfo<StringIdChatParameter >::parseFromBinaryStream(&startSpam, stream);
		return true;

	case 0xb0ad142c: //Buff.endSpam
		TypeInfo<StringIdChatParameter >::parseFromBinaryStream(&endSpam, stream);
		return true;

	case 0x7d3c2a99: //Buff.spamColor
		TypeInfo<byte >::parseFromBinaryStream(&spamColor, stream);
		return true;

	case 0xd837d1a8: //Buff.broadcastSpam
		TypeInfo<bool >::parseFromBinaryStream(&broadcastSpam, stream);
		return true;

	case 0xeca8f5e2: //Buff.startFlyFile
		TypeInfo<String >::parseFromBinaryStream(&startFlyFile, stream);
		return true;

	case 0xf33f1e99: //Buff.startFlyAux
		TypeInfo<String >::parseFromBinaryStream(&startFlyAux, stream);
		return true;

	case 0x8590f867: //Buff.startFlyRed
		TypeInfo<byte >::parseFromBinaryStream(&startFlyRed, stream);
		return true;

	case 0x5115d13e: //Buff.startFlyGreen
		TypeInfo<byte >::parseFromBinaryStream(&startFlyGreen, stream);
		return true;

	case 0xdee7bee1: //Buff.startFlyBlue
		TypeInfo<byte >::parseFromBinaryStream(&startFlyBlue, stream);
		return true;

	case 0x3b80468e: //Buff.endFlyFile
		TypeInfo<String >::parseFromBinaryStream(&endFlyFile, stream);
		return true;

	case 0xa68764ea: //Buff.endFlyAux
		TypeInfo<String >::parseFromBinaryStream(&endFlyAux, stream);
		return true;

	case 0xd0288214: //Buff.endFlyRed
		TypeInfo<byte >::parseFromBinaryStream(&endFlyRed, stream);
		return true;

	case 0x767aa6d2: //Buff.endFlyGreen
		TypeInfo<byte >::parseFromBinaryStream(&endFlyGreen, stream);
		return true;

	case 0x9cf0d8d: //Buff.endFlyBlue
		TypeInfo<byte >::parseFromBinaryStream(&endFlyBlue, stream);
		return true;

	case 0xd9698796: //Buff.nextExecutionTime
		TypeInfo<Time >::parseFromBinaryStream(&nextExecutionTime, stream);
		return true;

	case 0x33526832: //Buff.secondaryBuffCRCs
		TypeInfo<Vector<unsigned long long> >::parseFromBinaryStream(&secondaryBuffCRCs, stream);
		return true;

	}

	return false;
}

void BuffImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = BuffImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int BuffImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ManagedObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xa921f788; //Buff.creature
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&creature, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf0e7f402; //Buff.timeApplied
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&timeApplied, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7006427e; //Buff.attributeModifiers
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<byte, int> >::toBinaryStream(&attributeModifiers, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa139fa26; //Buff.skillModifiers
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&skillModifiers, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7f68d91a; //Buff.states
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&states, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7a50e1dc; //Buff.modsApplied
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&modsApplied, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x234d15c8; //Buff.buffName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&buffName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3ca26af4; //Buff.buffDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&buffDuration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf78c9c7c; //Buff.buffCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&buffCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8fc21cc4; //Buff.buffType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&buffType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4ac65add; //Buff.fillAttributesOnBuff
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&fillAttributesOnBuff, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x14f05dca; //Buff.startMessage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<StringIdChatParameter >::toBinaryStream(&startMessage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc3d8eea6; //Buff.endMessage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<StringIdChatParameter >::toBinaryStream(&endMessage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd5f8d81e; //Buff.startSpam
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<StringIdChatParameter >::toBinaryStream(&startSpam, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb0ad142c; //Buff.endSpam
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<StringIdChatParameter >::toBinaryStream(&endSpam, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7d3c2a99; //Buff.spamColor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&spamColor, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd837d1a8; //Buff.broadcastSpam
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&broadcastSpam, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xeca8f5e2; //Buff.startFlyFile
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&startFlyFile, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf33f1e99; //Buff.startFlyAux
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&startFlyAux, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8590f867; //Buff.startFlyRed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&startFlyRed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5115d13e; //Buff.startFlyGreen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&startFlyGreen, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdee7bee1; //Buff.startFlyBlue
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&startFlyBlue, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3b80468e; //Buff.endFlyFile
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&endFlyFile, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa68764ea; //Buff.endFlyAux
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&endFlyAux, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd0288214; //Buff.endFlyRed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&endFlyRed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x767aa6d2; //Buff.endFlyGreen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&endFlyGreen, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9cf0d8d; //Buff.endFlyBlue
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&endFlyBlue, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd9698796; //Buff.nextExecutionTime
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&nextExecutionTime, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x33526832; //Buff.secondaryBuffCRCs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&secondaryBuffCRCs, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void BuffImplementation::writeJSON(nlohmann::json& j) {
	ManagedObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["creature"] = creature;

	thisObject["timeApplied"] = timeApplied;

	thisObject["attributeModifiers"] = attributeModifiers;

	thisObject["skillModifiers"] = skillModifiers;

	thisObject["states"] = states;

	thisObject["modsApplied"] = modsApplied;

	thisObject["buffName"] = buffName;

	thisObject["buffDuration"] = buffDuration;

	thisObject["buffCRC"] = buffCRC;

	thisObject["buffType"] = buffType;

	thisObject["fillAttributesOnBuff"] = fillAttributesOnBuff;

	thisObject["startMessage"] = startMessage;

	thisObject["endMessage"] = endMessage;

	thisObject["startSpam"] = startSpam;

	thisObject["endSpam"] = endSpam;

	thisObject["spamColor"] = spamColor;

	thisObject["broadcastSpam"] = broadcastSpam;

	thisObject["startFlyFile"] = startFlyFile;

	thisObject["startFlyAux"] = startFlyAux;

	thisObject["startFlyRed"] = startFlyRed;

	thisObject["startFlyGreen"] = startFlyGreen;

	thisObject["startFlyBlue"] = startFlyBlue;

	thisObject["endFlyFile"] = endFlyFile;

	thisObject["endFlyAux"] = endFlyAux;

	thisObject["endFlyRed"] = endFlyRed;

	thisObject["endFlyGreen"] = endFlyGreen;

	thisObject["endFlyBlue"] = endFlyBlue;

	thisObject["nextExecutionTime"] = nextExecutionTime;

	thisObject["secondaryBuffCRCs"] = secondaryBuffCRCs;

	j["Buff"] = thisObject;
}

BuffImplementation::BuffImplementation(CreatureObject* creo, unsigned int buffcrc, float duration, int bufftype, unsigned long long secondaryCRC) {
	_initializeImplementation();
	// server/zone/objects/creature/buffs/Buff.idl():  		creature = creo;
	creature = creo;
	// server/zone/objects/creature/buffs/Buff.idl():  		buffCRC = buffcrc;
	buffCRC = buffcrc;
	// server/zone/objects/creature/buffs/Buff.idl():  		buffDuration = duration;
	buffDuration = duration;
	// server/zone/objects/creature/buffs/Buff.idl():  		buffType = bufftype;
	buffType = bufftype;
	// server/zone/objects/creature/buffs/Buff.idl():  		fillAttributesOnBuff = false;
	fillAttributesOnBuff = false;
	// server/zone/objects/creature/buffs/Buff.idl():  		modsApplied = false;
	modsApplied = false;
	// server/zone/objects/creature/buffs/Buff.idl():  		startFlyFile 
	if (secondaryCRC != 0)	// server/zone/objects/creature/buffs/Buff.idl():  			secondaryBuffCRCs.add(secondaryCRC);
	(&secondaryBuffCRCs)->add(secondaryCRC);
	// server/zone/objects/creature/buffs/Buff.idl():  		startFlyFile = "";
	startFlyFile = "";
	// server/zone/objects/creature/buffs/Buff.idl():  		endFlyFile = "";
	endFlyFile = "";
	// server/zone/objects/creature/buffs/Buff.idl():  		spamColor = 0;
	spamColor = 0;
	// server/zone/objects/creature/buffs/Buff.idl():  		broadcastSpam = false;
	broadcastSpam = false;
	// server/zone/objects/creature/buffs/Buff.idl():  		Logger.setLoggingName("Buff");
	Logger::setLoggingName("Buff");
	// server/zone/objects/creature/buffs/Buff.idl():  		init();
	init();
}

void BuffImplementation::activate() {
	// server/zone/objects/creature/buffs/Buff.idl():  		activate(true);
	activate(true);
}

void BuffImplementation::deactivate() {
	// server/zone/objects/creature/buffs/Buff.idl():  		deactivate(true);
	deactivate(true);
}

bool BuffImplementation::checkRenew() {
	// server/zone/objects/creature/buffs/Buff.idl():  		return false;
	return false;
}

VectorMap<String, int>* BuffImplementation::getSkillModifiers() {
	// server/zone/objects/creature/buffs/Buff.idl():  		return skillModifiers;
	return (&skillModifiers);
}

void BuffImplementation::setAttributeModifier(byte attribute, int value) {
	// server/zone/objects/creature/buffs/Buff.idl():  			attributeModifiers.put(attribute, value);
	if ((&attributeModifiers)->contains(attribute))	// server/zone/objects/creature/buffs/Buff.idl():  			attributeModifiers.get(attribute) = value;
	(&attributeModifiers)->get(attribute) = value;

	else 	// server/zone/objects/creature/buffs/Buff.idl():  			attributeModifiers.put(attribute, value);
	(&attributeModifiers)->put(attribute, value);
}

void BuffImplementation::setSkillModifier(const String& modname, int value) {
	// server/zone/objects/creature/buffs/Buff.idl():  			skillModifiers.put(modname, value);
	if ((&skillModifiers)->contains(modname))	// server/zone/objects/creature/buffs/Buff.idl():  			skillModifiers.get(modname) = value;
	(&skillModifiers)->get(modname) = value;

	else 	// server/zone/objects/creature/buffs/Buff.idl():  			skillModifiers.put(modname, value);
	(&skillModifiers)->put(modname, value);
}

void BuffImplementation::addState(unsigned long long option) {
	// server/zone/objects/creature/buffs/Buff.idl():  		states.add(option);
	(&states)->add(option);
}

void BuffImplementation::setSpeedMultiplierMod(float multiplier) {
	// server/zone/objects/creature/buffs/Buff.idl():  		setSkillModifier("private_speed_multiplier", multiplier * 100);
	setSkillModifier("private_speed_multiplier", multiplier * 100);
}

void BuffImplementation::setAccelerationMultiplierMod(float multiplier) {
	// server/zone/objects/creature/buffs/Buff.idl():  		setSkillModifier("private_acceleration_multiplier", multiplier * 100);
	setSkillModifier("private_acceleration_multiplier", multiplier * 100);
}

float BuffImplementation::getSpeedMultiplierMod() {
	// server/zone/objects/creature/buffs/Buff.idl():  		int speed = getSkillModifierValue("private_speed_multiplier");
	int speed = getSkillModifierValue("private_speed_multiplier");
	// server/zone/objects/creature/buffs/Buff.idl():  		float multiplier = speed / 100.0;
	float multiplier = speed / 100.0;
	// server/zone/objects/creature/buffs/Buff.idl():  		return multiplier;
	return multiplier;
}

float BuffImplementation::getAccelerationMultiplierMod() {
	// server/zone/objects/creature/buffs/Buff.idl():  		int acceleration = getSkillModifierValue("private_acceleration_multiplier");
	int acceleration = getSkillModifierValue("private_acceleration_multiplier");
	// server/zone/objects/creature/buffs/Buff.idl():  		float multiplier = acceleration / 100.0;
	float multiplier = acceleration / 100.0;
	// server/zone/objects/creature/buffs/Buff.idl():  		return multiplier;
	return multiplier;
}

void BuffImplementation::setFillAttributesOnBuff(bool val) {
	// server/zone/objects/creature/buffs/Buff.idl():  		fillAttributesOnBuff = val;
	fillAttributesOnBuff = val;
}

String BuffImplementation::getBuffName() const{
	// server/zone/objects/creature/buffs/Buff.idl():  		return buffName;
	return buffName;
}

unsigned int BuffImplementation::getBuffCRC() const{
	// server/zone/objects/creature/buffs/Buff.idl():  		return buffCRC;
	return buffCRC;
}

float BuffImplementation::getBuffDuration() const{
	// server/zone/objects/creature/buffs/Buff.idl():  		return buffDuration;
	return buffDuration;
}

int BuffImplementation::getBuffType() const{
	// server/zone/objects/creature/buffs/Buff.idl():  		return buffType;
	return buffType;
}

VectorMap<byte, int>* BuffImplementation::getAttributeModifiers() {
	// server/zone/objects/creature/buffs/Buff.idl():  		return attributeModifiers;
	return (&attributeModifiers);
}

int BuffImplementation::getAttributeModifierValue(byte attribute) {
	// server/zone/objects/creature/buffs/Buff.idl():  		return 
	if ((&attributeModifiers)->contains(attribute))	// server/zone/objects/creature/buffs/Buff.idl():  			return attributeModifiers.get(attribute);
	return (&attributeModifiers)->get(attribute);
	// server/zone/objects/creature/buffs/Buff.idl():  		return 0;
	return 0;
}

int BuffImplementation::getSkillModifierValue(const String& modname) {
	// server/zone/objects/creature/buffs/Buff.idl():  		return 
	if ((&skillModifiers)->contains(modname))	// server/zone/objects/creature/buffs/Buff.idl():  			return skillModifiers.get(modname);
	return (&skillModifiers)->get(modname);
	// server/zone/objects/creature/buffs/Buff.idl():  		return 0;
	return 0;
}

bool BuffImplementation::isSpiceBuff() const{
	// server/zone/objects/creature/buffs/Buff.idl():  		return (buffType == BuffType.SPICE);
	return (buffType == BuffType::SPICE);
}

bool BuffImplementation::isAttributeBuff() const{
	// server/zone/objects/creature/buffs/Buff.idl():  		return (attributeModifiers.size() != 0);
	return ((&attributeModifiers)->size() != 0);
}

void BuffImplementation::addSecondaryBuffCRC(unsigned long long secondaryCRC) {
	// server/zone/objects/creature/buffs/Buff.idl():  	}
	if (secondaryCRC != 0 && !(&secondaryBuffCRCs)->contains(secondaryCRC))	// server/zone/objects/creature/buffs/Buff.idl():  			secondaryBuffCRCs.add(secondaryCRC);
	(&secondaryBuffCRCs)->add(secondaryCRC);
}

Vector<unsigned long long>* BuffImplementation::getSecondaryBuffCRCs() {
	// server/zone/objects/creature/buffs/Buff.idl():  		return secondaryBuffCRCs;
	return (&secondaryBuffCRCs);
}

bool BuffImplementation::hasMods() const{
	// server/zone/objects/creature/buffs/Buff.idl():  		return modsApplied;
	return modsApplied;
}

void BuffImplementation::setModsApplied(bool applied) {
	// server/zone/objects/creature/buffs/Buff.idl():  		modsApplied = applied;
	modsApplied = applied;
}

bool BuffImplementation::removeOnClearBuffs() const{
	// server/zone/objects/creature/buffs/Buff.idl():  		return true;
	return true;
}

/*
 *	BuffAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


BuffAdapter::BuffAdapter(Buff* obj) : ManagedObjectAdapter(obj) {
}

void BuffAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_LOADBUFFDURATIONEVENT__CREATUREOBJECT_:
		{
			CreatureObject* creo = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			loadBuffDurationEvent(creo);
			
		}
		break;
	case RPC_INIT__:
		{
			
			init();
			
		}
		break;
	case RPC_SENDTO__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendTo(player);
			
		}
		break;
	case RPC_SENDDESTROYTO__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendDestroyTo(player);
			
		}
		break;
	case RPC_ACTIVATE__BOOL_:
		{
			bool applyModifiers = inv->getBooleanParameter();
			
			activate(applyModifiers);
			
		}
		break;
	case RPC_DEACTIVATE__BOOL_:
		{
			bool removeModifiers = inv->getBooleanParameter();
			
			deactivate(removeModifiers);
			
		}
		break;
	case RPC_ACTIVATE__:
		{
			
			activate();
			
		}
		break;
	case RPC_DEACTIVATE__:
		{
			
			deactivate();
			
		}
		break;
	case RPC_CHECKRENEW__:
		{
			
			bool _m_res = checkRenew();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_APPLYATTRIBUTEMODIFIERS__:
		{
			
			applyAttributeModifiers();
			
		}
		break;
	case RPC_APPLYSKILLMODIFIERS__:
		{
			
			applySkillModifiers();
			
		}
		break;
	case RPC_APPLYSTATES__:
		{
			
			applyStates();
			
		}
		break;
	case RPC_APPLYALLMODIFIERS__:
		{
			
			applyAllModifiers();
			
		}
		break;
	case RPC_REMOVEATTRIBUTEMODIFIERS__:
		{
			
			removeAttributeModifiers();
			
		}
		break;
	case RPC_REMOVESKILLMODIFIERS__:
		{
			
			removeSkillModifiers();
			
		}
		break;
	case RPC_REMOVESTATES__:
		{
			
			removeStates();
			
		}
		break;
	case RPC_REMOVEALLMODIFIERS__:
		{
			
			removeAllModifiers();
			
		}
		break;
	case RPC_CLEARBUFFEVENT__:
		{
			
			clearBuffEvent();
			
		}
		break;
	case RPC_SETBUFFEVENTNULL__:
		{
			
			setBuffEventNull();
			
		}
		break;
	case RPC_SCHEDULEBUFFEVENT__:
		{
			
			scheduleBuffEvent();
			
		}
		break;
	case RPC_RENEW__FLOAT_:
		{
			float newDuration = inv->getFloatParameter();
			
			renew(newDuration);
			
		}
		break;
	case RPC_PARSEATTRIBUTEMODIFIERSTRING__STRING_:
		{
			 String modifierstring; inv->getAsciiParameter(modifierstring);
			
			parseAttributeModifierString(modifierstring);
			
		}
		break;
	case RPC_PARSESKILLMODIFIERSTRING__STRING_:
		{
			 String modifierstring; inv->getAsciiParameter(modifierstring);
			
			parseSkillModifierString(modifierstring);
			
		}
		break;
	case RPC_GETATTRIBUTEMODIFIERSTRING__:
		{
			
			String _m_res = getAttributeModifierString();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETSKILLMODIFIERSTRING__:
		{
			
			String _m_res = getSkillModifierString();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETTIMELEFT__:
		{
			
			float _m_res = getTimeLeft();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETATTRIBUTEMODIFIER__BYTE_INT_:
		{
			byte attribute = inv->getByteParameter();
			int value = inv->getSignedIntParameter();
			
			setAttributeModifier(attribute, value);
			
		}
		break;
	case RPC_SETSKILLMODIFIER__STRING_INT_:
		{
			 String modname; inv->getAsciiParameter(modname);
			int value = inv->getSignedIntParameter();
			
			setSkillModifier(modname, value);
			
		}
		break;
	case RPC_ADDSTATE__LONG_:
		{
			unsigned long long option = inv->getUnsignedLongParameter();
			
			addState(option);
			
		}
		break;
	case RPC_SETSPEEDMULTIPLIERMOD__FLOAT_:
		{
			float multiplier = inv->getFloatParameter();
			
			setSpeedMultiplierMod(multiplier);
			
		}
		break;
	case RPC_SETACCELERATIONMULTIPLIERMOD__FLOAT_:
		{
			float multiplier = inv->getFloatParameter();
			
			setAccelerationMultiplierMod(multiplier);
			
		}
		break;
	case RPC_GETSPEEDMULTIPLIERMOD__:
		{
			
			float _m_res = getSpeedMultiplierMod();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETACCELERATIONMULTIPLIERMOD__:
		{
			
			float _m_res = getAccelerationMultiplierMod();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETFILLATTRIBUTESONBUFF__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setFillAttributesOnBuff(val);
			
		}
		break;
	case RPC_GETBUFFNAME__:
		{
			
			String _m_res = getBuffName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETBUFFCRC__:
		{
			
			unsigned int _m_res = getBuffCRC();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETBUFFDURATION__:
		{
			
			float _m_res = getBuffDuration();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBUFFTYPE__:
		{
			
			int _m_res = getBuffType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETATTRIBUTEMODIFIERVALUE__BYTE_:
		{
			byte attribute = inv->getByteParameter();
			
			int _m_res = getAttributeModifierValue(attribute);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSKILLMODIFIERVALUE__STRING_:
		{
			 String modname; inv->getAsciiParameter(modname);
			
			int _m_res = getSkillModifierValue(modname);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISACTIVE__:
		{
			
			bool _m_res = isActive();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSPICEBUFF__:
		{
			
			bool _m_res = isSpiceBuff();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISATTRIBUTEBUFF__:
		{
			
			bool _m_res = isAttributeBuff();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETSPAMCOLOR__BYTE_:
		{
			byte color = inv->getByteParameter();
			
			setSpamColor(color);
			
		}
		break;
	case RPC_SETBROADCASTSPAM__BOOL_:
		{
			bool value = inv->getBooleanParameter();
			
			setBroadcastSpam(value);
			
		}
		break;
	case RPC_SETSTARTFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_:
		{
			 String file; inv->getAsciiParameter(file);
			 String aux; inv->getAsciiParameter(aux);
			byte red = inv->getByteParameter();
			byte green = inv->getByteParameter();
			byte blue = inv->getByteParameter();
			
			setStartFlyText(file, aux, red, green, blue);
			
		}
		break;
	case RPC_SETENDFLYTEXT__STRING_STRING_BYTE_BYTE_BYTE_:
		{
			 String file; inv->getAsciiParameter(file);
			 String aux; inv->getAsciiParameter(aux);
			byte red = inv->getByteParameter();
			byte green = inv->getByteParameter();
			byte blue = inv->getByteParameter();
			
			setEndFlyText(file, aux, red, green, blue);
			
		}
		break;
	case RPC_ADDSECONDARYBUFFCRC__LONG_:
		{
			unsigned long long secondaryCRC = inv->getUnsignedLongParameter();
			
			addSecondaryBuffCRC(secondaryCRC);
			
		}
		break;
	case RPC_COMPARETO__BUFF_:
		{
			Buff* obj = static_cast<Buff*>(inv->getObjectParameter());
			
			int _m_res = compareTo(obj);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASMODS__:
		{
			
			bool _m_res = hasMods();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETMODSAPPLIED__BOOL_:
		{
			bool applied = inv->getBooleanParameter();
			
			setModsApplied(applied);
			
		}
		break;
	case RPC_REMOVEONCLEARBUFFS__:
		{
			
			bool _m_res = removeOnClearBuffs();
			resp->insertBoolean(_m_res);
		}
		break;
	default:
		ManagedObjectAdapter::invokeMethod(methid, inv);
	}
}

void BuffAdapter::initializeTransientMembers() {
	(static_cast<Buff*>(stub))->initializeTransientMembers();
}

void BuffAdapter::notifyLoadFromDatabase() {
	(static_cast<Buff*>(stub))->notifyLoadFromDatabase();
}

void BuffAdapter::loadBuffDurationEvent(CreatureObject* creo) {
	(static_cast<Buff*>(stub))->loadBuffDurationEvent(creo);
}

void BuffAdapter::init() {
	(static_cast<Buff*>(stub))->init();
}

void BuffAdapter::sendTo(CreatureObject* player) {
	(static_cast<Buff*>(stub))->sendTo(player);
}

void BuffAdapter::sendDestroyTo(CreatureObject* player) {
	(static_cast<Buff*>(stub))->sendDestroyTo(player);
}

void BuffAdapter::activate(bool applyModifiers) {
	(static_cast<Buff*>(stub))->activate(applyModifiers);
}

void BuffAdapter::deactivate(bool removeModifiers) {
	(static_cast<Buff*>(stub))->deactivate(removeModifiers);
}

void BuffAdapter::activate() {
	(static_cast<Buff*>(stub))->activate();
}

void BuffAdapter::deactivate() {
	(static_cast<Buff*>(stub))->deactivate();
}

bool BuffAdapter::checkRenew() {
	return (static_cast<Buff*>(stub))->checkRenew();
}

void BuffAdapter::applyAttributeModifiers() {
	(static_cast<Buff*>(stub))->applyAttributeModifiers();
}

void BuffAdapter::applySkillModifiers() {
	(static_cast<Buff*>(stub))->applySkillModifiers();
}

void BuffAdapter::applyStates() {
	(static_cast<Buff*>(stub))->applyStates();
}

void BuffAdapter::applyAllModifiers() {
	(static_cast<Buff*>(stub))->applyAllModifiers();
}

void BuffAdapter::removeAttributeModifiers() {
	(static_cast<Buff*>(stub))->removeAttributeModifiers();
}

void BuffAdapter::removeSkillModifiers() {
	(static_cast<Buff*>(stub))->removeSkillModifiers();
}

void BuffAdapter::removeStates() {
	(static_cast<Buff*>(stub))->removeStates();
}

void BuffAdapter::removeAllModifiers() {
	(static_cast<Buff*>(stub))->removeAllModifiers();
}

void BuffAdapter::clearBuffEvent() {
	(static_cast<Buff*>(stub))->clearBuffEvent();
}

void BuffAdapter::setBuffEventNull() {
	(static_cast<Buff*>(stub))->setBuffEventNull();
}

void BuffAdapter::scheduleBuffEvent() {
	(static_cast<Buff*>(stub))->scheduleBuffEvent();
}

void BuffAdapter::renew(float newDuration) {
	(static_cast<Buff*>(stub))->renew(newDuration);
}

void BuffAdapter::parseAttributeModifierString(const String& modifierstring) {
	(static_cast<Buff*>(stub))->parseAttributeModifierString(modifierstring);
}

void BuffAdapter::parseSkillModifierString(const String& modifierstring) {
	(static_cast<Buff*>(stub))->parseSkillModifierString(modifierstring);
}

String BuffAdapter::getAttributeModifierString() {
	return (static_cast<Buff*>(stub))->getAttributeModifierString();
}

String BuffAdapter::getSkillModifierString() {
	return (static_cast<Buff*>(stub))->getSkillModifierString();
}

float BuffAdapter::getTimeLeft() {
	return (static_cast<Buff*>(stub))->getTimeLeft();
}

void BuffAdapter::setAttributeModifier(byte attribute, int value) {
	(static_cast<Buff*>(stub))->setAttributeModifier(attribute, value);
}

void BuffAdapter::setSkillModifier(const String& modname, int value) {
	(static_cast<Buff*>(stub))->setSkillModifier(modname, value);
}

void BuffAdapter::addState(unsigned long long option) {
	(static_cast<Buff*>(stub))->addState(option);
}

void BuffAdapter::setSpeedMultiplierMod(float multiplier) {
	(static_cast<Buff*>(stub))->setSpeedMultiplierMod(multiplier);
}

void BuffAdapter::setAccelerationMultiplierMod(float multiplier) {
	(static_cast<Buff*>(stub))->setAccelerationMultiplierMod(multiplier);
}

float BuffAdapter::getSpeedMultiplierMod() {
	return (static_cast<Buff*>(stub))->getSpeedMultiplierMod();
}

float BuffAdapter::getAccelerationMultiplierMod() {
	return (static_cast<Buff*>(stub))->getAccelerationMultiplierMod();
}

void BuffAdapter::setFillAttributesOnBuff(bool val) {
	(static_cast<Buff*>(stub))->setFillAttributesOnBuff(val);
}

String BuffAdapter::getBuffName() const {
	return (static_cast<Buff*>(stub))->getBuffName();
}

unsigned int BuffAdapter::getBuffCRC() const {
	return (static_cast<Buff*>(stub))->getBuffCRC();
}

float BuffAdapter::getBuffDuration() const {
	return (static_cast<Buff*>(stub))->getBuffDuration();
}

int BuffAdapter::getBuffType() const {
	return (static_cast<Buff*>(stub))->getBuffType();
}

int BuffAdapter::getAttributeModifierValue(byte attribute) {
	return (static_cast<Buff*>(stub))->getAttributeModifierValue(attribute);
}

int BuffAdapter::getSkillModifierValue(const String& modname) {
	return (static_cast<Buff*>(stub))->getSkillModifierValue(modname);
}

bool BuffAdapter::isActive() {
	return (static_cast<Buff*>(stub))->isActive();
}

bool BuffAdapter::isSpiceBuff() const {
	return (static_cast<Buff*>(stub))->isSpiceBuff();
}

bool BuffAdapter::isAttributeBuff() const {
	return (static_cast<Buff*>(stub))->isAttributeBuff();
}

void BuffAdapter::setSpamColor(byte color) {
	(static_cast<Buff*>(stub))->setSpamColor(color);
}

void BuffAdapter::setBroadcastSpam(bool value) {
	(static_cast<Buff*>(stub))->setBroadcastSpam(value);
}

void BuffAdapter::setStartFlyText(const String& file, const String& aux, byte red, byte green, byte blue) {
	(static_cast<Buff*>(stub))->setStartFlyText(file, aux, red, green, blue);
}

void BuffAdapter::setEndFlyText(const String& file, const String& aux, byte red, byte green, byte blue) {
	(static_cast<Buff*>(stub))->setEndFlyText(file, aux, red, green, blue);
}

void BuffAdapter::addSecondaryBuffCRC(unsigned long long secondaryCRC) {
	(static_cast<Buff*>(stub))->addSecondaryBuffCRC(secondaryCRC);
}

int BuffAdapter::compareTo(Buff* obj) {
	return (static_cast<Buff*>(stub))->compareTo(obj);
}

bool BuffAdapter::hasMods() const {
	return (static_cast<Buff*>(stub))->hasMods();
}

void BuffAdapter::setModsApplied(bool applied) {
	(static_cast<Buff*>(stub))->setModsApplied(applied);
}

bool BuffAdapter::removeOnClearBuffs() const {
	return (static_cast<Buff*>(stub))->removeOnClearBuffs();
}

/*
 *	BuffHelper
 */

BuffHelper* BuffHelper::staticInitializer = BuffHelper::instance();

BuffHelper::BuffHelper() {
	className = "Buff";

	Core::getObjectBroker()->registerClass(className, this);
}

void BuffHelper::finalizeHelper() {
	BuffHelper::finalize();
}

DistributedObject* BuffHelper::instantiateObject() {
	return new Buff(DummyConstructorParameter::instance());
}

DistributedObjectServant* BuffHelper::instantiateServant() {
	return new BuffImplementation(DummyConstructorParameter::instance());
}

DistributedObjectPOD* BuffHelper::instantiatePOD() {
	return new BuffPOD();
}

DistributedObjectAdapter* BuffHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new BuffAdapter(static_cast<Buff*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	BuffPOD
 */

BuffPOD::~BuffPOD() {
}

BuffPOD::BuffPOD(void) {
	_className = "Buff";
}


void BuffPOD::writeJSON(nlohmann::json& j) {
	ManagedObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (creature)
		thisObject["creature"] = creature.value();

	if (timeApplied)
		thisObject["timeApplied"] = timeApplied.value();

	if (attributeModifiers)
		thisObject["attributeModifiers"] = attributeModifiers.value();

	if (skillModifiers)
		thisObject["skillModifiers"] = skillModifiers.value();

	if (states)
		thisObject["states"] = states.value();

	if (modsApplied)
		thisObject["modsApplied"] = modsApplied.value();

	if (buffName)
		thisObject["buffName"] = buffName.value();

	if (buffDuration)
		thisObject["buffDuration"] = buffDuration.value();

	if (buffCRC)
		thisObject["buffCRC"] = buffCRC.value();

	if (buffType)
		thisObject["buffType"] = buffType.value();

	if (fillAttributesOnBuff)
		thisObject["fillAttributesOnBuff"] = fillAttributesOnBuff.value();

	if (startMessage)
		thisObject["startMessage"] = startMessage.value();

	if (endMessage)
		thisObject["endMessage"] = endMessage.value();

	if (startSpam)
		thisObject["startSpam"] = startSpam.value();

	if (endSpam)
		thisObject["endSpam"] = endSpam.value();

	if (spamColor)
		thisObject["spamColor"] = spamColor.value();

	if (broadcastSpam)
		thisObject["broadcastSpam"] = broadcastSpam.value();

	if (startFlyFile)
		thisObject["startFlyFile"] = startFlyFile.value();

	if (startFlyAux)
		thisObject["startFlyAux"] = startFlyAux.value();

	if (startFlyRed)
		thisObject["startFlyRed"] = startFlyRed.value();

	if (startFlyGreen)
		thisObject["startFlyGreen"] = startFlyGreen.value();

	if (startFlyBlue)
		thisObject["startFlyBlue"] = startFlyBlue.value();

	if (endFlyFile)
		thisObject["endFlyFile"] = endFlyFile.value();

	if (endFlyAux)
		thisObject["endFlyAux"] = endFlyAux.value();

	if (endFlyRed)
		thisObject["endFlyRed"] = endFlyRed.value();

	if (endFlyGreen)
		thisObject["endFlyGreen"] = endFlyGreen.value();

	if (endFlyBlue)
		thisObject["endFlyBlue"] = endFlyBlue.value();

	if (nextExecutionTime)
		thisObject["nextExecutionTime"] = nextExecutionTime.value();

	if (secondaryBuffCRCs)
		thisObject["secondaryBuffCRCs"] = secondaryBuffCRCs.value();

	j["Buff"] = thisObject;
}


void BuffPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = BuffPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int BuffPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ManagedObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (creature) {
	_nameHashCode = 0xa921f788; //Buff.creature
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::toBinaryStream(&creature.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (timeApplied) {
	_nameHashCode = 0xf0e7f402; //Buff.timeApplied
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&timeApplied.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (attributeModifiers) {
	_nameHashCode = 0x7006427e; //Buff.attributeModifiers
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<byte, int> >::toBinaryStream(&attributeModifiers.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (skillModifiers) {
	_nameHashCode = 0xa139fa26; //Buff.skillModifiers
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&skillModifiers.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (states) {
	_nameHashCode = 0x7f68d91a; //Buff.states
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&states.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (modsApplied) {
	_nameHashCode = 0x7a50e1dc; //Buff.modsApplied
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&modsApplied.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (buffName) {
	_nameHashCode = 0x234d15c8; //Buff.buffName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&buffName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (buffDuration) {
	_nameHashCode = 0x3ca26af4; //Buff.buffDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&buffDuration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (buffCRC) {
	_nameHashCode = 0xf78c9c7c; //Buff.buffCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&buffCRC.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (buffType) {
	_nameHashCode = 0x8fc21cc4; //Buff.buffType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&buffType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (fillAttributesOnBuff) {
	_nameHashCode = 0x4ac65add; //Buff.fillAttributesOnBuff
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&fillAttributesOnBuff.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (startMessage) {
	_nameHashCode = 0x14f05dca; //Buff.startMessage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<StringIdChatParameter >::toBinaryStream(&startMessage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (endMessage) {
	_nameHashCode = 0xc3d8eea6; //Buff.endMessage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<StringIdChatParameter >::toBinaryStream(&endMessage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (startSpam) {
	_nameHashCode = 0xd5f8d81e; //Buff.startSpam
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<StringIdChatParameter >::toBinaryStream(&startSpam.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (endSpam) {
	_nameHashCode = 0xb0ad142c; //Buff.endSpam
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<StringIdChatParameter >::toBinaryStream(&endSpam.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spamColor) {
	_nameHashCode = 0x7d3c2a99; //Buff.spamColor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&spamColor.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (broadcastSpam) {
	_nameHashCode = 0xd837d1a8; //Buff.broadcastSpam
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&broadcastSpam.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (startFlyFile) {
	_nameHashCode = 0xeca8f5e2; //Buff.startFlyFile
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&startFlyFile.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (startFlyAux) {
	_nameHashCode = 0xf33f1e99; //Buff.startFlyAux
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&startFlyAux.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (startFlyRed) {
	_nameHashCode = 0x8590f867; //Buff.startFlyRed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&startFlyRed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (startFlyGreen) {
	_nameHashCode = 0x5115d13e; //Buff.startFlyGreen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&startFlyGreen.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (startFlyBlue) {
	_nameHashCode = 0xdee7bee1; //Buff.startFlyBlue
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&startFlyBlue.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (endFlyFile) {
	_nameHashCode = 0x3b80468e; //Buff.endFlyFile
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&endFlyFile.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (endFlyAux) {
	_nameHashCode = 0xa68764ea; //Buff.endFlyAux
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&endFlyAux.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (endFlyRed) {
	_nameHashCode = 0xd0288214; //Buff.endFlyRed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&endFlyRed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (endFlyGreen) {
	_nameHashCode = 0x767aa6d2; //Buff.endFlyGreen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&endFlyGreen.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (endFlyBlue) {
	_nameHashCode = 0x9cf0d8d; //Buff.endFlyBlue
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&endFlyBlue.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (nextExecutionTime) {
	_nameHashCode = 0xd9698796; //Buff.nextExecutionTime
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&nextExecutionTime.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (secondaryBuffCRCs) {
	_nameHashCode = 0x33526832; //Buff.secondaryBuffCRCs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&secondaryBuffCRCs.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool BuffPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ManagedObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xa921f788: //Buff.creature
		{
			ManagedWeakReference<CreatureObjectPOD* > _mncreature;
			TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::parseFromBinaryStream(&_mncreature, stream);
			creature = std::move(_mncreature);
		}
		return true;

	case 0xf0e7f402: //Buff.timeApplied
		{
			Time _mntimeApplied;
			TypeInfo<Time >::parseFromBinaryStream(&_mntimeApplied, stream);
			timeApplied = std::move(_mntimeApplied);
		}
		return true;

	case 0x7006427e: //Buff.attributeModifiers
		{
			VectorMap<byte, int> _mnattributeModifiers;
			TypeInfo<VectorMap<byte, int> >::parseFromBinaryStream(&_mnattributeModifiers, stream);
			attributeModifiers = std::move(_mnattributeModifiers);
		}
		return true;

	case 0xa139fa26: //Buff.skillModifiers
		{
			VectorMap<String, int> _mnskillModifiers;
			TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&_mnskillModifiers, stream);
			skillModifiers = std::move(_mnskillModifiers);
		}
		return true;

	case 0x7f68d91a: //Buff.states
		{
			Vector<unsigned long long> _mnstates;
			TypeInfo<Vector<unsigned long long> >::parseFromBinaryStream(&_mnstates, stream);
			states = std::move(_mnstates);
		}
		return true;

	case 0x7a50e1dc: //Buff.modsApplied
		{
			bool _mnmodsApplied;
			TypeInfo<bool >::parseFromBinaryStream(&_mnmodsApplied, stream);
			modsApplied = std::move(_mnmodsApplied);
		}
		return true;

	case 0x234d15c8: //Buff.buffName
		{
			String _mnbuffName;
			TypeInfo<String >::parseFromBinaryStream(&_mnbuffName, stream);
			buffName = std::move(_mnbuffName);
		}
		return true;

	case 0x3ca26af4: //Buff.buffDuration
		{
			float _mnbuffDuration;
			TypeInfo<float >::parseFromBinaryStream(&_mnbuffDuration, stream);
			buffDuration = std::move(_mnbuffDuration);
		}
		return true;

	case 0xf78c9c7c: //Buff.buffCRC
		{
			unsigned int _mnbuffCRC;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnbuffCRC, stream);
			buffCRC = std::move(_mnbuffCRC);
		}
		return true;

	case 0x8fc21cc4: //Buff.buffType
		{
			int _mnbuffType;
			TypeInfo<int >::parseFromBinaryStream(&_mnbuffType, stream);
			buffType = std::move(_mnbuffType);
		}
		return true;

	case 0x4ac65add: //Buff.fillAttributesOnBuff
		{
			bool _mnfillAttributesOnBuff;
			TypeInfo<bool >::parseFromBinaryStream(&_mnfillAttributesOnBuff, stream);
			fillAttributesOnBuff = std::move(_mnfillAttributesOnBuff);
		}
		return true;

	case 0x14f05dca: //Buff.startMessage
		{
			StringIdChatParameter _mnstartMessage;
			TypeInfo<StringIdChatParameter >::parseFromBinaryStream(&_mnstartMessage, stream);
			startMessage = std::move(_mnstartMessage);
		}
		return true;

	case 0xc3d8eea6: //Buff.endMessage
		{
			StringIdChatParameter _mnendMessage;
			TypeInfo<StringIdChatParameter >::parseFromBinaryStream(&_mnendMessage, stream);
			endMessage = std::move(_mnendMessage);
		}
		return true;

	case 0xd5f8d81e: //Buff.startSpam
		{
			StringIdChatParameter _mnstartSpam;
			TypeInfo<StringIdChatParameter >::parseFromBinaryStream(&_mnstartSpam, stream);
			startSpam = std::move(_mnstartSpam);
		}
		return true;

	case 0xb0ad142c: //Buff.endSpam
		{
			StringIdChatParameter _mnendSpam;
			TypeInfo<StringIdChatParameter >::parseFromBinaryStream(&_mnendSpam, stream);
			endSpam = std::move(_mnendSpam);
		}
		return true;

	case 0x7d3c2a99: //Buff.spamColor
		{
			byte _mnspamColor;
			TypeInfo<byte >::parseFromBinaryStream(&_mnspamColor, stream);
			spamColor = std::move(_mnspamColor);
		}
		return true;

	case 0xd837d1a8: //Buff.broadcastSpam
		{
			bool _mnbroadcastSpam;
			TypeInfo<bool >::parseFromBinaryStream(&_mnbroadcastSpam, stream);
			broadcastSpam = std::move(_mnbroadcastSpam);
		}
		return true;

	case 0xeca8f5e2: //Buff.startFlyFile
		{
			String _mnstartFlyFile;
			TypeInfo<String >::parseFromBinaryStream(&_mnstartFlyFile, stream);
			startFlyFile = std::move(_mnstartFlyFile);
		}
		return true;

	case 0xf33f1e99: //Buff.startFlyAux
		{
			String _mnstartFlyAux;
			TypeInfo<String >::parseFromBinaryStream(&_mnstartFlyAux, stream);
			startFlyAux = std::move(_mnstartFlyAux);
		}
		return true;

	case 0x8590f867: //Buff.startFlyRed
		{
			byte _mnstartFlyRed;
			TypeInfo<byte >::parseFromBinaryStream(&_mnstartFlyRed, stream);
			startFlyRed = std::move(_mnstartFlyRed);
		}
		return true;

	case 0x5115d13e: //Buff.startFlyGreen
		{
			byte _mnstartFlyGreen;
			TypeInfo<byte >::parseFromBinaryStream(&_mnstartFlyGreen, stream);
			startFlyGreen = std::move(_mnstartFlyGreen);
		}
		return true;

	case 0xdee7bee1: //Buff.startFlyBlue
		{
			byte _mnstartFlyBlue;
			TypeInfo<byte >::parseFromBinaryStream(&_mnstartFlyBlue, stream);
			startFlyBlue = std::move(_mnstartFlyBlue);
		}
		return true;

	case 0x3b80468e: //Buff.endFlyFile
		{
			String _mnendFlyFile;
			TypeInfo<String >::parseFromBinaryStream(&_mnendFlyFile, stream);
			endFlyFile = std::move(_mnendFlyFile);
		}
		return true;

	case 0xa68764ea: //Buff.endFlyAux
		{
			String _mnendFlyAux;
			TypeInfo<String >::parseFromBinaryStream(&_mnendFlyAux, stream);
			endFlyAux = std::move(_mnendFlyAux);
		}
		return true;

	case 0xd0288214: //Buff.endFlyRed
		{
			byte _mnendFlyRed;
			TypeInfo<byte >::parseFromBinaryStream(&_mnendFlyRed, stream);
			endFlyRed = std::move(_mnendFlyRed);
		}
		return true;

	case 0x767aa6d2: //Buff.endFlyGreen
		{
			byte _mnendFlyGreen;
			TypeInfo<byte >::parseFromBinaryStream(&_mnendFlyGreen, stream);
			endFlyGreen = std::move(_mnendFlyGreen);
		}
		return true;

	case 0x9cf0d8d: //Buff.endFlyBlue
		{
			byte _mnendFlyBlue;
			TypeInfo<byte >::parseFromBinaryStream(&_mnendFlyBlue, stream);
			endFlyBlue = std::move(_mnendFlyBlue);
		}
		return true;

	case 0xd9698796: //Buff.nextExecutionTime
		{
			Time _mnnextExecutionTime;
			TypeInfo<Time >::parseFromBinaryStream(&_mnnextExecutionTime, stream);
			nextExecutionTime = std::move(_mnnextExecutionTime);
		}
		return true;

	case 0x33526832: //Buff.secondaryBuffCRCs
		{
			Vector<unsigned long long> _mnsecondaryBuffCRCs;
			TypeInfo<Vector<unsigned long long> >::parseFromBinaryStream(&_mnsecondaryBuffCRCs, stream);
			secondaryBuffCRCs = std::move(_mnsecondaryBuffCRCs);
		}
		return true;

	}

	return false;
}

void BuffPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(BuffPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void BuffPOD::writeObjectCompact(ObjectOutputStream* stream) {
	ManagedObjectPOD::writeObjectCompact(stream);

	TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::toBinaryStream(&creature.value(), stream);

	TypeInfo<Time >::toBinaryStream(&timeApplied.value(), stream);

	TypeInfo<VectorMap<byte, int> >::toBinaryStream(&attributeModifiers.value(), stream);

	TypeInfo<VectorMap<String, int> >::toBinaryStream(&skillModifiers.value(), stream);

	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&states.value(), stream);

	TypeInfo<bool >::toBinaryStream(&modsApplied.value(), stream);

	TypeInfo<String >::toBinaryStream(&buffName.value(), stream);

	TypeInfo<float >::toBinaryStream(&buffDuration.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&buffCRC.value(), stream);

	TypeInfo<int >::toBinaryStream(&buffType.value(), stream);

	TypeInfo<bool >::toBinaryStream(&fillAttributesOnBuff.value(), stream);

	TypeInfo<StringIdChatParameter >::toBinaryStream(&startMessage.value(), stream);

	TypeInfo<StringIdChatParameter >::toBinaryStream(&endMessage.value(), stream);

	TypeInfo<StringIdChatParameter >::toBinaryStream(&startSpam.value(), stream);

	TypeInfo<StringIdChatParameter >::toBinaryStream(&endSpam.value(), stream);

	TypeInfo<byte >::toBinaryStream(&spamColor.value(), stream);

	TypeInfo<bool >::toBinaryStream(&broadcastSpam.value(), stream);

	TypeInfo<String >::toBinaryStream(&startFlyFile.value(), stream);

	TypeInfo<String >::toBinaryStream(&startFlyAux.value(), stream);

	TypeInfo<byte >::toBinaryStream(&startFlyRed.value(), stream);

	TypeInfo<byte >::toBinaryStream(&startFlyGreen.value(), stream);

	TypeInfo<byte >::toBinaryStream(&startFlyBlue.value(), stream);

	TypeInfo<String >::toBinaryStream(&endFlyFile.value(), stream);

	TypeInfo<String >::toBinaryStream(&endFlyAux.value(), stream);

	TypeInfo<byte >::toBinaryStream(&endFlyRed.value(), stream);

	TypeInfo<byte >::toBinaryStream(&endFlyGreen.value(), stream);

	TypeInfo<byte >::toBinaryStream(&endFlyBlue.value(), stream);

	TypeInfo<Time >::toBinaryStream(&nextExecutionTime.value(), stream);

	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&secondaryBuffCRCs.value(), stream);


}

