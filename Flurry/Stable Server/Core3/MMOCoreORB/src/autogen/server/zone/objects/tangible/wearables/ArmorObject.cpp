/*
 *	autogen/server/zone/objects/tangible/wearables/ArmorObject.cpp generated by engine3 IDL compiler 0.70
 */

#include "ArmorObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

/*
 *	ArmorObjectStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 4036877556,RPC_NOTIFYLOADFROMDATABASE__,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_ISSPECIAL__INT_,RPC_ISVULNERABLE__INT_,RPC_ISARMOROBJECT__,RPC_SETRATING__INT_,RPC_GETRATING__,RPC_SETKINETIC__FLOAT_,RPC_SETENERGY__FLOAT_,RPC_SETELECTRICITY__FLOAT_,RPC_SETSTUN__FLOAT_,RPC_SETBLAST__FLOAT_,RPC_SETHEAT__FLOAT_,RPC_SETCOLD__FLOAT_,RPC_SETACID__FLOAT_,RPC_SETLIGHTSABER__FLOAT_,RPC_GETHEALTHENCUMBRANCE__,RPC_SETHEALTHENCUMBRANCE__INT_,RPC_GETACTIONENCUMBRANCE__,RPC_SETACTIONENCUMBRANCE__INT_,RPC_GETMINDENCUMBRANCE__,RPC_SETMINDENCUMBRANCE__INT_,RPC_SETEFFECTIVENESSSLICE__FLOAT_,RPC_SETENCUMBRANCESLICE__FLOAT_,RPC_GETHITLOCATION__,RPC_SETHITLOCATION__BYTE_,RPC_GETRESIST__INT_};

ArmorObject::ArmorObject() : WearableObject(DummyConstructorParameter::instance()) {
	ArmorObjectImplementation* _implementation = new ArmorObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("ArmorObject");
}

ArmorObject::ArmorObject(DummyConstructorParameter* param) : WearableObject(param) {
	_setClassName("ArmorObject");
}

ArmorObject::~ArmorObject() {
}



void ArmorObject::initializeTransientMembers() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void ArmorObject::notifyLoadFromDatabase() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

void ArmorObject::loadTemplateData(SharedObjectTemplate* templateData) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void ArmorObject::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

int ArmorObject::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

void ArmorObject::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updateCraftingValues(values, firstUpdate);
	}
}

bool ArmorObject::isSpecial(int type) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPECIAL__INT_);
		method.addSignedIntParameter(type);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSpecial(type);
	}
}

bool ArmorObject::isVulnerable(int type) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISVULNERABLE__INT_);
		method.addSignedIntParameter(type);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isVulnerable(type);
	}
}

bool ArmorObject::isArmorObject() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISARMOROBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isArmorObject();
	}
}

void ArmorObject::setRating(int rate) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRATING__INT_);
		method.addSignedIntParameter(rate);

		method.executeWithVoidReturn();
	} else {
		_implementation->setRating(rate);
	}
}

int ArmorObject::getRating() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRATING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getRating();
	}
}

float ArmorObject::getKinetic() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getKinetic();
	}
}

void ArmorObject::setKinetic(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETKINETIC__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setKinetic(value);
	}
}

float ArmorObject::getEnergy() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getEnergy();
	}
}

void ArmorObject::setEnergy(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETENERGY__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setEnergy(value);
	}
}

float ArmorObject::getElectricity() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getElectricity();
	}
}

void ArmorObject::setElectricity(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETELECTRICITY__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setElectricity(value);
	}
}

float ArmorObject::getStun() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getStun();
	}
}

void ArmorObject::setStun(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTUN__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setStun(value);
	}
}

float ArmorObject::getBlast() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getBlast();
	}
}

void ArmorObject::setBlast(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBLAST__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBlast(value);
	}
}

float ArmorObject::getHeat() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHeat();
	}
}

void ArmorObject::setHeat(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHEAT__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setHeat(value);
	}
}

float ArmorObject::getCold() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCold();
	}
}

void ArmorObject::setCold(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOLD__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCold(value);
	}
}

float ArmorObject::getAcid() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAcid();
	}
}

void ArmorObject::setAcid(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACID__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAcid(value);
	}
}

float ArmorObject::getLightSaber() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLightSaber();
	}
}

void ArmorObject::setLightSaber(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLIGHTSABER__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLightSaber(value);
	}
}

int ArmorObject::getHealthEncumbrance() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEALTHENCUMBRANCE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHealthEncumbrance();
	}
}

void ArmorObject::setHealthEncumbrance(int encumber) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHEALTHENCUMBRANCE__INT_);
		method.addSignedIntParameter(encumber);

		method.executeWithVoidReturn();
	} else {
		_implementation->setHealthEncumbrance(encumber);
	}
}

int ArmorObject::getActionEncumbrance() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIONENCUMBRANCE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getActionEncumbrance();
	}
}

void ArmorObject::setActionEncumbrance(int encumber) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACTIONENCUMBRANCE__INT_);
		method.addSignedIntParameter(encumber);

		method.executeWithVoidReturn();
	} else {
		_implementation->setActionEncumbrance(encumber);
	}
}

int ArmorObject::getMindEncumbrance() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDENCUMBRANCE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMindEncumbrance();
	}
}

void ArmorObject::setMindEncumbrance(int encumber) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMINDENCUMBRANCE__INT_);
		method.addSignedIntParameter(encumber);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMindEncumbrance(encumber);
	}
}

void ArmorObject::setEffectivenessSlice(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETEFFECTIVENESSSLICE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setEffectivenessSlice(value);
	}
}

void ArmorObject::setEncumbranceSlice(float value) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETENCUMBRANCESLICE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setEncumbranceSlice(value);
	}
}

byte ArmorObject::getHitLocation() {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHITLOCATION__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getHitLocation();
	}
}

void ArmorObject::setHitLocation(byte h) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHITLOCATION__BYTE_);
		method.addByteParameter(h);

		method.executeWithVoidReturn();
	} else {
		_implementation->setHitLocation(h);
	}
}

float ArmorObject::getResist(int type) {
	ArmorObjectImplementation* _implementation = static_cast<ArmorObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRESIST__INT_);
		method.addSignedIntParameter(type);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getResist(type);
	}
}

DistributedObjectServant* ArmorObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* ArmorObject::_getImplementationForRead() const {
	return _impl;
}

void ArmorObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ArmorObjectImplementation
 */

ArmorObjectImplementation::ArmorObjectImplementation(DummyConstructorParameter* param) : WearableObjectImplementation(param) {
	_initializeImplementation();
}


ArmorObjectImplementation::~ArmorObjectImplementation() {
}


void ArmorObjectImplementation::finalize() {
}

void ArmorObjectImplementation::_initializeImplementation() {
	_setClassHelper(ArmorObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ArmorObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<ArmorObject*>(stub);
	WearableObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ArmorObjectImplementation::_getStub() {
	return _this.get();
}

ArmorObjectImplementation::operator const ArmorObject*() {
	return _this.get();
}

void ArmorObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ArmorObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ArmorObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ArmorObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ArmorObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ArmorObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ArmorObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ArmorObjectImplementation::_serializationHelperMethod() {
	WearableObjectImplementation::_serializationHelperMethod();

	_setClassName("ArmorObject");

}

void ArmorObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ArmorObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ArmorObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (WearableObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xeeb40659: //ArmorObject.healthEncumbrance
		TypeInfo<int >::parseFromBinaryStream(&healthEncumbrance, stream);
		return true;

	case 0x7f538949: //ArmorObject.actionEncumbrance
		TypeInfo<int >::parseFromBinaryStream(&actionEncumbrance, stream);
		return true;

	case 0xaecc083b: //ArmorObject.mindEncumbrance
		TypeInfo<int >::parseFromBinaryStream(&mindEncumbrance, stream);
		return true;

	case 0x8d21b747: //ArmorObject.rating
		TypeInfo<int >::parseFromBinaryStream(&rating, stream);
		return true;

	case 0xc065156e: //ArmorObject.kinetic
		TypeInfo<float >::parseFromBinaryStream(&kinetic, stream);
		return true;

	case 0xd223642b: //ArmorObject.energy
		TypeInfo<float >::parseFromBinaryStream(&energy, stream);
		return true;

	case 0x68993a4b: //ArmorObject.electricity
		TypeInfo<float >::parseFromBinaryStream(&electricity, stream);
		return true;

	case 0x7e45dbfc: //ArmorObject.stun
		TypeInfo<float >::parseFromBinaryStream(&stun, stream);
		return true;

	case 0x84bf4ed: //ArmorObject.blast
		TypeInfo<float >::parseFromBinaryStream(&blast, stream);
		return true;

	case 0x3a700fd0: //ArmorObject.heat
		TypeInfo<float >::parseFromBinaryStream(&heat, stream);
		return true;

	case 0xfffd60d5: //ArmorObject.cold
		TypeInfo<float >::parseFromBinaryStream(&cold, stream);
		return true;

	case 0xdd7d7e5d: //ArmorObject.acid
		TypeInfo<float >::parseFromBinaryStream(&acid, stream);
		return true;

	case 0xabba9979: //ArmorObject.lightSaber
		TypeInfo<float >::parseFromBinaryStream(&lightSaber, stream);
		return true;

	case 0x10bcfe9d: //ArmorObject.specialResists
		TypeInfo<int >::parseFromBinaryStream(&specialResists, stream);
		return true;

	case 0x649e28d1: //ArmorObject.vulnerabilites
		TypeInfo<int >::parseFromBinaryStream(&vulnerabilites, stream);
		return true;

	case 0x3caaef3e: //ArmorObject.hitLocation
		TypeInfo<byte >::parseFromBinaryStream(&hitLocation, stream);
		return true;

	case 0xd16ec46a: //ArmorObject.baseProtection
		TypeInfo<float >::parseFromBinaryStream(&baseProtection, stream);
		return true;

	case 0xbceb2194: //ArmorObject.specialProtection
		TypeInfo<float >::parseFromBinaryStream(&specialProtection, stream);
		return true;

	case 0xf3165a3d: //ArmorObject.effectivenessSlice
		TypeInfo<float >::parseFromBinaryStream(&effectivenessSlice, stream);
		return true;

	case 0xc5431498: //ArmorObject.encumbranceSlice
		TypeInfo<float >::parseFromBinaryStream(&encumbranceSlice, stream);
		return true;

	}

	return false;
}

void ArmorObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ArmorObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ArmorObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = WearableObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xeeb40659; //ArmorObject.healthEncumbrance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&healthEncumbrance, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7f538949; //ArmorObject.actionEncumbrance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&actionEncumbrance, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xaecc083b; //ArmorObject.mindEncumbrance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&mindEncumbrance, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8d21b747; //ArmorObject.rating
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&rating, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc065156e; //ArmorObject.kinetic
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&kinetic, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd223642b; //ArmorObject.energy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&energy, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x68993a4b; //ArmorObject.electricity
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&electricity, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7e45dbfc; //ArmorObject.stun
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&stun, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x84bf4ed; //ArmorObject.blast
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&blast, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3a700fd0; //ArmorObject.heat
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&heat, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xfffd60d5; //ArmorObject.cold
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&cold, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdd7d7e5d; //ArmorObject.acid
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&acid, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xabba9979; //ArmorObject.lightSaber
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&lightSaber, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x10bcfe9d; //ArmorObject.specialResists
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&specialResists, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x649e28d1; //ArmorObject.vulnerabilites
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vulnerabilites, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3caaef3e; //ArmorObject.hitLocation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&hitLocation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd16ec46a; //ArmorObject.baseProtection
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&baseProtection, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbceb2194; //ArmorObject.specialProtection
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&specialProtection, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf3165a3d; //ArmorObject.effectivenessSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&effectivenessSlice, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc5431498; //ArmorObject.encumbranceSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&encumbranceSlice, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void ArmorObjectImplementation::writeJSON(nlohmann::json& j) {
	WearableObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["healthEncumbrance"] = healthEncumbrance;

	thisObject["actionEncumbrance"] = actionEncumbrance;

	thisObject["mindEncumbrance"] = mindEncumbrance;

	thisObject["rating"] = rating;

	thisObject["kinetic"] = kinetic;

	thisObject["energy"] = energy;

	thisObject["electricity"] = electricity;

	thisObject["stun"] = stun;

	thisObject["blast"] = blast;

	thisObject["heat"] = heat;

	thisObject["cold"] = cold;

	thisObject["acid"] = acid;

	thisObject["lightSaber"] = lightSaber;

	thisObject["specialResists"] = specialResists;

	thisObject["vulnerabilites"] = vulnerabilites;

	thisObject["hitLocation"] = hitLocation;

	thisObject["baseProtection"] = baseProtection;

	thisObject["specialProtection"] = specialProtection;

	thisObject["effectivenessSlice"] = effectivenessSlice;

	thisObject["encumbranceSlice"] = encumbranceSlice;

	j["ArmorObject"] = thisObject;
}

ArmorObjectImplementation::ArmorObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		healthEncumbrance = 100;
	healthEncumbrance = 100;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		actionEncumbrance = 100;
	actionEncumbrance = 100;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		mindEncumbrance = 100;
	mindEncumbrance = 100;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		rating = LIGHT;
	rating = LIGHT;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		kinetic = 0;
	kinetic = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		energy = 0;
	energy = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		electricity = 0;
	electricity = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		stun = 0;
	stun = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		blast = 0;
	blast = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		heat = 0;
	heat = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		cold = 0;
	cold = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		acid = 0;
	acid = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		lightSaber = 0;
	lightSaber = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		effectivenessSlice = 1;
	effectivenessSlice = 1;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		encumbranceSlice = 1;
	encumbranceSlice = 1;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		baseProtection = 0;
	baseProtection = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		specialProtection = 0;
	specialProtection = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		specialResists = 0;
	specialResists = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		vulnerabilites = 0;
	vulnerabilites = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		hitLocation = 0;
	hitLocation = 0;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		setSliceable(true);
	setSliceable(true);
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		Logger.setLoggingName("ArmorObject");
	Logger::setLoggingName("ArmorObject");
}

bool ArmorObjectImplementation::isSpecial(int type) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return specialResists & type;
	return specialResists & type;
}

bool ArmorObjectImplementation::isArmorObject() {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return true;
	return true;
}

void ArmorObjectImplementation::setRating(int rate) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		rating = rate;
	rating = rate;
}

int ArmorObjectImplementation::getRating() {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return rating;
	return rating;
}

void ArmorObjectImplementation::setKinetic(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		kinetic = value;
	kinetic = value;
}

void ArmorObjectImplementation::setEnergy(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		energy = value;
	energy = value;
}

void ArmorObjectImplementation::setElectricity(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		electricity = value;
	electricity = value;
}

void ArmorObjectImplementation::setStun(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		stun = value;
	stun = value;
}

void ArmorObjectImplementation::setBlast(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		blast = value;
	blast = value;
}

void ArmorObjectImplementation::setHeat(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		heat = value;
	heat = value;
}

void ArmorObjectImplementation::setCold(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		cold = value;
	cold = value;
}

void ArmorObjectImplementation::setAcid(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		acid = value;
	acid = value;
}

void ArmorObjectImplementation::setLightSaber(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		lightSaber = value;
	lightSaber = value;
}

int ArmorObjectImplementation::getHealthEncumbrance() {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return 
	if (healthEncumbrance < 0)	// server/zone/objects/tangible/wearables/ArmorObject.idl():  			return healthEncumbrance * (2 - encumbranceSlice);
	return healthEncumbrance * (2 - encumbranceSlice);
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return healthEncumbrance * encumbranceSlice;
	return healthEncumbrance * encumbranceSlice;
}

void ArmorObjectImplementation::setHealthEncumbrance(int encumber) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		healthEncumbrance = encumber;
	healthEncumbrance = encumber;
}

int ArmorObjectImplementation::getActionEncumbrance() {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return 
	if (actionEncumbrance < 0)	// server/zone/objects/tangible/wearables/ArmorObject.idl():  			return actionEncumbrance * (2 - encumbranceSlice);
	return actionEncumbrance * (2 - encumbranceSlice);
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return actionEncumbrance * encumbranceSlice;
	return actionEncumbrance * encumbranceSlice;
}

void ArmorObjectImplementation::setActionEncumbrance(int encumber) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		actionEncumbrance = encumber;
	actionEncumbrance = encumber;
}

int ArmorObjectImplementation::getMindEncumbrance() {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return 
	if (mindEncumbrance < 0)	// server/zone/objects/tangible/wearables/ArmorObject.idl():  			return mindEncumbrance * (2 - encumbranceSlice);
	return mindEncumbrance * (2 - encumbranceSlice);
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return mindEncumbrance * encumbranceSlice;
	return mindEncumbrance * encumbranceSlice;
}

void ArmorObjectImplementation::setMindEncumbrance(int encumber) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		mindEncumbrance = encumber;
	mindEncumbrance = encumber;
}

void ArmorObjectImplementation::setEffectivenessSlice(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		effectivenessSlice 
	if (value > 0.5f || value < 0)	// server/zone/objects/tangible/wearables/ArmorObject.idl():  			return;
	return;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		effectivenessSlice = 1 + value;
	effectivenessSlice = 1 + value;
}

void ArmorObjectImplementation::setEncumbranceSlice(float value) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		encumbranceSlice 
	if (value > 0.5f || value < 0)	// server/zone/objects/tangible/wearables/ArmorObject.idl():  			return;
	return;
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		encumbranceSlice = 1 - value;
	encumbranceSlice = 1 - value;
}

byte ArmorObjectImplementation::getHitLocation() {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		return hitLocation;
	return hitLocation;
}

void ArmorObjectImplementation::setHitLocation(byte h) {
	// server/zone/objects/tangible/wearables/ArmorObject.idl():  		hitLocation = h;
	hitLocation = h;
}

/*
 *	ArmorObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ArmorObjectAdapter::ArmorObjectAdapter(ArmorObject* obj) : WearableObjectAdapter(obj) {
}

void ArmorObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte selectedID = inv->getByteParameter();
			
			int _m_res = handleObjectMenuSelect(player, selectedID);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISSPECIAL__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			bool _m_res = isSpecial(type);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISVULNERABLE__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			bool _m_res = isVulnerable(type);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISARMOROBJECT__:
		{
			
			bool _m_res = isArmorObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETRATING__INT_:
		{
			int rate = inv->getSignedIntParameter();
			
			setRating(rate);
			
		}
		break;
	case RPC_GETRATING__:
		{
			
			int _m_res = getRating();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETKINETIC__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setKinetic(value);
			
		}
		break;
	case RPC_SETENERGY__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setEnergy(value);
			
		}
		break;
	case RPC_SETELECTRICITY__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setElectricity(value);
			
		}
		break;
	case RPC_SETSTUN__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setStun(value);
			
		}
		break;
	case RPC_SETBLAST__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setBlast(value);
			
		}
		break;
	case RPC_SETHEAT__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setHeat(value);
			
		}
		break;
	case RPC_SETCOLD__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setCold(value);
			
		}
		break;
	case RPC_SETACID__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setAcid(value);
			
		}
		break;
	case RPC_SETLIGHTSABER__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setLightSaber(value);
			
		}
		break;
	case RPC_GETHEALTHENCUMBRANCE__:
		{
			
			int _m_res = getHealthEncumbrance();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETHEALTHENCUMBRANCE__INT_:
		{
			int encumber = inv->getSignedIntParameter();
			
			setHealthEncumbrance(encumber);
			
		}
		break;
	case RPC_GETACTIONENCUMBRANCE__:
		{
			
			int _m_res = getActionEncumbrance();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETACTIONENCUMBRANCE__INT_:
		{
			int encumber = inv->getSignedIntParameter();
			
			setActionEncumbrance(encumber);
			
		}
		break;
	case RPC_GETMINDENCUMBRANCE__:
		{
			
			int _m_res = getMindEncumbrance();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMINDENCUMBRANCE__INT_:
		{
			int encumber = inv->getSignedIntParameter();
			
			setMindEncumbrance(encumber);
			
		}
		break;
	case RPC_SETEFFECTIVENESSSLICE__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setEffectivenessSlice(value);
			
		}
		break;
	case RPC_SETENCUMBRANCESLICE__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setEncumbranceSlice(value);
			
		}
		break;
	case RPC_GETHITLOCATION__:
		{
			
			byte _m_res = getHitLocation();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_SETHITLOCATION__BYTE_:
		{
			byte h = inv->getByteParameter();
			
			setHitLocation(h);
			
		}
		break;
	case RPC_GETRESIST__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			float _m_res = getResist(type);
			resp->insertFloat(_m_res);
		}
		break;
	default:
		WearableObjectAdapter::invokeMethod(methid, inv);
	}
}

void ArmorObjectAdapter::initializeTransientMembers() {
	(static_cast<ArmorObject*>(stub))->initializeTransientMembers();
}

void ArmorObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<ArmorObject*>(stub))->notifyLoadFromDatabase();
}

int ArmorObjectAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<ArmorObject*>(stub))->handleObjectMenuSelect(player, selectedID);
}

bool ArmorObjectAdapter::isSpecial(int type) {
	return (static_cast<ArmorObject*>(stub))->isSpecial(type);
}

bool ArmorObjectAdapter::isVulnerable(int type) {
	return (static_cast<ArmorObject*>(stub))->isVulnerable(type);
}

bool ArmorObjectAdapter::isArmorObject() {
	return (static_cast<ArmorObject*>(stub))->isArmorObject();
}

void ArmorObjectAdapter::setRating(int rate) {
	(static_cast<ArmorObject*>(stub))->setRating(rate);
}

int ArmorObjectAdapter::getRating() {
	return (static_cast<ArmorObject*>(stub))->getRating();
}

void ArmorObjectAdapter::setKinetic(float value) {
	(static_cast<ArmorObject*>(stub))->setKinetic(value);
}

void ArmorObjectAdapter::setEnergy(float value) {
	(static_cast<ArmorObject*>(stub))->setEnergy(value);
}

void ArmorObjectAdapter::setElectricity(float value) {
	(static_cast<ArmorObject*>(stub))->setElectricity(value);
}

void ArmorObjectAdapter::setStun(float value) {
	(static_cast<ArmorObject*>(stub))->setStun(value);
}

void ArmorObjectAdapter::setBlast(float value) {
	(static_cast<ArmorObject*>(stub))->setBlast(value);
}

void ArmorObjectAdapter::setHeat(float value) {
	(static_cast<ArmorObject*>(stub))->setHeat(value);
}

void ArmorObjectAdapter::setCold(float value) {
	(static_cast<ArmorObject*>(stub))->setCold(value);
}

void ArmorObjectAdapter::setAcid(float value) {
	(static_cast<ArmorObject*>(stub))->setAcid(value);
}

void ArmorObjectAdapter::setLightSaber(float value) {
	(static_cast<ArmorObject*>(stub))->setLightSaber(value);
}

int ArmorObjectAdapter::getHealthEncumbrance() {
	return (static_cast<ArmorObject*>(stub))->getHealthEncumbrance();
}

void ArmorObjectAdapter::setHealthEncumbrance(int encumber) {
	(static_cast<ArmorObject*>(stub))->setHealthEncumbrance(encumber);
}

int ArmorObjectAdapter::getActionEncumbrance() {
	return (static_cast<ArmorObject*>(stub))->getActionEncumbrance();
}

void ArmorObjectAdapter::setActionEncumbrance(int encumber) {
	(static_cast<ArmorObject*>(stub))->setActionEncumbrance(encumber);
}

int ArmorObjectAdapter::getMindEncumbrance() {
	return (static_cast<ArmorObject*>(stub))->getMindEncumbrance();
}

void ArmorObjectAdapter::setMindEncumbrance(int encumber) {
	(static_cast<ArmorObject*>(stub))->setMindEncumbrance(encumber);
}

void ArmorObjectAdapter::setEffectivenessSlice(float value) {
	(static_cast<ArmorObject*>(stub))->setEffectivenessSlice(value);
}

void ArmorObjectAdapter::setEncumbranceSlice(float value) {
	(static_cast<ArmorObject*>(stub))->setEncumbranceSlice(value);
}

byte ArmorObjectAdapter::getHitLocation() {
	return (static_cast<ArmorObject*>(stub))->getHitLocation();
}

void ArmorObjectAdapter::setHitLocation(byte h) {
	(static_cast<ArmorObject*>(stub))->setHitLocation(h);
}

float ArmorObjectAdapter::getResist(int type) {
	return (static_cast<ArmorObject*>(stub))->getResist(type);
}

/*
 *	ArmorObjectHelper
 */

ArmorObjectHelper* ArmorObjectHelper::staticInitializer = ArmorObjectHelper::instance();

ArmorObjectHelper::ArmorObjectHelper() {
	className = "ArmorObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void ArmorObjectHelper::finalizeHelper() {
	ArmorObjectHelper::finalize();
}

DistributedObject* ArmorObjectHelper::instantiateObject() {
	return new ArmorObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* ArmorObjectHelper::instantiateServant() {
	return new ArmorObjectImplementation();
}

DistributedObjectPOD* ArmorObjectHelper::instantiatePOD() {
	return new ArmorObjectPOD();
}

DistributedObjectAdapter* ArmorObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ArmorObjectAdapter(static_cast<ArmorObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	ArmorObjectPOD
 */

ArmorObjectPOD::~ArmorObjectPOD() {
	finalize();
}

ArmorObjectPOD::ArmorObjectPOD(void) {
	_className = "ArmorObject";
}


void ArmorObjectPOD::writeJSON(nlohmann::json& j) {
	WearableObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (healthEncumbrance)
		thisObject["healthEncumbrance"] = healthEncumbrance.value();

	if (actionEncumbrance)
		thisObject["actionEncumbrance"] = actionEncumbrance.value();

	if (mindEncumbrance)
		thisObject["mindEncumbrance"] = mindEncumbrance.value();

	if (rating)
		thisObject["rating"] = rating.value();

	if (kinetic)
		thisObject["kinetic"] = kinetic.value();

	if (energy)
		thisObject["energy"] = energy.value();

	if (electricity)
		thisObject["electricity"] = electricity.value();

	if (stun)
		thisObject["stun"] = stun.value();

	if (blast)
		thisObject["blast"] = blast.value();

	if (heat)
		thisObject["heat"] = heat.value();

	if (cold)
		thisObject["cold"] = cold.value();

	if (acid)
		thisObject["acid"] = acid.value();

	if (lightSaber)
		thisObject["lightSaber"] = lightSaber.value();

	if (specialResists)
		thisObject["specialResists"] = specialResists.value();

	if (vulnerabilites)
		thisObject["vulnerabilites"] = vulnerabilites.value();

	if (hitLocation)
		thisObject["hitLocation"] = hitLocation.value();

	if (baseProtection)
		thisObject["baseProtection"] = baseProtection.value();

	if (specialProtection)
		thisObject["specialProtection"] = specialProtection.value();

	if (effectivenessSlice)
		thisObject["effectivenessSlice"] = effectivenessSlice.value();

	if (encumbranceSlice)
		thisObject["encumbranceSlice"] = encumbranceSlice.value();

	j["ArmorObject"] = thisObject;
}


void ArmorObjectPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ArmorObjectPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ArmorObjectPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = WearableObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (healthEncumbrance) {
	_nameHashCode = 0xeeb40659; //ArmorObject.healthEncumbrance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&healthEncumbrance.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (actionEncumbrance) {
	_nameHashCode = 0x7f538949; //ArmorObject.actionEncumbrance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&actionEncumbrance.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (mindEncumbrance) {
	_nameHashCode = 0xaecc083b; //ArmorObject.mindEncumbrance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&mindEncumbrance.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (rating) {
	_nameHashCode = 0x8d21b747; //ArmorObject.rating
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&rating.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (kinetic) {
	_nameHashCode = 0xc065156e; //ArmorObject.kinetic
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&kinetic.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (energy) {
	_nameHashCode = 0xd223642b; //ArmorObject.energy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&energy.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (electricity) {
	_nameHashCode = 0x68993a4b; //ArmorObject.electricity
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&electricity.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (stun) {
	_nameHashCode = 0x7e45dbfc; //ArmorObject.stun
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&stun.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (blast) {
	_nameHashCode = 0x84bf4ed; //ArmorObject.blast
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&blast.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (heat) {
	_nameHashCode = 0x3a700fd0; //ArmorObject.heat
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&heat.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (cold) {
	_nameHashCode = 0xfffd60d5; //ArmorObject.cold
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&cold.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (acid) {
	_nameHashCode = 0xdd7d7e5d; //ArmorObject.acid
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&acid.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lightSaber) {
	_nameHashCode = 0xabba9979; //ArmorObject.lightSaber
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&lightSaber.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (specialResists) {
	_nameHashCode = 0x10bcfe9d; //ArmorObject.specialResists
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&specialResists.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (vulnerabilites) {
	_nameHashCode = 0x649e28d1; //ArmorObject.vulnerabilites
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vulnerabilites.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (hitLocation) {
	_nameHashCode = 0x3caaef3e; //ArmorObject.hitLocation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&hitLocation.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (baseProtection) {
	_nameHashCode = 0xd16ec46a; //ArmorObject.baseProtection
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&baseProtection.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (specialProtection) {
	_nameHashCode = 0xbceb2194; //ArmorObject.specialProtection
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&specialProtection.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (effectivenessSlice) {
	_nameHashCode = 0xf3165a3d; //ArmorObject.effectivenessSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&effectivenessSlice.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (encumbranceSlice) {
	_nameHashCode = 0xc5431498; //ArmorObject.encumbranceSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&encumbranceSlice.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool ArmorObjectPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (WearableObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xeeb40659: //ArmorObject.healthEncumbrance
		{
			int _mnhealthEncumbrance;
			TypeInfo<int >::parseFromBinaryStream(&_mnhealthEncumbrance, stream);
			healthEncumbrance = std::move(_mnhealthEncumbrance);
		}
		return true;

	case 0x7f538949: //ArmorObject.actionEncumbrance
		{
			int _mnactionEncumbrance;
			TypeInfo<int >::parseFromBinaryStream(&_mnactionEncumbrance, stream);
			actionEncumbrance = std::move(_mnactionEncumbrance);
		}
		return true;

	case 0xaecc083b: //ArmorObject.mindEncumbrance
		{
			int _mnmindEncumbrance;
			TypeInfo<int >::parseFromBinaryStream(&_mnmindEncumbrance, stream);
			mindEncumbrance = std::move(_mnmindEncumbrance);
		}
		return true;

	case 0x8d21b747: //ArmorObject.rating
		{
			int _mnrating;
			TypeInfo<int >::parseFromBinaryStream(&_mnrating, stream);
			rating = std::move(_mnrating);
		}
		return true;

	case 0xc065156e: //ArmorObject.kinetic
		{
			float _mnkinetic;
			TypeInfo<float >::parseFromBinaryStream(&_mnkinetic, stream);
			kinetic = std::move(_mnkinetic);
		}
		return true;

	case 0xd223642b: //ArmorObject.energy
		{
			float _mnenergy;
			TypeInfo<float >::parseFromBinaryStream(&_mnenergy, stream);
			energy = std::move(_mnenergy);
		}
		return true;

	case 0x68993a4b: //ArmorObject.electricity
		{
			float _mnelectricity;
			TypeInfo<float >::parseFromBinaryStream(&_mnelectricity, stream);
			electricity = std::move(_mnelectricity);
		}
		return true;

	case 0x7e45dbfc: //ArmorObject.stun
		{
			float _mnstun;
			TypeInfo<float >::parseFromBinaryStream(&_mnstun, stream);
			stun = std::move(_mnstun);
		}
		return true;

	case 0x84bf4ed: //ArmorObject.blast
		{
			float _mnblast;
			TypeInfo<float >::parseFromBinaryStream(&_mnblast, stream);
			blast = std::move(_mnblast);
		}
		return true;

	case 0x3a700fd0: //ArmorObject.heat
		{
			float _mnheat;
			TypeInfo<float >::parseFromBinaryStream(&_mnheat, stream);
			heat = std::move(_mnheat);
		}
		return true;

	case 0xfffd60d5: //ArmorObject.cold
		{
			float _mncold;
			TypeInfo<float >::parseFromBinaryStream(&_mncold, stream);
			cold = std::move(_mncold);
		}
		return true;

	case 0xdd7d7e5d: //ArmorObject.acid
		{
			float _mnacid;
			TypeInfo<float >::parseFromBinaryStream(&_mnacid, stream);
			acid = std::move(_mnacid);
		}
		return true;

	case 0xabba9979: //ArmorObject.lightSaber
		{
			float _mnlightSaber;
			TypeInfo<float >::parseFromBinaryStream(&_mnlightSaber, stream);
			lightSaber = std::move(_mnlightSaber);
		}
		return true;

	case 0x10bcfe9d: //ArmorObject.specialResists
		{
			int _mnspecialResists;
			TypeInfo<int >::parseFromBinaryStream(&_mnspecialResists, stream);
			specialResists = std::move(_mnspecialResists);
		}
		return true;

	case 0x649e28d1: //ArmorObject.vulnerabilites
		{
			int _mnvulnerabilites;
			TypeInfo<int >::parseFromBinaryStream(&_mnvulnerabilites, stream);
			vulnerabilites = std::move(_mnvulnerabilites);
		}
		return true;

	case 0x3caaef3e: //ArmorObject.hitLocation
		{
			byte _mnhitLocation;
			TypeInfo<byte >::parseFromBinaryStream(&_mnhitLocation, stream);
			hitLocation = std::move(_mnhitLocation);
		}
		return true;

	case 0xd16ec46a: //ArmorObject.baseProtection
		{
			float _mnbaseProtection;
			TypeInfo<float >::parseFromBinaryStream(&_mnbaseProtection, stream);
			baseProtection = std::move(_mnbaseProtection);
		}
		return true;

	case 0xbceb2194: //ArmorObject.specialProtection
		{
			float _mnspecialProtection;
			TypeInfo<float >::parseFromBinaryStream(&_mnspecialProtection, stream);
			specialProtection = std::move(_mnspecialProtection);
		}
		return true;

	case 0xf3165a3d: //ArmorObject.effectivenessSlice
		{
			float _mneffectivenessSlice;
			TypeInfo<float >::parseFromBinaryStream(&_mneffectivenessSlice, stream);
			effectivenessSlice = std::move(_mneffectivenessSlice);
		}
		return true;

	case 0xc5431498: //ArmorObject.encumbranceSlice
		{
			float _mnencumbranceSlice;
			TypeInfo<float >::parseFromBinaryStream(&_mnencumbranceSlice, stream);
			encumbranceSlice = std::move(_mnencumbranceSlice);
		}
		return true;

	}

	return false;
}

void ArmorObjectPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ArmorObjectPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ArmorObjectPOD::writeObjectCompact(ObjectOutputStream* stream) {
	WearableObjectPOD::writeObjectCompact(stream);

	TypeInfo<int >::toBinaryStream(&healthEncumbrance.value(), stream);

	TypeInfo<int >::toBinaryStream(&actionEncumbrance.value(), stream);

	TypeInfo<int >::toBinaryStream(&mindEncumbrance.value(), stream);

	TypeInfo<int >::toBinaryStream(&rating.value(), stream);

	TypeInfo<float >::toBinaryStream(&kinetic.value(), stream);

	TypeInfo<float >::toBinaryStream(&energy.value(), stream);

	TypeInfo<float >::toBinaryStream(&electricity.value(), stream);

	TypeInfo<float >::toBinaryStream(&stun.value(), stream);

	TypeInfo<float >::toBinaryStream(&blast.value(), stream);

	TypeInfo<float >::toBinaryStream(&heat.value(), stream);

	TypeInfo<float >::toBinaryStream(&cold.value(), stream);

	TypeInfo<float >::toBinaryStream(&acid.value(), stream);

	TypeInfo<float >::toBinaryStream(&lightSaber.value(), stream);

	TypeInfo<int >::toBinaryStream(&specialResists.value(), stream);

	TypeInfo<int >::toBinaryStream(&vulnerabilites.value(), stream);

	TypeInfo<byte >::toBinaryStream(&hitLocation.value(), stream);

	TypeInfo<float >::toBinaryStream(&baseProtection.value(), stream);

	TypeInfo<float >::toBinaryStream(&specialProtection.value(), stream);

	TypeInfo<float >::toBinaryStream(&effectivenessSlice.value(), stream);

	TypeInfo<float >::toBinaryStream(&encumbranceSlice.value(), stream);


}

