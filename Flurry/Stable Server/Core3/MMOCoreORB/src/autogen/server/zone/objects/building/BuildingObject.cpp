/*
 *	autogen/server/zone/objects/building/BuildingObject.cpp generated by engine3 IDL compiler 0.70
 */

#include "BuildingObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/tangible/sign/SignObject.h"

#include "server/zone/Zone.h"

/*
 *	BuildingObjectStub
 */

enum {RPC_CREATECELLOBJECTS__ = 3291165931,RPC_DESTROYOBJECTFROMDATABASE__BOOL_,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_CREATECONTAINERCOMPONENT__,RPC_SETCUSTOMOBJECTNAME__UNICODESTRING_BOOL_,RPC_UPDATESIGNNAME__BOOL_,RPC_SENDCONTAINEROBJECTSTO__SCENEOBJECT_BOOL_,RPC_UPDATECELLPERMISSIONSTO__CREATUREOBJECT_,RPC_BROADCASTCELLPERMISSIONS__,RPC_BROADCASTCELLPERMISSIONS__LONG_,RPC_ISALLOWEDENTRY__CREATUREOBJECT_,RPC_ISCITYBANNED__CREATUREOBJECT_,RPC_NOTIFYSTRUCTUREPLACED__CREATUREOBJECT_,RPC_HASTEMPLATEEJECTIONPOINT__,RPC_EJECTOBJECT__CREATUREOBJECT_,RPC_NOTIFYREMOVEFROMZONE__,RPC_NOTIFYINSERTTOZONE__ZONE_,RPC_NOTIFYOBJECTINSERTEDTOZONE__SCENEOBJECT_,RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDDESTROYTO__SCENEOBJECT_,RPC_ADDCELL__CELLOBJECT_INT_,RPC_ISSTATICBUILDING__,RPC_GETCELL__INT_,RPC_GETCELL__STRING_,RPC_GETTOTALCELLNUMBER__,RPC_NOTIFYOBJECTINSERTEDTOCHILD__SCENEOBJECT_SCENEOBJECT_SCENEOBJECT_,RPC_NOTIFYOBJECTREMOVEDFROMCHILD__SCENEOBJECT_SCENEOBJECT_,RPC_GETCURRENTNUMBEROFPLAYERITEMS__,RPC_DESTROYALLPLAYERITEMS__,RPC_ONENTER__CREATUREOBJECT_,RPC_ONEXIT__CREATUREOBJECT_LONG_,RPC_SETSIGNOBJECT__SIGNOBJECT_,RPC_GETSIGNOBJECT__,RPC_ISPUBLICSTRUCTURE__,RPC_ISPRIVATESTRUCTURE__,RPC_SETPUBLICSTRUCTURE__BOOL_,RPC_ISCONDEMNED__,RPC_GETMAPCELLSIZE__,RPC_TOGGLEPRIVACY__,RPC_GETMAXIMUMNUMBEROFPLAYERITEMS__,RPC_GETREDEEDMESSAGE__,RPC_HASACCESSFEE__,RPC_GETACCESSFEE__,RPC_CANCHANGEACCESSFEE__,RPC_SETACCESSFEE__INT_INT_,RPC_REMOVEACCESSFEE__,RPC_GETACCESSFEEDELAY__,RPC_PAYACCESSFEE__CREATUREOBJECT_,RPC_UPDATEPAIDACCESSLIST__,RPC_REGISTERPROFESSIONAL__CREATUREOBJECT_,RPC_UNREGISTERPROFESSIONAL__CREATUREOBJECT_,RPC_ISINPLAYERCITY__,RPC_CANPLAYERREGISTERWITHIN__,RPC_ISPLAYERREGISTEREDWITHIN__LONG_,RPC_CREATECHILDOBJECTS__,RPC_SPAWNCHILDCREATURESFROMTEMPLATE__,RPC_HASTEMPLATECHILDCREATURES__,RPC_DESTROYCHILDOBJECTS__,RPC_ISRESIDENCE__,RPC_SETRESIDENCE__BOOL_,RPC_GETFACTIONBASETYPE__,RPC_GETOUTOFRANGEDISTANCE__,RPC_GETCELLNAME__LONG_};

BuildingObject::BuildingObject() : StructureObject(DummyConstructorParameter::instance()) {
	BuildingObjectImplementation* _implementation = new BuildingObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("BuildingObject");
}

BuildingObject::BuildingObject(DummyConstructorParameter* param) : StructureObject(param) {
	_setClassName("BuildingObject");
}

BuildingObject::~BuildingObject() {
}



void BuildingObject::createCellObjects() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECELLOBJECTS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->createCellObjects();
	}
}

void BuildingObject::destroyObjectFromDatabase(bool destroyContainedObjects) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyObjectFromDatabase(destroyContainedObjects);
	}
}

void BuildingObject::loadTemplateData(SharedObjectTemplate* templateData) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void BuildingObject::initializeTransientMembers() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void BuildingObject::createContainerComponent() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECONTAINERCOMPONENT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->createContainerComponent();
	}
}

void BuildingObject::setCustomObjectName(const UnicodeString& name, bool notifyClient) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCUSTOMOBJECTNAME__UNICODESTRING_BOOL_);
		method.addUnicodeParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCustomObjectName(name, notifyClient);
	}
}

void BuildingObject::updateSignName(bool notifyClient) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATESIGNNAME__BOOL_);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateSignName(notifyClient);
	}
}

void BuildingObject::sendContainerObjectsTo(SceneObject* player, bool forceLoad) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONTAINEROBJECTSTO__SCENEOBJECT_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(forceLoad);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendContainerObjectsTo(player, forceLoad);
	}
}

void BuildingObject::updateCellPermissionsTo(CreatureObject* creature) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATECELLPERMISSIONSTO__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateCellPermissionsTo(creature);
	}
}

void BuildingObject::broadcastCellPermissions() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BROADCASTCELLPERMISSIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->broadcastCellPermissions();
	}
}

void BuildingObject::broadcastCellPermissions(unsigned long long objectid) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BROADCASTCELLPERMISSIONS__LONG_);
		method.addUnsignedLongParameter(objectid);

		method.executeWithVoidReturn();
	} else {
		_implementation->broadcastCellPermissions(objectid);
	}
}

bool BuildingObject::isAllowedEntry(CreatureObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISALLOWEDENTRY__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAllowedEntry(player);
	}
}

bool BuildingObject::isCityBanned(CreatureObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCITYBANNED__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCityBanned(player);
	}
}

int BuildingObject::notifyStructurePlaced(CreatureObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYSTRUCTUREPLACED__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyStructurePlaced(player);
	}
}

bool BuildingObject::hasTemplateEjectionPoint() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASTEMPLATEEJECTIONPOINT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasTemplateEjectionPoint();
	}
}

Vector3 BuildingObject::getTemplateEjectionPoint() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTemplateEjectionPoint();
	}
}

Vector3 BuildingObject::getEjectionPoint() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getEjectionPoint();
	}
}

void BuildingObject::ejectObject(CreatureObject* creature) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_EJECTOBJECT__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->ejectObject(creature);
	}
}

void BuildingObject::notifyRemoveFromZone() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYREMOVEFROMZONE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyRemoveFromZone();
	}
}

void BuildingObject::notifyInsert(QuadTreeEntry* obj) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->notifyInsert(obj);
	}
}

void BuildingObject::notifyInsertToZone(Zone* zone) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYINSERTTOZONE__ZONE_);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyInsertToZone(zone);
	}
}

void BuildingObject::notifyDissapear(QuadTreeEntry* obj) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->notifyDissapear(obj);
	}
}

void BuildingObject::notifyPositionUpdate(QuadTreeEntry* entry) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->notifyPositionUpdate(entry);
	}
}

void BuildingObject::notifyObjectInsertedToZone(SceneObject* object) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTINSERTEDTOZONE__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyObjectInsertedToZone(object);
	}
}

void BuildingObject::insert(QuadTreeEntry* obj) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->insert(obj);
	}
}

void BuildingObject::remove(QuadTreeEntry* obj) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->remove(obj);
	}
}

void BuildingObject::update(QuadTreeEntry* obj) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->update(obj);
	}
}

void BuildingObject::inRange(QuadTreeEntry* obj, float range) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->inRange(obj, range);
	}
}

void BuildingObject::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);
		method.addBooleanParameter(forceLoadContainer);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendTo(player, doClose, forceLoadContainer);
	}
}

void BuildingObject::sendBaselinesTo(SceneObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

void BuildingObject::sendDestroyTo(SceneObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDDESTROYTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendDestroyTo(player);
	}
}

void BuildingObject::addCell(CellObject* cell, unsigned int cellNumber) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCELL__CELLOBJECT_INT_);
		method.addObjectParameter(cell);
		method.addUnsignedIntParameter(cellNumber);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addCell(cell, cellNumber);
	}
}

bool BuildingObject::isStaticBuilding() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTATICBUILDING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isStaticBuilding();
	}
}

CellObject* BuildingObject::getCell(unsigned int idx) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCELL__INT_);
		method.addUnsignedIntParameter(idx);

		return static_cast<CellObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getCell(idx);
	}
}

CellObject* BuildingObject::getCell(const String& cellName) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCELL__STRING_);
		method.addAsciiParameter(cellName);

		return static_cast<CellObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getCell(cellName);
	}
}

int BuildingObject::getTotalCellNumber() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTOTALCELLNUMBER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getTotalCellNumber();
	}
}

int BuildingObject::notifyObjectInsertedToChild(SceneObject* object, SceneObject* child, SceneObject* oldParent) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTINSERTEDTOCHILD__SCENEOBJECT_SCENEOBJECT_SCENEOBJECT_);
		method.addObjectParameter(object);
		method.addObjectParameter(child);
		method.addObjectParameter(oldParent);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObjectInsertedToChild(object, child, oldParent);
	}
}

int BuildingObject::notifyObjectRemovedFromChild(SceneObject* object, SceneObject* child) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTREMOVEDFROMCHILD__SCENEOBJECT_SCENEOBJECT_);
		method.addObjectParameter(object);
		method.addObjectParameter(child);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObjectRemovedFromChild(object, child);
	}
}

int BuildingObject::getCurrentNumberOfPlayerItems() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTNUMBEROFPLAYERITEMS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCurrentNumberOfPlayerItems();
	}
}

void BuildingObject::destroyAllPlayerItems() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYALLPLAYERITEMS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->destroyAllPlayerItems();
	}
}

void BuildingObject::onEnter(CreatureObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ONENTER__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->onEnter(player);
	}
}

void BuildingObject::onExit(CreatureObject* player, unsigned long long parentid) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ONEXIT__CREATUREOBJECT_LONG_);
		method.addObjectParameter(player);
		method.addUnsignedLongParameter(parentid);

		method.executeWithVoidReturn();
	} else {
		_implementation->onExit(player, parentid);
	}
}

bool BuildingObject::__isBuildingObject() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->isBuildingObject();
	}
}

void BuildingObject::setSignObject(SignObject* sign) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSIGNOBJECT__SIGNOBJECT_);
		method.addObjectParameter(sign);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setSignObject(sign);
	}
}

SignObject* BuildingObject::getSignObject() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSIGNOBJECT__);

		return static_cast<SignObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSignObject();
	}
}

bool BuildingObject::isPublicStructure() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPUBLICSTRUCTURE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPublicStructure();
	}
}

bool BuildingObject::isPrivateStructure() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPRIVATESTRUCTURE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPrivateStructure();
	}
}

void BuildingObject::setPublicStructure(bool privacy) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPUBLICSTRUCTURE__BOOL_);
		method.addBooleanParameter(privacy);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPublicStructure(privacy);
	}
}

bool BuildingObject::isCondemned() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCONDEMNED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCondemned();
	}
}

int BuildingObject::getMapCellSize() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAPCELLSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMapCellSize();
	}
}

bool BuildingObject::togglePrivacy() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_TOGGLEPRIVACY__);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->togglePrivacy();
	}
}

unsigned int BuildingObject::getMaximumNumberOfPlayerItems() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXIMUMNUMBEROFPLAYERITEMS__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getMaximumNumberOfPlayerItems();
	}
}

String BuildingObject::getRedeedMessage() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREDEEDMESSAGE__);

		String _return_getRedeedMessage;
		method.executeWithAsciiReturn(_return_getRedeedMessage);
		return _return_getRedeedMessage;
	} else {
		return _implementation->getRedeedMessage();
	}
}

bool BuildingObject::hasAccessFee() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASACCESSFEE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasAccessFee();
	}
}

int BuildingObject::getAccessFee() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCESSFEE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAccessFee();
	}
}

bool BuildingObject::canChangeAccessFee() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCHANGEACCESSFEE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canChangeAccessFee();
	}
}

void BuildingObject::setAccessFee(int fee, int duration) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCESSFEE__INT_INT_);
		method.addSignedIntParameter(fee);
		method.addSignedIntParameter(duration);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAccessFee(fee, duration);
	}
}

void BuildingObject::removeAccessFee() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEACCESSFEE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeAccessFee();
	}
}

BuildingObject* BuildingObject::__asBuildingObject() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asBuildingObject();
	}
}

int BuildingObject::getAccessFeeDelay() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCESSFEEDELAY__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAccessFeeDelay();
	}
}

void BuildingObject::payAccessFee(CreatureObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PAYACCESSFEE__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert((player == NULL) || player->isLockedByCurrentThread());
		_implementation->payAccessFee(player);
	}
}

void BuildingObject::updatePaidAccessList() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEPAIDACCESSLIST__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updatePaidAccessList();
	}
}

void BuildingObject::registerProfessional(CreatureObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REGISTERPROFESSIONAL__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->registerProfessional(player);
	}
}

void BuildingObject::unregisterProfessional(CreatureObject* player) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNREGISTERPROFESSIONAL__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->unregisterProfessional(player);
	}
}

bool BuildingObject::isInPlayerCity() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINPLAYERCITY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInPlayerCity();
	}
}

bool BuildingObject::canPlayerRegisterWithin() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANPLAYERREGISTERWITHIN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canPlayerRegisterWithin();
	}
}

bool BuildingObject::isPlayerRegisteredWithin(unsigned long long id) const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYERREGISTEREDWITHIN__LONG_);
		method.addUnsignedLongParameter(id);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPlayerRegisteredWithin(id);
	}
}

void BuildingObject::createChildObjects() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECHILDOBJECTS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->createChildObjects();
	}
}

void BuildingObject::spawnChildSceneObject(String& templatePath, float x, float z, float y, unsigned long long cellID, float dw, float dx, float dy, float dz) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->spawnChildSceneObject(templatePath, x, z, y, cellID, dw, dx, dy, dz);
	}
}

void BuildingObject::spawnChildCreaturesFromTemplate() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SPAWNCHILDCREATURESFROMTEMPLATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->spawnChildCreaturesFromTemplate();
	}
}

void BuildingObject::spawnChildCreature(String& mobile, int respawnTimer, float x, float z, float y, float heading, unsigned long long cellID) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->spawnChildCreature(mobile, respawnTimer, x, z, y, heading, cellID);
	}
}

bool BuildingObject::hasTemplateChildCreatures() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASTEMPLATECHILDCREATURES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasTemplateChildCreatures();
	}
}

void BuildingObject::destroyChildObjects() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYCHILDOBJECTS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyChildObjects();
	}
}

bool BuildingObject::isResidence() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRESIDENCE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isResidence();
	}
}

void BuildingObject::setResidence(bool isResidence) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRESIDENCE__BOOL_);
		method.addBooleanParameter(isResidence);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setResidence(isResidence);
	}
}

int BuildingObject::getFactionBaseType() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONBASETYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFactionBaseType();
	}
}

void BuildingObject::changeSign(const SignTemplate* signConfig) {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->changeSign(signConfig);
	}
}

Vector<Reference<MeshData*> > BuildingObject::getTransformedMeshData(const Matrix4* parentTransform) const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTransformedMeshData(parentTransform);
	}
}

const BaseBoundingVolume* BuildingObject::getBoundingVolume() {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getBoundingVolume();
	}
}

float BuildingObject::getOutOfRangeDistance() const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOUTOFRANGEDISTANCE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getOutOfRangeDistance();
	}
}

String BuildingObject::getCellName(unsigned long long cellID) const {
	BuildingObjectImplementation* _implementation = static_cast<BuildingObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCELLNAME__LONG_);
		method.addUnsignedLongParameter(cellID);

		String _return_getCellName;
		method.executeWithAsciiReturn(_return_getCellName);
		return _return_getCellName;
	} else {
		return _implementation->getCellName(cellID);
	}
}

DistributedObjectServant* BuildingObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* BuildingObject::_getImplementationForRead() const {
	return _impl;
}

void BuildingObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	BuildingObjectImplementation
 */

BuildingObjectImplementation::BuildingObjectImplementation(DummyConstructorParameter* param) : StructureObjectImplementation(param) {
	_initializeImplementation();
}


BuildingObjectImplementation::~BuildingObjectImplementation() {
}


void BuildingObjectImplementation::finalize() {
}

void BuildingObjectImplementation::_initializeImplementation() {
	_setClassHelper(BuildingObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void BuildingObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<BuildingObject*>(stub);
	StructureObjectImplementation::_setStub(stub);
}

DistributedObjectStub* BuildingObjectImplementation::_getStub() {
	return _this.get();
}

BuildingObjectImplementation::operator const BuildingObject*() {
	return _this.get();
}

void BuildingObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void BuildingObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void BuildingObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void BuildingObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void BuildingObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void BuildingObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void BuildingObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void BuildingObjectImplementation::_serializationHelperMethod() {
	StructureObjectImplementation::_serializationHelperMethod();

	_setClassName("BuildingObject");

}

void BuildingObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(BuildingObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool BuildingObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (StructureObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x20f3b6a6: //BuildingObject.cells
		TypeInfo<VectorMap<unsigned int, ManagedReference<CellObject* > > >::parseFromBinaryStream(&cells, stream);
		return true;

	case 0x38fc81b9: //BuildingObject.totalCellNumber
		TypeInfo<int >::parseFromBinaryStream(&totalCellNumber, stream);
		return true;

	case 0xd3b1e837: //BuildingObject.signObject
		TypeInfo<ManagedReference<SignObject* > >::parseFromBinaryStream(&signObject, stream);
		return true;

	case 0xa7b4b67: //BuildingObject.deedObjectID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&deedObjectID, stream);
		return true;

	case 0x27b0682d: //BuildingObject.accessFee
		TypeInfo<int >::parseFromBinaryStream(&accessFee, stream);
		return true;

	case 0xd12474b7: //BuildingObject.accessDuration
		TypeInfo<int >::parseFromBinaryStream(&accessDuration, stream);
		return true;

	case 0xe781d77d: //BuildingObject.paidAccessList
		TypeInfo<VectorMap<unsigned long long, unsigned int> >::parseFromBinaryStream(&paidAccessList, stream);
		return true;

	case 0x2f655877: //BuildingObject.childCreatureObjects
		TypeInfo<SortedVector<ManagedReference<CreatureObject* > > >::parseFromBinaryStream(&childCreatureObjects, stream);
		return true;

	case 0xd1c7bb1c: //BuildingObject.publicStructure
		TypeInfo<bool >::parseFromBinaryStream(&publicStructure, stream);
		return true;

	case 0xbd232a91: //BuildingObject.signName
		TypeInfo<UnicodeString >::parseFromBinaryStream(&signName, stream);
		return true;

	case 0xff1529a2: //BuildingObject.isOwnerResidence
		TypeInfo<bool >::parseFromBinaryStream(&isOwnerResidence, stream);
		return true;

	case 0x164451a9: //BuildingObject.factionBaseType
		TypeInfo<int >::parseFromBinaryStream(&factionBaseType, stream);
		return true;

	}

	return false;
}

void BuildingObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = BuildingObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int BuildingObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = StructureObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x20f3b6a6; //BuildingObject.cells
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, ManagedReference<CellObject* > > >::toBinaryStream(&cells, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x38fc81b9; //BuildingObject.totalCellNumber
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&totalCellNumber, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd3b1e837; //BuildingObject.signObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<SignObject* > >::toBinaryStream(&signObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa7b4b67; //BuildingObject.deedObjectID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&deedObjectID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x27b0682d; //BuildingObject.accessFee
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&accessFee, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd12474b7; //BuildingObject.accessDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&accessDuration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe781d77d; //BuildingObject.paidAccessList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned long long, unsigned int> >::toBinaryStream(&paidAccessList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2f655877; //BuildingObject.childCreatureObjects
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<CreatureObject* > > >::toBinaryStream(&childCreatureObjects, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd1c7bb1c; //BuildingObject.publicStructure
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&publicStructure, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbd232a91; //BuildingObject.signName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<UnicodeString >::toBinaryStream(&signName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xff1529a2; //BuildingObject.isOwnerResidence
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&isOwnerResidence, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x164451a9; //BuildingObject.factionBaseType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&factionBaseType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void BuildingObjectImplementation::writeJSON(nlohmann::json& j) {
	StructureObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["cells"] = cells;

	thisObject["totalCellNumber"] = totalCellNumber;

	thisObject["signObject"] = signObject;

	thisObject["deedObjectID"] = deedObjectID;

	thisObject["accessFee"] = accessFee;

	thisObject["accessDuration"] = accessDuration;

	thisObject["paidAccessList"] = paidAccessList;

	thisObject["childCreatureObjects"] = childCreatureObjects;

	thisObject["publicStructure"] = publicStructure;

	thisObject["signName"] = signName;

	thisObject["isOwnerResidence"] = isOwnerResidence;

	thisObject["factionBaseType"] = factionBaseType;

	j["BuildingObject"] = thisObject;
}

BuildingObjectImplementation::BuildingObjectImplementation() {
	_initializeImplementation();
	Reference<CloseObjectsVector*> _ref0;
	// server/zone/objects/building/BuildingObject.idl():  		Logger.setLoggingName("BuildingObject");
	Logger::setLoggingName("BuildingObject");
	// server/zone/objects/building/BuildingObject.idl():  		super.closeobjects = new CloseObjectsVector();
	StructureObjectImplementation::closeobjects = _ref0 = new CloseObjectsVector();
	// server/zone/objects/building/BuildingObject.idl():  		super.closeobjects.setNoDuplicateInsertPlan();
	StructureObjectImplementation::closeobjects->setNoDuplicateInsertPlan();
	// server/zone/objects/building/BuildingObject.idl():  		super.staticObject = false;
	StructureObjectImplementation::staticObject = false;
	// server/zone/objects/building/BuildingObject.idl():  		totalCellNumber = 0;
	totalCellNumber = 0;
	// server/zone/objects/building/BuildingObject.idl():  		accessFee = 0;
	accessFee = 0;
	// server/zone/objects/building/BuildingObject.idl():  		accessDuration = 0;
	accessDuration = 0;
	// server/zone/objects/building/BuildingObject.idl():  		lastAccessFeeChange = 0;
	lastAccessFeeChange = 0;
	// server/zone/objects/building/BuildingObject.idl():  		deedObjectID = 0;
	deedObjectID = 0;
	// server/zone/objects/building/BuildingObject.idl():  		publicStructure = true;
	publicStructure = true;
	// server/zone/objects/building/BuildingObject.idl():  		signName = "";
	signName = "";
	// server/zone/objects/building/BuildingObject.idl():  		isOwnerResidence = false;
	isOwnerResidence = false;
	// server/zone/objects/building/BuildingObject.idl():  		factionBaseType = 0;
	factionBaseType = 0;
}

void BuildingObjectImplementation::setCustomObjectName(const UnicodeString& name, bool notifyClient) {
	// server/zone/objects/building/BuildingObject.idl():  		super.customName = name;
	StructureObjectImplementation::customName = name;
	// server/zone/objects/building/BuildingObject.idl():  		signName = name;
	signName = name;
	// server/zone/objects/building/BuildingObject.idl():  		updateSignName(notifyClient);
	updateSignName(notifyClient);
}

int BuildingObjectImplementation::notifyStructurePlaced(CreatureObject* player) {
	// server/zone/objects/building/BuildingObject.idl():  		return 0;
	return 0;
}

bool BuildingObjectImplementation::isStaticBuilding() const{
	// server/zone/objects/building/BuildingObject.idl():  		return super.staticObject;
	return StructureObjectImplementation::staticObject;
}

CellObject* BuildingObjectImplementation::getCell(unsigned int idx) {
	// server/zone/objects/building/BuildingObject.idl():  		return 
	if (idx == 0){
	// server/zone/objects/building/BuildingObject.idl():  			super.error("trying to get Cell with id = 0");
	StructureObjectImplementation::error("trying to get Cell with id = 0");
	// server/zone/objects/building/BuildingObject.idl():  			StackTrace.printStackTrace();
	StackTrace::printStackTrace();
}
	// server/zone/objects/building/BuildingObject.idl():  		return cells.get(idx);
	return (&cells)->get(idx);
}

int BuildingObjectImplementation::getTotalCellNumber() const{
	// server/zone/objects/building/BuildingObject.idl():  		return totalCellNumber;
	return totalCellNumber;
}

void BuildingObjectImplementation::setSignObject(SignObject* sign) {
	// server/zone/objects/building/BuildingObject.idl():  		signObject = sign;
	signObject = sign;
}

SignObject* BuildingObjectImplementation::getSignObject() const{
	// server/zone/objects/building/BuildingObject.idl():  		return signObject;
	return signObject;
}

bool BuildingObjectImplementation::isPublicStructure() const{
	// server/zone/objects/building/BuildingObject.idl():  		return publicStructure;
	return publicStructure;
}

bool BuildingObjectImplementation::isPrivateStructure() const{
	// server/zone/objects/building/BuildingObject.idl():  		return !publicStructure;
	return !publicStructure;
}

void BuildingObjectImplementation::setPublicStructure(bool privacy) {
	// server/zone/objects/building/BuildingObject.idl():  		publicStructure = privacy;
	publicStructure = privacy;
}

bool BuildingObjectImplementation::isCondemned() {
	// server/zone/objects/building/BuildingObject.idl():  		return super.isDecayed();
	return StructureObjectImplementation::isDecayed();
}

int BuildingObjectImplementation::getMapCellSize() const{
	// server/zone/objects/building/BuildingObject.idl():  		return cells.size();
	return (&cells)->size();
}

String BuildingObjectImplementation::getRedeedMessage() {
	// server/zone/objects/building/BuildingObject.idl():  		return 
	if (getCurrentNumberOfPlayerItems() > 0)	// server/zone/objects/building/BuildingObject.idl():  			return "clear_building_for_delete";
	return "clear_building_for_delete";
	// server/zone/objects/building/BuildingObject.idl():  		return "";
	return "";
}

bool BuildingObjectImplementation::hasAccessFee() const{
	// server/zone/objects/building/BuildingObject.idl():  		return accessFee > 0;
	return accessFee > 0;
}

int BuildingObjectImplementation::getAccessFee() const{
	// server/zone/objects/building/BuildingObject.idl():  		return accessFee;
	return accessFee;
}

void BuildingObjectImplementation::removeAccessFee() {
	// server/zone/objects/building/BuildingObject.idl():  		}
{
	Locker _locker((&paidAccessListMutex));
	// server/zone/objects/building/BuildingObject.idl():  			accessFee = 0;
	accessFee = 0;
	// server/zone/objects/building/BuildingObject.idl():  			accessDuration = 0;
	accessDuration = 0;
	// server/zone/objects/building/BuildingObject.idl():  			paidAccessList.removeAll();
	(&paidAccessList)->removeAll();
	// server/zone/objects/building/BuildingObject.idl():  			updatePaidAccessList();
	updatePaidAccessList();
}
}

bool BuildingObjectImplementation::isPlayerRegisteredWithin(unsigned long long id) const{
	// server/zone/objects/building/BuildingObject.idl():  		return registeredPlayerIdList.contains(id);
	return (&registeredPlayerIdList)->contains(id);
}

bool BuildingObjectImplementation::isResidence() const{
	// server/zone/objects/building/BuildingObject.idl():  		return isOwnerResidence;
	return isOwnerResidence;
}

void BuildingObjectImplementation::setResidence(bool isResidence) {
	// server/zone/objects/building/BuildingObject.idl():  		isOwnerResidence = isResidence;
	isOwnerResidence = isResidence;
}

int BuildingObjectImplementation::getFactionBaseType() const{
	// server/zone/objects/building/BuildingObject.idl():  		return factionBaseType;
	return factionBaseType;
}

/*
 *	BuildingObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


BuildingObjectAdapter::BuildingObjectAdapter(BuildingObject* obj) : StructureObjectAdapter(obj) {
}

void BuildingObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_CREATECELLOBJECTS__:
		{
			
			createCellObjects();
			
		}
		break;
	case RPC_DESTROYOBJECTFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyObjectFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_CREATECONTAINERCOMPONENT__:
		{
			
			createContainerComponent();
			
		}
		break;
	case RPC_SETCUSTOMOBJECTNAME__UNICODESTRING_BOOL_:
		{
			 UnicodeString name; inv->getUnicodeParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			setCustomObjectName(name, notifyClient);
			
		}
		break;
	case RPC_UPDATESIGNNAME__BOOL_:
		{
			bool notifyClient = inv->getBooleanParameter();
			
			updateSignName(notifyClient);
			
		}
		break;
	case RPC_SENDCONTAINEROBJECTSTO__SCENEOBJECT_BOOL_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			bool forceLoad = inv->getBooleanParameter();
			
			sendContainerObjectsTo(player, forceLoad);
			
		}
		break;
	case RPC_UPDATECELLPERMISSIONSTO__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			updateCellPermissionsTo(creature);
			
		}
		break;
	case RPC_BROADCASTCELLPERMISSIONS__:
		{
			
			broadcastCellPermissions();
			
		}
		break;
	case RPC_BROADCASTCELLPERMISSIONS__LONG_:
		{
			unsigned long long objectid = inv->getUnsignedLongParameter();
			
			broadcastCellPermissions(objectid);
			
		}
		break;
	case RPC_ISALLOWEDENTRY__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAllowedEntry(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCITYBANNED__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isCityBanned(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_NOTIFYSTRUCTUREPLACED__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			int _m_res = notifyStructurePlaced(player);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASTEMPLATEEJECTIONPOINT__:
		{
			
			bool _m_res = hasTemplateEjectionPoint();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_EJECTOBJECT__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			ejectObject(creature);
			
		}
		break;
	case RPC_NOTIFYREMOVEFROMZONE__:
		{
			
			notifyRemoveFromZone();
			
		}
		break;
	case RPC_NOTIFYINSERTTOZONE__ZONE_:
		{
			Zone* zone = static_cast<Zone*>(inv->getObjectParameter());
			
			notifyInsertToZone(zone);
			
		}
		break;
	case RPC_NOTIFYOBJECTINSERTEDTOZONE__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyObjectInsertedToZone(object);
			
		}
		break;
	case RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			bool doClose = inv->getBooleanParameter();
			bool forceLoadContainer = inv->getBooleanParameter();
			
			sendTo(player, doClose, forceLoadContainer);
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_SENDDESTROYTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendDestroyTo(player);
			
		}
		break;
	case RPC_ADDCELL__CELLOBJECT_INT_:
		{
			CellObject* cell = static_cast<CellObject*>(inv->getObjectParameter());
			unsigned int cellNumber = inv->getUnsignedIntParameter();
			
			addCell(cell, cellNumber);
			
		}
		break;
	case RPC_ISSTATICBUILDING__:
		{
			
			bool _m_res = isStaticBuilding();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCELL__INT_:
		{
			unsigned int idx = inv->getUnsignedIntParameter();
			
			DistributedObject* _m_res = getCell(idx);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETCELL__STRING_:
		{
			 String cellName; inv->getAsciiParameter(cellName);
			
			DistributedObject* _m_res = getCell(cellName);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETTOTALCELLNUMBER__:
		{
			
			int _m_res = getTotalCellNumber();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYOBJECTINSERTEDTOCHILD__SCENEOBJECT_SCENEOBJECT_SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			SceneObject* child = static_cast<SceneObject*>(inv->getObjectParameter());
			SceneObject* oldParent = static_cast<SceneObject*>(inv->getObjectParameter());
			
			int _m_res = notifyObjectInsertedToChild(object, child, oldParent);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYOBJECTREMOVEDFROMCHILD__SCENEOBJECT_SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			SceneObject* child = static_cast<SceneObject*>(inv->getObjectParameter());
			
			int _m_res = notifyObjectRemovedFromChild(object, child);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCURRENTNUMBEROFPLAYERITEMS__:
		{
			
			int _m_res = getCurrentNumberOfPlayerItems();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DESTROYALLPLAYERITEMS__:
		{
			
			destroyAllPlayerItems();
			
		}
		break;
	case RPC_ONENTER__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			onEnter(player);
			
		}
		break;
	case RPC_ONEXIT__CREATUREOBJECT_LONG_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long parentid = inv->getUnsignedLongParameter();
			
			onExit(player, parentid);
			
		}
		break;
	case RPC_SETSIGNOBJECT__SIGNOBJECT_:
		{
			SignObject* sign = static_cast<SignObject*>(inv->getObjectParameter());
			
			setSignObject(sign);
			
		}
		break;
	case RPC_GETSIGNOBJECT__:
		{
			
			DistributedObject* _m_res = getSignObject();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_ISPUBLICSTRUCTURE__:
		{
			
			bool _m_res = isPublicStructure();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPRIVATESTRUCTURE__:
		{
			
			bool _m_res = isPrivateStructure();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETPUBLICSTRUCTURE__BOOL_:
		{
			bool privacy = inv->getBooleanParameter();
			
			setPublicStructure(privacy);
			
		}
		break;
	case RPC_ISCONDEMNED__:
		{
			
			bool _m_res = isCondemned();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETMAPCELLSIZE__:
		{
			
			int _m_res = getMapCellSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_TOGGLEPRIVACY__:
		{
			
			bool _m_res = togglePrivacy();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETMAXIMUMNUMBEROFPLAYERITEMS__:
		{
			
			unsigned int _m_res = getMaximumNumberOfPlayerItems();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETREDEEDMESSAGE__:
		{
			
			String _m_res = getRedeedMessage();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_HASACCESSFEE__:
		{
			
			bool _m_res = hasAccessFee();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETACCESSFEE__:
		{
			
			int _m_res = getAccessFee();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CANCHANGEACCESSFEE__:
		{
			
			bool _m_res = canChangeAccessFee();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETACCESSFEE__INT_INT_:
		{
			int fee = inv->getSignedIntParameter();
			int duration = inv->getSignedIntParameter();
			
			setAccessFee(fee, duration);
			
		}
		break;
	case RPC_REMOVEACCESSFEE__:
		{
			
			removeAccessFee();
			
		}
		break;
	case RPC_GETACCESSFEEDELAY__:
		{
			
			int _m_res = getAccessFeeDelay();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_PAYACCESSFEE__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			payAccessFee(player);
			
		}
		break;
	case RPC_UPDATEPAIDACCESSLIST__:
		{
			
			updatePaidAccessList();
			
		}
		break;
	case RPC_REGISTERPROFESSIONAL__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			registerProfessional(player);
			
		}
		break;
	case RPC_UNREGISTERPROFESSIONAL__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			unregisterProfessional(player);
			
		}
		break;
	case RPC_ISINPLAYERCITY__:
		{
			
			bool _m_res = isInPlayerCity();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANPLAYERREGISTERWITHIN__:
		{
			
			bool _m_res = canPlayerRegisterWithin();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPLAYERREGISTEREDWITHIN__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			bool _m_res = isPlayerRegisteredWithin(id);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CREATECHILDOBJECTS__:
		{
			
			createChildObjects();
			
		}
		break;
	case RPC_SPAWNCHILDCREATURESFROMTEMPLATE__:
		{
			
			spawnChildCreaturesFromTemplate();
			
		}
		break;
	case RPC_HASTEMPLATECHILDCREATURES__:
		{
			
			bool _m_res = hasTemplateChildCreatures();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_DESTROYCHILDOBJECTS__:
		{
			
			destroyChildObjects();
			
		}
		break;
	case RPC_ISRESIDENCE__:
		{
			
			bool _m_res = isResidence();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETRESIDENCE__BOOL_:
		{
			bool isResidence = inv->getBooleanParameter();
			
			setResidence(isResidence);
			
		}
		break;
	case RPC_GETFACTIONBASETYPE__:
		{
			
			int _m_res = getFactionBaseType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETOUTOFRANGEDISTANCE__:
		{
			
			float _m_res = getOutOfRangeDistance();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCELLNAME__LONG_:
		{
			unsigned long long cellID = inv->getUnsignedLongParameter();
			
			String _m_res = getCellName(cellID);
			resp->insertAscii(_m_res);
		}
		break;
	default:
		StructureObjectAdapter::invokeMethod(methid, inv);
	}
}

void BuildingObjectAdapter::createCellObjects() {
	(static_cast<BuildingObject*>(stub))->createCellObjects();
}

void BuildingObjectAdapter::destroyObjectFromDatabase(bool destroyContainedObjects) {
	(static_cast<BuildingObject*>(stub))->destroyObjectFromDatabase(destroyContainedObjects);
}

void BuildingObjectAdapter::initializeTransientMembers() {
	(static_cast<BuildingObject*>(stub))->initializeTransientMembers();
}

void BuildingObjectAdapter::createContainerComponent() {
	(static_cast<BuildingObject*>(stub))->createContainerComponent();
}

void BuildingObjectAdapter::setCustomObjectName(const UnicodeString& name, bool notifyClient) {
	(static_cast<BuildingObject*>(stub))->setCustomObjectName(name, notifyClient);
}

void BuildingObjectAdapter::updateSignName(bool notifyClient) {
	(static_cast<BuildingObject*>(stub))->updateSignName(notifyClient);
}

void BuildingObjectAdapter::sendContainerObjectsTo(SceneObject* player, bool forceLoad) {
	(static_cast<BuildingObject*>(stub))->sendContainerObjectsTo(player, forceLoad);
}

void BuildingObjectAdapter::updateCellPermissionsTo(CreatureObject* creature) {
	(static_cast<BuildingObject*>(stub))->updateCellPermissionsTo(creature);
}

void BuildingObjectAdapter::broadcastCellPermissions() {
	(static_cast<BuildingObject*>(stub))->broadcastCellPermissions();
}

void BuildingObjectAdapter::broadcastCellPermissions(unsigned long long objectid) {
	(static_cast<BuildingObject*>(stub))->broadcastCellPermissions(objectid);
}

bool BuildingObjectAdapter::isAllowedEntry(CreatureObject* player) {
	return (static_cast<BuildingObject*>(stub))->isAllowedEntry(player);
}

bool BuildingObjectAdapter::isCityBanned(CreatureObject* player) {
	return (static_cast<BuildingObject*>(stub))->isCityBanned(player);
}

int BuildingObjectAdapter::notifyStructurePlaced(CreatureObject* player) {
	return (static_cast<BuildingObject*>(stub))->notifyStructurePlaced(player);
}

bool BuildingObjectAdapter::hasTemplateEjectionPoint() {
	return (static_cast<BuildingObject*>(stub))->hasTemplateEjectionPoint();
}

void BuildingObjectAdapter::ejectObject(CreatureObject* creature) {
	(static_cast<BuildingObject*>(stub))->ejectObject(creature);
}

void BuildingObjectAdapter::notifyRemoveFromZone() {
	(static_cast<BuildingObject*>(stub))->notifyRemoveFromZone();
}

void BuildingObjectAdapter::notifyInsertToZone(Zone* zone) {
	(static_cast<BuildingObject*>(stub))->notifyInsertToZone(zone);
}

void BuildingObjectAdapter::notifyObjectInsertedToZone(SceneObject* object) {
	(static_cast<BuildingObject*>(stub))->notifyObjectInsertedToZone(object);
}

void BuildingObjectAdapter::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	(static_cast<BuildingObject*>(stub))->sendTo(player, doClose, forceLoadContainer);
}

void BuildingObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<BuildingObject*>(stub))->sendBaselinesTo(player);
}

void BuildingObjectAdapter::sendDestroyTo(SceneObject* player) {
	(static_cast<BuildingObject*>(stub))->sendDestroyTo(player);
}

void BuildingObjectAdapter::addCell(CellObject* cell, unsigned int cellNumber) {
	(static_cast<BuildingObject*>(stub))->addCell(cell, cellNumber);
}

bool BuildingObjectAdapter::isStaticBuilding() const {
	return (static_cast<BuildingObject*>(stub))->isStaticBuilding();
}

CellObject* BuildingObjectAdapter::getCell(unsigned int idx) {
	return (static_cast<BuildingObject*>(stub))->getCell(idx);
}

CellObject* BuildingObjectAdapter::getCell(const String& cellName) {
	return (static_cast<BuildingObject*>(stub))->getCell(cellName);
}

int BuildingObjectAdapter::getTotalCellNumber() const {
	return (static_cast<BuildingObject*>(stub))->getTotalCellNumber();
}

int BuildingObjectAdapter::notifyObjectInsertedToChild(SceneObject* object, SceneObject* child, SceneObject* oldParent) {
	return (static_cast<BuildingObject*>(stub))->notifyObjectInsertedToChild(object, child, oldParent);
}

int BuildingObjectAdapter::notifyObjectRemovedFromChild(SceneObject* object, SceneObject* child) {
	return (static_cast<BuildingObject*>(stub))->notifyObjectRemovedFromChild(object, child);
}

int BuildingObjectAdapter::getCurrentNumberOfPlayerItems() {
	return (static_cast<BuildingObject*>(stub))->getCurrentNumberOfPlayerItems();
}

void BuildingObjectAdapter::destroyAllPlayerItems() {
	(static_cast<BuildingObject*>(stub))->destroyAllPlayerItems();
}

void BuildingObjectAdapter::onEnter(CreatureObject* player) {
	(static_cast<BuildingObject*>(stub))->onEnter(player);
}

void BuildingObjectAdapter::onExit(CreatureObject* player, unsigned long long parentid) {
	(static_cast<BuildingObject*>(stub))->onExit(player, parentid);
}

void BuildingObjectAdapter::setSignObject(SignObject* sign) {
	(static_cast<BuildingObject*>(stub))->setSignObject(sign);
}

SignObject* BuildingObjectAdapter::getSignObject() const {
	return (static_cast<BuildingObject*>(stub))->getSignObject();
}

bool BuildingObjectAdapter::isPublicStructure() const {
	return (static_cast<BuildingObject*>(stub))->isPublicStructure();
}

bool BuildingObjectAdapter::isPrivateStructure() const {
	return (static_cast<BuildingObject*>(stub))->isPrivateStructure();
}

void BuildingObjectAdapter::setPublicStructure(bool privacy) {
	(static_cast<BuildingObject*>(stub))->setPublicStructure(privacy);
}

bool BuildingObjectAdapter::isCondemned() {
	return (static_cast<BuildingObject*>(stub))->isCondemned();
}

int BuildingObjectAdapter::getMapCellSize() const {
	return (static_cast<BuildingObject*>(stub))->getMapCellSize();
}

bool BuildingObjectAdapter::togglePrivacy() {
	return (static_cast<BuildingObject*>(stub))->togglePrivacy();
}

unsigned int BuildingObjectAdapter::getMaximumNumberOfPlayerItems() {
	return (static_cast<BuildingObject*>(stub))->getMaximumNumberOfPlayerItems();
}

String BuildingObjectAdapter::getRedeedMessage() {
	return (static_cast<BuildingObject*>(stub))->getRedeedMessage();
}

bool BuildingObjectAdapter::hasAccessFee() const {
	return (static_cast<BuildingObject*>(stub))->hasAccessFee();
}

int BuildingObjectAdapter::getAccessFee() const {
	return (static_cast<BuildingObject*>(stub))->getAccessFee();
}

bool BuildingObjectAdapter::canChangeAccessFee() {
	return (static_cast<BuildingObject*>(stub))->canChangeAccessFee();
}

void BuildingObjectAdapter::setAccessFee(int fee, int duration) {
	(static_cast<BuildingObject*>(stub))->setAccessFee(fee, duration);
}

void BuildingObjectAdapter::removeAccessFee() {
	(static_cast<BuildingObject*>(stub))->removeAccessFee();
}

int BuildingObjectAdapter::getAccessFeeDelay() {
	return (static_cast<BuildingObject*>(stub))->getAccessFeeDelay();
}

void BuildingObjectAdapter::payAccessFee(CreatureObject* player) {
	(static_cast<BuildingObject*>(stub))->payAccessFee(player);
}

void BuildingObjectAdapter::updatePaidAccessList() {
	(static_cast<BuildingObject*>(stub))->updatePaidAccessList();
}

void BuildingObjectAdapter::registerProfessional(CreatureObject* player) {
	(static_cast<BuildingObject*>(stub))->registerProfessional(player);
}

void BuildingObjectAdapter::unregisterProfessional(CreatureObject* player) {
	(static_cast<BuildingObject*>(stub))->unregisterProfessional(player);
}

bool BuildingObjectAdapter::isInPlayerCity() {
	return (static_cast<BuildingObject*>(stub))->isInPlayerCity();
}

bool BuildingObjectAdapter::canPlayerRegisterWithin() {
	return (static_cast<BuildingObject*>(stub))->canPlayerRegisterWithin();
}

bool BuildingObjectAdapter::isPlayerRegisteredWithin(unsigned long long id) const {
	return (static_cast<BuildingObject*>(stub))->isPlayerRegisteredWithin(id);
}

void BuildingObjectAdapter::createChildObjects() {
	(static_cast<BuildingObject*>(stub))->createChildObjects();
}

void BuildingObjectAdapter::spawnChildCreaturesFromTemplate() {
	(static_cast<BuildingObject*>(stub))->spawnChildCreaturesFromTemplate();
}

bool BuildingObjectAdapter::hasTemplateChildCreatures() const {
	return (static_cast<BuildingObject*>(stub))->hasTemplateChildCreatures();
}

void BuildingObjectAdapter::destroyChildObjects() {
	(static_cast<BuildingObject*>(stub))->destroyChildObjects();
}

bool BuildingObjectAdapter::isResidence() const {
	return (static_cast<BuildingObject*>(stub))->isResidence();
}

void BuildingObjectAdapter::setResidence(bool isResidence) {
	(static_cast<BuildingObject*>(stub))->setResidence(isResidence);
}

int BuildingObjectAdapter::getFactionBaseType() const {
	return (static_cast<BuildingObject*>(stub))->getFactionBaseType();
}

float BuildingObjectAdapter::getOutOfRangeDistance() const {
	return (static_cast<BuildingObject*>(stub))->getOutOfRangeDistance();
}

String BuildingObjectAdapter::getCellName(unsigned long long cellID) const {
	return (static_cast<BuildingObject*>(stub))->getCellName(cellID);
}

/*
 *	BuildingObjectHelper
 */

BuildingObjectHelper* BuildingObjectHelper::staticInitializer = BuildingObjectHelper::instance();

BuildingObjectHelper::BuildingObjectHelper() {
	className = "BuildingObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void BuildingObjectHelper::finalizeHelper() {
	BuildingObjectHelper::finalize();
}

DistributedObject* BuildingObjectHelper::instantiateObject() {
	return new BuildingObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* BuildingObjectHelper::instantiateServant() {
	return new BuildingObjectImplementation();
}

DistributedObjectPOD* BuildingObjectHelper::instantiatePOD() {
	return new BuildingObjectPOD();
}

DistributedObjectAdapter* BuildingObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new BuildingObjectAdapter(static_cast<BuildingObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	BuildingObjectPOD
 */

BuildingObjectPOD::~BuildingObjectPOD() {
	finalize();
}

BuildingObjectPOD::BuildingObjectPOD(void) {
	_className = "BuildingObject";
}


void BuildingObjectPOD::writeJSON(nlohmann::json& j) {
	StructureObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (cells)
		thisObject["cells"] = cells.value();

	if (totalCellNumber)
		thisObject["totalCellNumber"] = totalCellNumber.value();

	if (signObject)
		thisObject["signObject"] = signObject.value();

	if (deedObjectID)
		thisObject["deedObjectID"] = deedObjectID.value();

	if (accessFee)
		thisObject["accessFee"] = accessFee.value();

	if (accessDuration)
		thisObject["accessDuration"] = accessDuration.value();

	if (paidAccessList)
		thisObject["paidAccessList"] = paidAccessList.value();

	if (childCreatureObjects)
		thisObject["childCreatureObjects"] = childCreatureObjects.value();

	if (publicStructure)
		thisObject["publicStructure"] = publicStructure.value();

	if (signName)
		thisObject["signName"] = signName.value();

	if (isOwnerResidence)
		thisObject["isOwnerResidence"] = isOwnerResidence.value();

	if (factionBaseType)
		thisObject["factionBaseType"] = factionBaseType.value();

	j["BuildingObject"] = thisObject;
}


void BuildingObjectPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = BuildingObjectPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int BuildingObjectPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = StructureObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (cells) {
	_nameHashCode = 0x20f3b6a6; //BuildingObject.cells
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, ManagedReference<CellObjectPOD* > > >::toBinaryStream(&cells.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (totalCellNumber) {
	_nameHashCode = 0x38fc81b9; //BuildingObject.totalCellNumber
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&totalCellNumber.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (signObject) {
	_nameHashCode = 0xd3b1e837; //BuildingObject.signObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<SignObjectPOD* > >::toBinaryStream(&signObject.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (deedObjectID) {
	_nameHashCode = 0xa7b4b67; //BuildingObject.deedObjectID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&deedObjectID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (accessFee) {
	_nameHashCode = 0x27b0682d; //BuildingObject.accessFee
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&accessFee.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (accessDuration) {
	_nameHashCode = 0xd12474b7; //BuildingObject.accessDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&accessDuration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (paidAccessList) {
	_nameHashCode = 0xe781d77d; //BuildingObject.paidAccessList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned long long, unsigned int> >::toBinaryStream(&paidAccessList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (childCreatureObjects) {
	_nameHashCode = 0x2f655877; //BuildingObject.childCreatureObjects
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<CreatureObjectPOD* > > >::toBinaryStream(&childCreatureObjects.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (publicStructure) {
	_nameHashCode = 0xd1c7bb1c; //BuildingObject.publicStructure
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&publicStructure.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (signName) {
	_nameHashCode = 0xbd232a91; //BuildingObject.signName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<UnicodeString >::toBinaryStream(&signName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (isOwnerResidence) {
	_nameHashCode = 0xff1529a2; //BuildingObject.isOwnerResidence
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&isOwnerResidence.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (factionBaseType) {
	_nameHashCode = 0x164451a9; //BuildingObject.factionBaseType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&factionBaseType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool BuildingObjectPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (StructureObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x20f3b6a6: //BuildingObject.cells
		{
			VectorMap<unsigned int, ManagedReference<CellObjectPOD* > > _mncells;
			TypeInfo<VectorMap<unsigned int, ManagedReference<CellObjectPOD* > > >::parseFromBinaryStream(&_mncells, stream);
			cells = std::move(_mncells);
		}
		return true;

	case 0x38fc81b9: //BuildingObject.totalCellNumber
		{
			int _mntotalCellNumber;
			TypeInfo<int >::parseFromBinaryStream(&_mntotalCellNumber, stream);
			totalCellNumber = std::move(_mntotalCellNumber);
		}
		return true;

	case 0xd3b1e837: //BuildingObject.signObject
		{
			ManagedReference<SignObjectPOD* > _mnsignObject;
			TypeInfo<ManagedReference<SignObjectPOD* > >::parseFromBinaryStream(&_mnsignObject, stream);
			signObject = std::move(_mnsignObject);
		}
		return true;

	case 0xa7b4b67: //BuildingObject.deedObjectID
		{
			unsigned long long _mndeedObjectID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mndeedObjectID, stream);
			deedObjectID = std::move(_mndeedObjectID);
		}
		return true;

	case 0x27b0682d: //BuildingObject.accessFee
		{
			int _mnaccessFee;
			TypeInfo<int >::parseFromBinaryStream(&_mnaccessFee, stream);
			accessFee = std::move(_mnaccessFee);
		}
		return true;

	case 0xd12474b7: //BuildingObject.accessDuration
		{
			int _mnaccessDuration;
			TypeInfo<int >::parseFromBinaryStream(&_mnaccessDuration, stream);
			accessDuration = std::move(_mnaccessDuration);
		}
		return true;

	case 0xe781d77d: //BuildingObject.paidAccessList
		{
			VectorMap<unsigned long long, unsigned int> _mnpaidAccessList;
			TypeInfo<VectorMap<unsigned long long, unsigned int> >::parseFromBinaryStream(&_mnpaidAccessList, stream);
			paidAccessList = std::move(_mnpaidAccessList);
		}
		return true;

	case 0x2f655877: //BuildingObject.childCreatureObjects
		{
			SortedVector<ManagedReference<CreatureObjectPOD* > > _mnchildCreatureObjects;
			TypeInfo<SortedVector<ManagedReference<CreatureObjectPOD* > > >::parseFromBinaryStream(&_mnchildCreatureObjects, stream);
			childCreatureObjects = std::move(_mnchildCreatureObjects);
		}
		return true;

	case 0xd1c7bb1c: //BuildingObject.publicStructure
		{
			bool _mnpublicStructure;
			TypeInfo<bool >::parseFromBinaryStream(&_mnpublicStructure, stream);
			publicStructure = std::move(_mnpublicStructure);
		}
		return true;

	case 0xbd232a91: //BuildingObject.signName
		{
			UnicodeString _mnsignName;
			TypeInfo<UnicodeString >::parseFromBinaryStream(&_mnsignName, stream);
			signName = std::move(_mnsignName);
		}
		return true;

	case 0xff1529a2: //BuildingObject.isOwnerResidence
		{
			bool _mnisOwnerResidence;
			TypeInfo<bool >::parseFromBinaryStream(&_mnisOwnerResidence, stream);
			isOwnerResidence = std::move(_mnisOwnerResidence);
		}
		return true;

	case 0x164451a9: //BuildingObject.factionBaseType
		{
			int _mnfactionBaseType;
			TypeInfo<int >::parseFromBinaryStream(&_mnfactionBaseType, stream);
			factionBaseType = std::move(_mnfactionBaseType);
		}
		return true;

	}

	return false;
}

void BuildingObjectPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(BuildingObjectPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void BuildingObjectPOD::writeObjectCompact(ObjectOutputStream* stream) {
	StructureObjectPOD::writeObjectCompact(stream);

	TypeInfo<VectorMap<unsigned int, ManagedReference<CellObjectPOD* > > >::toBinaryStream(&cells.value(), stream);

	TypeInfo<int >::toBinaryStream(&totalCellNumber.value(), stream);

	TypeInfo<ManagedReference<SignObjectPOD* > >::toBinaryStream(&signObject.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&deedObjectID.value(), stream);

	TypeInfo<int >::toBinaryStream(&accessFee.value(), stream);

	TypeInfo<int >::toBinaryStream(&accessDuration.value(), stream);

	TypeInfo<VectorMap<unsigned long long, unsigned int> >::toBinaryStream(&paidAccessList.value(), stream);

	TypeInfo<SortedVector<ManagedReference<CreatureObjectPOD* > > >::toBinaryStream(&childCreatureObjects.value(), stream);

	TypeInfo<bool >::toBinaryStream(&publicStructure.value(), stream);

	TypeInfo<UnicodeString >::toBinaryStream(&signName.value(), stream);

	TypeInfo<bool >::toBinaryStream(&isOwnerResidence.value(), stream);

	TypeInfo<int >::toBinaryStream(&factionBaseType.value(), stream);


}

