/*
 *	autogen/server/zone/objects/creature/ai/AiAgent.h generated by engine3 IDL compiler 0.70
 */

#ifndef AIAGENT_H_
#define AIAGENT_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace zone {

class Zone;

class ZonePOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace events {

class AiThinkEvent;

} // namespace events
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::events;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace events {

class AiMoveEvent;

} // namespace events
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::events;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace events {

class AiWaitEvent;

} // namespace events
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::events;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace events {

class AiAwarenessEvent;

} // namespace events
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::events;

namespace server {
namespace zone {
namespace packets {
namespace scene {

class AttributeListMessage;

} // namespace scene
} // namespace packets
} // namespace zone
} // namespace server

using namespace server::zone::packets::scene;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace weapon {

class WeaponObject;

class WeaponObjectPOD;

} // namespace weapon
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::weapon;

namespace server {
namespace zone {

class QuadTreeEntry;

class QuadTreeEntryPOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace tangible {

class TangibleObject;

class TangibleObjectPOD;

} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class CreatureTemplate;

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace events {

class DespawnCreatureOnPlayerDissappear;

} // namespace events
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::events;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace bt {

class Behavior;

} // namespace bt
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::bt;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace bt {

class CompositeBehavior;

} // namespace bt
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::bt;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace events {

class AiTrackingTask;

} // namespace events
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::events;

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObject;

class SceneObjectPOD;

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

#include "gmock/gmock.h"

#include "server/zone/objects/creature/ai/PatrolPointsVector.h"

#include "server/zone/objects/creature/ai/PatrolPoint.h"

#include "templates/SharedObjectTemplate.h"

#include "server/zone/objects/creature/ai/variables/CreatureAttackMap.h"

#include "system/thread/Mutex.h"

#include "server/zone/managers/loot/lootgroup/LootGroupCollection.h"

#include "server/zone/objects/creature/ai/variables/CreatureTemplateReference.h"

#include "system/thread/ReadWriteLock.h"

#include "server/zone/objects/creature/ai/variables/CurrentFoundPath.h"

#include "templates/AiTemplate.h"

#include "server/zone/objects/tangible/deed/pet/PetDeed.h"

#include "server/zone/objects/cell/CellObject.h"

#include "system/util/VectorMap.h"

#include "engine/util/u3d/Vector3.h"

#include "system/util/Vector.h"

#include "system/lang/Time.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "engine/core/ManagedObject.h"

#include "engine/util/Observable.h"

#include "system/thread/atomic/AtomicInteger.h"

#include "system/util/SortedVector.h"

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class AiAgent : public CreatureObject {
public:
	static const int UPDATEMOVEMENTINTERVAL = 500;

	static const int DEFAULTAGGRORADIUS = 24;

	static const int OBLIVIOUS = 0;

	static const int WATCHING = 1;

	static const int STALKING = 2;

	static const int FOLLOWING = 3;

	static const int PATROLLING = 4;

	static const int FLEEING = 5;

	static const int LEASHING = 6;

	AiAgent();

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	/**
	 * Schedules the next recovery event
	 * @pre { at least this is locked }
	 * @post { at least this is locked }
	 */
	void activateRecovery();

	/**
	 * Schedules the next movement event
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void activateMovementEvent();

	/**
	 * Schedules the next wait event
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void activateWaitEvent();

	/**
	 * Schedules an event to check awareness
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void activateAwarenessEvent(unsigned long long delay = 1000);

	/**
	 * Executes an AI interrupt in a separate thread (to shed locks)
	 * @pre { }
	 * @post { }
	 */
	void activateInterrupt(SceneObject* source, long long msg);

	/**
	 * Schedules the loading
	 * @pre { }
	 * @post { }
	 */
	void activateLoad(const String& temp);

	/**
	 * Does a recovery tick
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param latency The amount of time since the last recovery event
	 */
	void doRecovery(int latency);

	/**
	 * Does the main AI update tick
	 * @pre { this object is locked }
	 * @post { this object is locked, this AI will have performed one update tick }
	 */
	void doMovement();

	void setLevel(int lvl, bool randomHam = true);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines
	 */
	void sendBaselinesTo(SceneObject* player);

	int calculateAttackMinDamage(int level);

	int calculateAttackMaxDamage(int level);

	float calculateAttackSpeed(int level);

	SceneObject* getTargetFromMap();

	SceneObject* getTargetFromDefenders();

	SceneObject* getTargetFromTargetsDefenders();

	bool validateTarget();

	bool validateTarget(SceneObject* target);

	bool isCamouflaged(CreatureObject* target);

	bool findNextPosition(float maxDistance, bool walk = false);

	float getWorldZ(const Vector3& position);

	/**
	 * Does the AI awareness update tick
	 * @pre { this is locked }
	 * @post { this is locked, this AI will have scheduled one awareness check }
	 */
	void doAwarenessCheck();

	bool runAwarenessLogicCheck(SceneObject* pObject);

	void runStartAwarenessInterrupt(SceneObject* pObject);

	int checkForReactionChat(SceneObject* pObject);

	/**
	 * Handles the radial selection sent by the client, must be overriden by inherited objects
	 * @pre { this object is locked, player is locked }
	 * @post { this object is locked, player is locked }
	 * @param player CreatureObject that selected the option
	 * @param selectedID selected menu id
	 * @returns 0 if successfull
	 */
	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void checkNewAngle();

	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	void setNextPosition(float x, float z, float y, CellObject* cell = NULL);

	void setNextStepPosition(float x, float z, float y, CellObject* cell = NULL);

	void notifyPositionUpdate(QuadTreeEntry* entry);

	void updateCurrentPosition(PatrolPoint* point);

	void broadcastNextPositionUpdate(PatrolPoint* point);

	void clearPatrolPoints();

	void clearSavedPatrolPoints();

	void setPatrolPoints(PatrolPointsVector& pVector);

	PatrolPoint getNextPosition();

	int getPatrolPointSize();

	void notifyInsert(QuadTreeEntry* entry);

	void notifyDissapear(QuadTreeEntry* entry);

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	void loadTemplateData(CreatureTemplate* templateData);

	void setupAttackMaps();

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient = true, bool isCombatAction = false);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient = true, bool isCombatAction = false);

	int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0);

	/**
	 * sends the conversation notification
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 * @return whether the conversation was started or not
	 */
	bool sendConversationStartTo(SceneObject* player);

	/**
	 * sends the default conversation list
	 * @pre {this locked, player locked }
	 * @post {this locked, player locked }
	 */
	void sendDefaultConversationTo(SceneObject* player);

	/**
	 * sends the conversation list
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	void selectConversationOption(int option, SceneObject* obj);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	/**
	 * Is called when an object is talked to
	 * @pre { this, converser locked }
	 * @post {this, converser locked }
	 */
	int notifyConverseObservers(CreatureObject* converser);

	int notifyAttack(Observable* observable);

	int notifyCallForHelp(Observable* observable, ManagedObject* arg1);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	void destroyObjectFromDatabase(bool destroyContainedObjects = false);

	void activatePostureRecovery();

	void activateHAMRegeneration(int latency);

	void queueDizzyFallEvent();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	void clearCombatState(bool clearDefenders = true);

	/**
	 * Sets the active defender
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is active }
	 * @param defender SceneObject to set as the active defender
	 */
	void setDefender(SceneObject* defender);

	/**
	 * Adds a SceneObject to the defender vector
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is in the defender vector }
	 * @param defender SceneObject to add to the defender vector
	 */
	void addDefender(SceneObject* defender);

	/**
	 * Removes the specified defender from the defender vector
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is not in the defender vector }
	 * @param defender SceneObject to remove from the defender vector
	 */
	void removeDefender(SceneObject* defender);

	void setDespawnOnNoPlayerInRange(bool val);

	/**
	 * Gets called when the creature was despawned
	 */
	void notifyDespawn(Zone* zone);

	void scheduleDespawn();

	/**
	 * Schedules despawn of the AiAgent.
	 * @param timeToDespawn the time to despawn the AiAgent in seconds.
	 */
	void scheduleDespawn(int timeToDespawn);

	/**
	 * Respawns creature to specified zone with home location position
	 */
	void respawn(Zone* zone, int level);

	void addPatrolPoint(PatrolPoint& point);

	void setHomeLocation(float x, float z, float y, CellObject* cell = NULL);

	void setRespawnTimer(float resp);

	void setRandomRespawn(bool resp);

	void resetRespawnCounter();

	/**
	 * Evaluates if this can be attacked by object
	 * @pre { }
	 * @post { }
	 * @return returns true if object can attack this
	 */
	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* object);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	bool isAggressiveTo(CreatureObject* object);

	void setOblivious();

	void setWatchObject(SceneObject* obj);

	void setStalkObject(SceneObject* obj);

	void setFollowObject(SceneObject* obj);

	void setTargetObject(SceneObject* obj);

	void runAway(CreatureObject* target, float range);

	void leash();

	bool generatePatrol(int num, float dist);

	ManagedWeakReference<SceneObject* > getFollowObject();

	void storeFollowObject();

	void restoreFollowObject();

	unsigned int getFollowState() const;

	void setFollowState(int state);

	float getMaxDistance();

	int setDestination();

	bool completeMove();

	void setWait(int wait);

	int getWait() const;

	bool isWaiting() const;

	/**
	 * Sets the waiting variable to false, which determines if an action can be performed
	 * @pre { the AI is locked }
	 * @post { the AI is locked, and ready to perform an action }
	 */
	void stopWaiting();

	void selectWeapon();

	void selectDefaultWeapon();

	bool validateStateAttack(CreatureObject* target, unsigned int actionCRC);

	void selectSpecialAttack();

	void selectSpecialAttack(int attackNum);

	void selectDefaultAttack();

	bool validateStateAttack();

	void enqueueAttack(int priority = -1);

	bool isRetreating();

	bool isFleeing();

	void clearDespawnEvent();

	float getKinetic();

	float getEnergy();

	float getElectricity();

	float getStun();

	float getBlast();

	float getHeat();

	float getCold();

	float getAcid();

	float getLightSaber();

	bool isSpecialProtection(int resistType);

	bool isStalker();

	bool isKiller();

	unsigned int getFerocity();

	int getAggroRadius();

	unsigned int getArmor();

	bool getDespawnOnNoPlayerInRange() const;

	int getNumberOfPlayersInRange();

	String getFactionString();

	String getSocialGroup();

	float getChanceHit();

	int getDamageMin();

	int getDamageMax();

	float getSpecialDamageMult();

	int getBaseXp();

	unsigned int getDiet();

	unsigned int getTemplateLevel() const;

	float getTame() const;

	const CreatureAttackMap* getAttackMap();

	const LootGroupCollection* getLootGroups();

	String getReactionStf();

	float getRespawnTimer() const;

	bool getRandomRespawn() const;

	int getRespawnCounter() const;

	PatrolPoint* getHomeLocation();

	bool isAiAgent();

	AiAgent* asAiAgent();

	const CreatureTemplate* getCreatureTemplate() const;

	bool hasLoot();

	void setShowNextPosition(bool val);

	bool isEventMob();

	bool isPet() const;

	/**
	 * Sets up the behavior based on the creature bitmask
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void setupBehaviorTree();

	/**
	 * Sets up the behavior tree by forcing a template into it
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param aiTemplate the template to load
	 */
	void setupBehaviorTree(AiTemplate* aiTemplate);

	/**
	 * Helper function for setting up the behavior tree from bitmask
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param getTarget Template for target selection
	 * @param selectAttack Template for attack selection
	 * @param combatMove Template for movement when in combat
	 * @param idle Template for idle behavior
	 */
	void setupBehaviorTree(AiTemplate* getTarget, AiTemplate* selectAttack, AiTemplate* combatMove, AiTemplate* idle);

	/**
	 * Sets the behavior in the tree
	 * @pre { this is locked }
	 * @post { this is locked, behavior is set }
	 * @param b the id of the behavior in the tree
	 */
	void setCurrentBehavior(unsigned int b);

	unsigned int getCurrentBehavior() const;

	int getBehaviorStatus();

	void setBehaviorStatus(int status);

	/**
	 * Resets the behavior list to the default position
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void resetBehaviorList();

	void clearBehaviorList();

	/**
	 * Executes an interrupt called from a new thread
	 * @pre { this is locked, source is locked }
	 * @post { this is locked, source is locked }
	 * @param source The originator of the interrupt call
	 * @param msg The long id of the message (argument) of the interrupt
	 */
	int interrupt(SceneObject* source, long long msg);

	void broadcastInterrupt(long long msg);

	void setHomeObject(SceneObject* home);

	ManagedWeakReference<SceneObject* > getHomeObject() const;

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	void setCombatState();

	int getCreatureBitmask() const;

	void setCreatureBitmask(int mask);

	void setCreatureBit(unsigned int option);

	void clearCreatureBit(unsigned int option);

	Time* getAlertedTime();

	void incrementLuaCall(const String& key);

	void addToLuaTime(const String& key, unsigned long long val);

	void outputLuaTimes(CreatureObject* caller);

	void rescheduleTrackingTask();

	bool hasRangedWeapon();

	bool getUseRanged();

	bool hasSpecialAttack(int num);

	void setPetDeed(PetDeed* deed);

	bool hasPetDeed() const;

	PetDeed* getPetDeed() const;

	void sendReactionChat(int type, int state = 0, bool force = false);

	bool hasReactionChatMessages();

	float getEffectiveResist();

	String getPersonalityStf();

	int getReactionRank() const;

	void setReactionRank(int rank);

	int getHamMaximum() const;

	int getHamBase() const;

	void setMaxHAM(int type, int value, bool notifyClient = true);

	/**
	 * Reset the aiagent back to it's initial creation state.
	 * this resets the HAM, Damage, Size and Weapons of the AiAgent. Used for Pet adjustments.
	 */
	void reloadTemplate();

	unsigned int getConvoTemplateCRC() const;

	void setConvoTemplate(const String& templateString);

	void setLairTemplateCRC(unsigned int crc);

	unsigned int getLairTemplateCRC() const;

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	AiAgent(DummyConstructorParameter* param);

	virtual ~AiAgent();

	AiAgent* __asAiAgent();

	friend class AiAgentHelper;
};

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class AiAgentImplementation : public CreatureObjectImplementation {
protected:
	Reference<AiThinkEvent* > thinkEvent;

	Reference<AiMoveEvent* > moveEvent;

	Reference<AiWaitEvent* > waitEvent;

	Reference<AiAwarenessEvent* > awarenessEvent;

	ReadWriteLock despawnMutex;

	Vector<String> skillCommands;

	PatrolPointsVector patrolPoints;

	PatrolPointsVector savedPatrolPoints;

	PatrolPoint homeLocation;

	PatrolPoint nextStepPosition;

	Reference<CurrentFoundPath* > currentFoundPath;

	ManagedReference<CellObject* > targetCellObject;

	ManagedReference<WeaponObject* > readyWeapon;

	Reference<CreatureAttackMap* > attackMap;

	Reference<CreatureAttackMap* > defaultAttackMap;

	SortedVector<unsigned long long> camouflagedObjects;

	CreatureTemplateReference npcTemplate;

	unsigned int convoTemplateCRC;

	ManagedWeakReference<SceneObject* > homeObject;

	bool showNextMovementPosition;

	Vector<ManagedReference<SceneObject* > > movementMarkers;

	bool despawnOnNoPlayerInRange;

private:
	ManagedWeakReference<SceneObject* > followObject;

	ManagedWeakReference<SceneObject* > followStore;

	unsigned int followState;

	Mutex targetMutex;

	Mutex awarenessEventMutex;

	Mutex movementEventMutex;

	int nextMovementInterval;

protected:
	Time lastDamageReceived;

	int reactionRank;

	float respawnTimer;

	int respawnCounter;

	bool randomRespawn;

	AtomicInteger numberOfPlayersInRange;

	bool loadedOutfit;

	Reference<DespawnCreatureOnPlayerDissappear* > despawnEvent;

	ManagedReference<PetDeed* > petDeed;

	unsigned int currentBehaviorID;

	VectorMap<unsigned int, Behavior*> behaviors;

	String templateName;

	unsigned int lairTemplateCRC;

	unsigned int creatureBitmask;

	int waitTime;

	bool waiting;

	float fleeRange;

	Time alertedTime;

	Reference<AiTrackingTask* > trackingTask;

	unsigned int nextActionCRC;

	String nextActionArgs;

public:
	static const int UPDATEMOVEMENTINTERVAL = 500;

	static const int DEFAULTAGGRORADIUS = 24;

	static const int OBLIVIOUS = 0;

	static const int WATCHING = 1;

	static const int STALKING = 2;

	static const int FOLLOWING = 3;

	static const int PATROLLING = 4;

	static const int FLEEING = 5;

	static const int LEASHING = 6;

	AiAgentImplementation();

	AiAgentImplementation(DummyConstructorParameter* param);

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	void finalize();

	/**
	 * Schedules the next recovery event
	 * @pre { at least this is locked }
	 * @post { at least this is locked }
	 */
	virtual void activateRecovery();

	/**
	 * Schedules the next movement event
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	virtual void activateMovementEvent();

	/**
	 * Schedules the next wait event
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	virtual void activateWaitEvent();

	/**
	 * Schedules an event to check awareness
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void activateAwarenessEvent(unsigned long long delay = 1000);

	/**
	 * Executes an AI interrupt in a separate thread (to shed locks)
	 * @pre { }
	 * @post { }
	 */
	void activateInterrupt(SceneObject* source, long long msg);

	/**
	 * Schedules the loading
	 * @pre { }
	 * @post { }
	 */
	void activateLoad(const String& temp);

	/**
	 * Does a recovery tick
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param latency The amount of time since the last recovery event
	 */
	void doRecovery(int latency);

	/**
	 * Does the main AI update tick
	 * @pre { this object is locked }
	 * @post { this object is locked, this AI will have performed one update tick }
	 */
	void doMovement();

	void setLevel(int lvl, bool randomHam = true);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines
	 */
	void sendBaselinesTo(SceneObject* player);

	int calculateAttackMinDamage(int level);

	int calculateAttackMaxDamage(int level);

	float calculateAttackSpeed(int level);

	SceneObject* getTargetFromMap();

	SceneObject* getTargetFromDefenders();

	SceneObject* getTargetFromTargetsDefenders();

	bool validateTarget();

	bool validateTarget(SceneObject* target);

	virtual bool isCamouflaged(CreatureObject* target);

protected:
	bool isScentMasked(CreatureObject* target);

	bool isConcealed(CreatureObject* target);

public:
	bool findNextPosition(float maxDistance, bool walk = false);

	float getWorldZ(const Vector3& position);

	/**
	 * Does the AI awareness update tick
	 * @pre { this is locked }
	 * @post { this is locked, this AI will have scheduled one awareness check }
	 */
	void doAwarenessCheck();

	bool runAwarenessLogicCheck(SceneObject* pObject);

	void runStartAwarenessInterrupt(SceneObject* pObject);

	int checkForReactionChat(SceneObject* pObject);

	/**
	 * Handles the radial selection sent by the client, must be overriden by inherited objects
	 * @pre { this object is locked, player is locked }
	 * @post { this object is locked, player is locked }
	 * @param player CreatureObject that selected the option
	 * @param selectedID selected menu id
	 * @returns 0 if successfull
	 */
	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void checkNewAngle();

	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	void setNextPosition(float x, float z, float y, CellObject* cell = NULL);

	void setNextStepPosition(float x, float z, float y, CellObject* cell = NULL);

	void notifyPositionUpdate(QuadTreeEntry* entry);

	void updateCurrentPosition(PatrolPoint* point);

	void broadcastNextPositionUpdate(PatrolPoint* point);

	void clearPatrolPoints();

	void clearSavedPatrolPoints();

	void setPatrolPoints(PatrolPointsVector& pVector);

	PatrolPoint getNextPosition();

	int getPatrolPointSize();

	void notifyInsert(QuadTreeEntry* entry);

	void notifyDissapear(QuadTreeEntry* entry);

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	void loadTemplateData(CreatureTemplate* templateData);

	void setupAttackMaps();

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient = true, bool isCombatAction = false);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient = true, bool isCombatAction = false);

	int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0);

	/**
	 * sends the conversation notification
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 * @return whether the conversation was started or not
	 */
	bool sendConversationStartTo(SceneObject* player);

	/**
	 * sends the default conversation list
	 * @pre {this locked, player locked }
	 * @post {this locked, player locked }
	 */
	void sendDefaultConversationTo(SceneObject* player);

	/**
	 * sends the conversation list
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	void selectConversationOption(int option, SceneObject* obj);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	/**
	 * Is called when an object is talked to
	 * @pre { this, converser locked }
	 * @post {this, converser locked }
	 */
	int notifyConverseObservers(CreatureObject* converser);

	int notifyAttack(Observable* observable);

	int notifyCallForHelp(Observable* observable, ManagedObject* arg1);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	void destroyObjectFromDatabase(bool destroyContainedObjects = false);

	void activatePostureRecovery();

	virtual void activateHAMRegeneration(int latency);

	void queueDizzyFallEvent();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	void clearCombatState(bool clearDefenders = true);

	/**
	 * Sets the active defender
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is active }
	 * @param defender SceneObject to set as the active defender
	 */
	void setDefender(SceneObject* defender);

	/**
	 * Adds a SceneObject to the defender vector
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is in the defender vector }
	 * @param defender SceneObject to add to the defender vector
	 */
	void addDefender(SceneObject* defender);

	/**
	 * Removes the specified defender from the defender vector
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is not in the defender vector }
	 * @param defender SceneObject to remove from the defender vector
	 */
	void removeDefender(SceneObject* defender);

	void setDespawnOnNoPlayerInRange(bool val);

	/**
	 * Gets called when the creature was despawned
	 */
	virtual void notifyDespawn(Zone* zone);

	virtual void scheduleDespawn();

	/**
	 * Schedules despawn of the AiAgent.
	 * @param timeToDespawn the time to despawn the AiAgent in seconds.
	 */
	virtual void scheduleDespawn(int timeToDespawn);

	/**
	 * Respawns creature to specified zone with home location position
	 */
	void respawn(Zone* zone, int level);

	void addPatrolPoint(PatrolPoint& point);

	void setHomeLocation(float x, float z, float y, CellObject* cell = NULL);

	void setRespawnTimer(float resp);

	void setRandomRespawn(bool resp);

	void resetRespawnCounter();

	/**
	 * Evaluates if this can be attacked by object
	 * @pre { }
	 * @post { }
	 * @return returns true if object can attack this
	 */
	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* object);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	bool isAggressiveTo(CreatureObject* object);

	void setOblivious();

	void setWatchObject(SceneObject* obj);

	void setStalkObject(SceneObject* obj);

	void setFollowObject(SceneObject* obj);

	void setTargetObject(SceneObject* obj);

	void runAway(CreatureObject* target, float range);

	void leash();

	bool generatePatrol(int num, float dist);

	ManagedWeakReference<SceneObject* > getFollowObject();

	void storeFollowObject();

	void restoreFollowObject();

	unsigned int getFollowState() const;

	void setFollowState(int state);

	float getMaxDistance();

	int setDestination();

	bool completeMove();

	void setWait(int wait);

	int getWait() const;

	bool isWaiting() const;

	/**
	 * Sets the waiting variable to false, which determines if an action can be performed
	 * @pre { the AI is locked }
	 * @post { the AI is locked, and ready to perform an action }
	 */
	void stopWaiting();

	void selectWeapon();

	void selectDefaultWeapon();

	bool validateStateAttack(CreatureObject* target, unsigned int actionCRC);

	void selectSpecialAttack();

	void selectSpecialAttack(int attackNum);

	void selectDefaultAttack();

	bool validateStateAttack();

	void enqueueAttack(int priority = -1);

	bool isRetreating();

	bool isFleeing();

	void clearDespawnEvent();

	virtual float getKinetic();

	virtual float getEnergy();

	virtual float getElectricity();

	virtual float getStun();

	virtual float getBlast();

	virtual float getHeat();

	virtual float getCold();

	virtual float getAcid();

	virtual float getLightSaber();

protected:
	float getReducedResist(float value);

public:
	virtual bool isSpecialProtection(int resistType);

	bool isStalker();

	bool isKiller();

	unsigned int getFerocity();

	int getAggroRadius();

	virtual unsigned int getArmor();

	bool getDespawnOnNoPlayerInRange() const;

	int getNumberOfPlayersInRange();

	String getFactionString();

	String getSocialGroup();

	float getChanceHit();

	int getDamageMin();

	int getDamageMax();

	float getSpecialDamageMult();

	virtual int getBaseXp();

	unsigned int getDiet();

	unsigned int getTemplateLevel() const;

	float getTame() const;

	const CreatureAttackMap* getAttackMap();

	const LootGroupCollection* getLootGroups();

	virtual String getReactionStf();

	float getRespawnTimer() const;

	bool getRandomRespawn() const;

	int getRespawnCounter() const;

	PatrolPoint* getHomeLocation();

	bool isAiAgent();

	AiAgent* asAiAgent();

	const CreatureTemplate* getCreatureTemplate() const;

	bool hasLoot();

	void setShowNextPosition(bool val);

	bool isEventMob();

	bool isPet() const;

	/**
	 * Sets up the behavior based on the creature bitmask
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void setupBehaviorTree();

	/**
	 * Sets up the behavior tree by forcing a template into it
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param aiTemplate the template to load
	 */
	void setupBehaviorTree(AiTemplate* aiTemplate);

	/**
	 * Helper function for setting up the behavior tree from bitmask
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param getTarget Template for target selection
	 * @param selectAttack Template for attack selection
	 * @param combatMove Template for movement when in combat
	 * @param idle Template for idle behavior
	 */
	void setupBehaviorTree(AiTemplate* getTarget, AiTemplate* selectAttack, AiTemplate* combatMove, AiTemplate* idle);

	/**
	 * Sets the behavior in the tree
	 * @pre { this is locked }
	 * @post { this is locked, behavior is set }
	 * @param b the id of the behavior in the tree
	 */
	void setCurrentBehavior(unsigned int b);

	unsigned int getCurrentBehavior() const;

	int getBehaviorStatus();

	void setBehaviorStatus(int status);

private:
	void addBehaviorToTree(Behavior* b, CompositeBehavior* parent);

	void addCurrentBehaviorToTree(CompositeBehavior* parent);

public:
	/**
	 * Resets the behavior list to the default position
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void resetBehaviorList();

	void clearBehaviorList();

	/**
	 * Executes an interrupt called from a new thread
	 * @pre { this is locked, source is locked }
	 * @post { this is locked, source is locked }
	 * @param source The originator of the interrupt call
	 * @param msg The long id of the message (argument) of the interrupt
	 */
	int interrupt(SceneObject* source, long long msg);

	void broadcastInterrupt(long long msg);

	void setHomeObject(SceneObject* home);

	ManagedWeakReference<SceneObject* > getHomeObject() const;

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	void setCombatState();

	int getCreatureBitmask() const;

	void setCreatureBitmask(int mask);

	void setCreatureBit(unsigned int option);

	void clearCreatureBit(unsigned int option);

	Time* getAlertedTime();

	void incrementLuaCall(const String& key);

	void addToLuaTime(const String& key, unsigned long long val);

	void outputLuaTimes(CreatureObject* caller);

	void rescheduleTrackingTask();

	bool hasRangedWeapon();

	bool getUseRanged();

	bool hasSpecialAttack(int num);

	void setPetDeed(PetDeed* deed);

	bool hasPetDeed() const;

	PetDeed* getPetDeed() const;

	void sendReactionChat(int type, int state = 0, bool force = false);

	virtual bool hasReactionChatMessages();

	float getEffectiveResist();

	virtual String getPersonalityStf();

	int getReactionRank() const;

	void setReactionRank(int rank);

	int getHamMaximum() const;

	int getHamBase() const;

	void setMaxHAM(int type, int value, bool notifyClient = true);

	/**
	 * Reset the aiagent back to it's initial creation state.
	 * this resets the HAM, Damage, Size and Weapons of the AiAgent. Used for Pet adjustments.
	 */
	void reloadTemplate();

	unsigned int getConvoTemplateCRC() const;

	void setConvoTemplate(const String& templateString);

	void setLairTemplateCRC(unsigned int crc);

	unsigned int getLairTemplateCRC() const;

	WeakReference<AiAgent*> _this;

	operator const AiAgent*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	virtual void writeJSON(nlohmann::json& j);
protected:
	virtual ~AiAgentImplementation();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class AiAgent;
};

class AiAgentAdapter : public CreatureObjectAdapter {
public:
	AiAgentAdapter(AiAgent* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void initializeTransientMembers();

	void notifyLoadFromDatabase();

	void finalize();

	void activateRecovery();

	void activateMovementEvent();

	void activateWaitEvent();

	void activateAwarenessEvent(unsigned long long delay);

	void activateInterrupt(SceneObject* source, long long msg);

	void activateLoad(const String& temp);

	void doRecovery(int latency);

	void doMovement();

	void setLevel(int lvl, bool randomHam);

	void sendBaselinesTo(SceneObject* player);

	int calculateAttackMinDamage(int level);

	int calculateAttackMaxDamage(int level);

	float calculateAttackSpeed(int level);

	SceneObject* getTargetFromMap();

	SceneObject* getTargetFromDefenders();

	SceneObject* getTargetFromTargetsDefenders();

	bool validateTarget();

	bool validateTarget(SceneObject* target);

	bool isCamouflaged(CreatureObject* target);

	bool findNextPosition(float maxDistance, bool walk);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void checkNewAngle();

	void setNextPosition(float x, float z, float y, CellObject* cell);

	void setNextStepPosition(float x, float z, float y, CellObject* cell);

	void notifyPositionUpdate(QuadTreeEntry* entry);

	void clearPatrolPoints();

	void clearSavedPatrolPoints();

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction);

	int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength);

	bool sendConversationStartTo(SceneObject* player);

	void sendDefaultConversationTo(SceneObject* player);

	void selectConversationOption(int option, SceneObject* obj);

	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	int notifyConverseObservers(CreatureObject* converser);

	int notifyAttack(Observable* observable);

	int notifyCallForHelp(Observable* observable, ManagedObject* arg1);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	void destroyObjectFromDatabase(bool destroyContainedObjects);

	void activatePostureRecovery();

	void activateHAMRegeneration(int latency);

	void queueDizzyFallEvent();

	void clearCombatState(bool clearDefenders);

	void setDefender(SceneObject* defender);

	void addDefender(SceneObject* defender);

	void removeDefender(SceneObject* defender);

	void setDespawnOnNoPlayerInRange(bool val);

	void notifyDespawn(Zone* zone);

	void scheduleDespawn();

	void scheduleDespawn(int timeToDespawn);

	void respawn(Zone* zone, int level);

	void setHomeLocation(float x, float z, float y, CellObject* cell);

	void setRespawnTimer(float resp);

	void setRandomRespawn(bool resp);

	void resetRespawnCounter();

	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* object);

	bool isAggressiveTo(CreatureObject* object);

	void setOblivious();

	void setWatchObject(SceneObject* obj);

	void setStalkObject(SceneObject* obj);

	void setFollowObject(SceneObject* obj);

	void setTargetObject(SceneObject* obj);

	void runAway(CreatureObject* target, float range);

	void leash();

	bool generatePatrol(int num, float dist);

	ManagedWeakReference<SceneObject* > getFollowObject();

	void storeFollowObject();

	void restoreFollowObject();

	unsigned int getFollowState() const;

	void setFollowState(int state);

	float getMaxDistance();

	int setDestination();

	bool completeMove();

	void setWait(int wait);

	int getWait() const;

	bool isWaiting() const;

	void stopWaiting();

	void selectWeapon();

	void selectDefaultWeapon();

	bool validateStateAttack(CreatureObject* target, unsigned int actionCRC);

	void selectSpecialAttack();

	void selectSpecialAttack(int attackNum);

	void selectDefaultAttack();

	bool validateStateAttack();

	void enqueueAttack(int priority);

	bool isRetreating();

	bool isFleeing();

	void clearDespawnEvent();

	float getKinetic();

	float getEnergy();

	float getElectricity();

	float getStun();

	float getBlast();

	float getHeat();

	float getCold();

	float getAcid();

	float getLightSaber();

	bool isSpecialProtection(int resistType);

	bool isStalker();

	bool isKiller();

	unsigned int getFerocity();

	int getAggroRadius();

	unsigned int getArmor();

	bool getDespawnOnNoPlayerInRange() const;

	int getNumberOfPlayersInRange();

	String getFactionString();

	String getSocialGroup();

	float getChanceHit();

	int getDamageMin();

	int getDamageMax();

	float getSpecialDamageMult();

	int getBaseXp();

	unsigned int getDiet();

	unsigned int getTemplateLevel() const;

	float getTame() const;

	String getReactionStf();

	float getRespawnTimer() const;

	bool getRandomRespawn() const;

	int getRespawnCounter() const;

	bool isAiAgent();

	bool hasLoot();

	void setShowNextPosition(bool val);

	bool isEventMob();

	bool isPet() const;

	unsigned int getCurrentBehavior() const;

	void setHomeObject(SceneObject* home);

	void setCombatState();

	int getCreatureBitmask() const;

	void setCreatureBitmask(int mask);

	void setCreatureBit(unsigned int option);

	void clearCreatureBit(unsigned int option);

	void incrementLuaCall(const String& key);

	void addToLuaTime(const String& key, unsigned long long val);

	void outputLuaTimes(CreatureObject* caller);

	void rescheduleTrackingTask();

	bool hasRangedWeapon();

	bool getUseRanged();

	bool hasSpecialAttack(int num);

	void setPetDeed(PetDeed* deed);

	bool hasPetDeed() const;

	PetDeed* getPetDeed() const;

	void sendReactionChat(int type, int state, bool force);

	bool hasReactionChatMessages();

	String getPersonalityStf();

	int getReactionRank() const;

	void setReactionRank(int rank);

	int getHamMaximum() const;

	int getHamBase() const;

	void setMaxHAM(int type, int value, bool notifyClient);

	void reloadTemplate();

	unsigned int getConvoTemplateCRC() const;

	void setConvoTemplate(const String& templateString);

	void setLairTemplateCRC(unsigned int crc);

	unsigned int getLairTemplateCRC() const;

};

class AiAgentHelper : public DistributedObjectClassHelper, public Singleton<AiAgentHelper> {
	static AiAgentHelper* staticInitializer;

public:
	AiAgentHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<AiAgentHelper>;
};

class MockAiAgent : public AiAgent {
public:

	MOCK_METHOD0(getWorldPositionX,float());
	MOCK_METHOD0(getWorldPositionY,float());
	MOCK_METHOD0(getWorldPositionZ,float());
	MOCK_METHOD0(getWorldPosition,Vector3());

};

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class AiAgentPOD : public CreatureObjectPOD {
public:
	Optional<Vector<String>> skillCommands;

	Optional<PatrolPointsVector> patrolPoints;

	Optional<PatrolPointsVector> savedPatrolPoints;

	Optional<PatrolPoint> homeLocation;

	Optional<PatrolPoint> nextStepPosition;

	Optional<ManagedReference<WeaponObjectPOD* >> readyWeapon;

	Optional<CreatureTemplateReference> npcTemplate;

	Optional<unsigned int> convoTemplateCRC;

	Optional<ManagedWeakReference<SceneObjectPOD* >> homeObject;

	Optional<bool> showNextMovementPosition;

	Optional<Vector<ManagedReference<SceneObjectPOD* > >> movementMarkers;

	Optional<bool> despawnOnNoPlayerInRange;

	Optional<ManagedWeakReference<SceneObjectPOD* >> followObject;

	Optional<ManagedWeakReference<SceneObjectPOD* >> followStore;

	Optional<unsigned int> followState;

	Optional<int> nextMovementInterval;

	Optional<int> reactionRank;

	Optional<float> respawnTimer;

	Optional<int> respawnCounter;

	Optional<bool> randomRespawn;

	Optional<bool> loadedOutfit;

	Optional<ManagedReference<PetDeedPOD* >> petDeed;

	Optional<unsigned int> currentBehaviorID;

	Optional<unsigned int> lairTemplateCRC;

	Optional<unsigned int> creatureBitmask;

	Optional<int> waitTime;

	Optional<bool> waiting;

	Optional<float> fleeRange;

	Optional<unsigned int> nextActionCRC;

	Optional<String> nextActionArgs;

	String _className;
	AiAgentPOD();
	virtual void writeJSON(nlohmann::json& j);
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~AiAgentPOD();

};

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

#endif /*AIAGENTPOD_H_*/
