/*
 *	autogen/server/zone/objects/tangible/weapon/WeaponObject.cpp generated by engine3 IDL compiler 0.70
 */

#include "WeaponObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/objects/tangible/powerup/PowerupObject.h"

/*
 *	WeaponObjectStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDCONTAINERTO__CREATUREOBJECT_,RPC_NOTIFYLOADFROMDATABASE__,RPC_CREATECHILDOBJECTS__,RPC_ISCERTIFIEDFOR__CREATUREOBJECT_,RPC_SETCERTIFIED__BOOL_,RPC_GETATTACKTYPE__,RPC_SETATTACKTYPE__INT_,RPC_ISCERTIFIED__,RPC_ISEQUIPPED__,RPC_GETPOINTBLANKACCURACY__BOOL_,RPC_SETPOINTBLANKACCURACY__INT_,RPC_GETPOINTBLANKRANGE__BOOL_,RPC_GETIDEALRANGE__BOOL_,RPC_SETIDEALRANGE__INT_,RPC_GETMAXRANGE__BOOL_,RPC_SETMAXRANGE__INT_,RPC_GETIDEALACCURACY__BOOL_,RPC_SETIDEALACCURACY__INT_,RPC_SETARMORPIERCING__INT_,RPC_GETARMORPIERCING__,RPC_GETMAXRANGEACCURACY__BOOL_,RPC_SETMAXRANGEACCURACY__INT_,RPC_GETATTACKSPEED__BOOL_,RPC_SETATTACKSPEED__FLOAT_,RPC_GETMAXDAMAGE__BOOL_,RPC_SETMAXDAMAGE__FLOAT_,RPC_GETMINDAMAGE__BOOL_,RPC_SETMINDAMAGE__FLOAT_,RPC_GETWOUNDSRATIO__BOOL_,RPC_SETWOUNDSRATIO__FLOAT_,RPC_GETDAMAGERADIUS__BOOL_,RPC_SETDAMAGERADIUS__FLOAT_,RPC_GETHEALTHATTACKCOST__BOOL_,RPC_SETHEALTHATTACKCOST__INT_,RPC_GETACTIONATTACKCOST__BOOL_,RPC_SETACTIONATTACKCOST__INT_,RPC_GETMINDATTACKCOST__BOOL_,RPC_SETMINDATTACKCOST__INT_,RPC_GETFORCECOST__,RPC_SETFORCECOST__FLOAT_,RPC_GETBLADECOLOR__,RPC_SETBLADECOLOR__INT_,RPC_GETDAMAGETYPE__,RPC_GETXPTYPE__,RPC_GETNUMBEROFDOTS__,RPC_GETDOTTYPE__INT_,RPC_GETDOTATTRIBUTE__INT_,RPC_GETDOTSTRENGTH__INT_,RPC_GETDOTDURATION__INT_,RPC_GETDOTPOTENCY__INT_,RPC_GETDOTUSES__INT_,RPC_ADDDOTTYPE__INT_,RPC_ADDDOTATTRIBUTE__INT_,RPC_ADDDOTSTRENGTH__INT_,RPC_ADDDOTDURATION__INT_,RPC_ADDDOTPOTENCY__INT_,RPC_ADDDOTUSES__INT_,RPC_SETDOTUSES__INT_INT_,RPC_GETWEAPONTYPE__,RPC_ISUNARMEDWEAPON__,RPC_ISMELEEWEAPON__,RPC_ISRANGEDWEAPON__,RPC_ISRIFLEWEAPON__,RPC_ISTHROWNWEAPON__,RPC_ISHEAVYWEAPON__,RPC_ISSPECIALHEAVYWEAPON__,RPC_ISLIGHTNINGRIFLE__,RPC_ISFLAMETHROWER__,RPC_ISHEAVYACIDRIFLE__,RPC_ISCARBINEWEAPON__,RPC_ISPISTOLWEAPON__,RPC_ISONEHANDMELEEWEAPON__,RPC_ISPOLEARMWEAPONOBJECT__,RPC_ISTWOHANDMELEEWEAPON__,RPC_ISMINEWEAPON__,RPC_ISJEDIWEAPON__,RPC_ISJEDIONEHANDEDWEAPON__,RPC_ISJEDITWOHANDEDWEAPON__,RPC_ISJEDIPOLEARMWEAPON__,RPC_GETWEAPONBITMASK__,RPC_ISWEAPONOBJECT__,RPC_HASPOWERUP__,RPC_APPLYPOWERUP__CREATUREOBJECT_POWERUPOBJECT_,RPC_REMOVEPOWERUP__,RPC_DECREASEPOWERUPUSES__CREATUREOBJECT_,RPC_REPAIRATTEMPT__INT_,RPC_DECAY__CREATUREOBJECT_,RPC_SETDAMAGESLICE__FLOAT_,RPC_SETSPEEDSLICE__FLOAT_,RPC_APPLYSKILLMODSTO__CREATUREOBJECT_,RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_,RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_,};

WeaponObject::WeaponObject() : TangibleObject(DummyConstructorParameter::instance()) {
	WeaponObjectImplementation* _implementation = new WeaponObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("WeaponObject");
}

WeaponObject::WeaponObject(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("WeaponObject");
}

WeaponObject::~WeaponObject() {
}



void WeaponObject::loadTemplateData(SharedObjectTemplate* templateData) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void WeaponObject::initializeTransientMembers() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void WeaponObject::sendBaselinesTo(SceneObject* player) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

void WeaponObject::sendContainerTo(CreatureObject* player) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONTAINERTO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendContainerTo(player);
	}
}

void WeaponObject::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

void WeaponObject::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updateCraftingValues(values, firstUpdate);
	}
}

void WeaponObject::notifyLoadFromDatabase() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

void WeaponObject::createChildObjects() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATECHILDOBJECTS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->createChildObjects();
	}
}

bool WeaponObject::isCertifiedFor(CreatureObject* object) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCERTIFIEDFOR__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCertifiedFor(object);
	}
}

const Vector<String>* WeaponObject::getDamageModifiers() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getDamageModifiers();
	}
}

const Vector<String>* WeaponObject::getSpeedModifiers() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSpeedModifiers();
	}
}

const Vector<String>* WeaponObject::getCreatureAccuracyModifiers() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCreatureAccuracyModifiers();
	}
}

const Vector<String>* WeaponObject::getCreatureAimModifiers() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCreatureAimModifiers();
	}
}

const Vector<String>* WeaponObject::getDefenderDefenseModifiers() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getDefenderDefenseModifiers();
	}
}

const Vector<String>* WeaponObject::getDefenderSecondaryDefenseModifiers() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getDefenderSecondaryDefenseModifiers();
	}
}

const Vector<String>* WeaponObject::getDefenderToughnessModifiers() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getDefenderToughnessModifiers();
	}
}

void WeaponObject::setCertified(bool cert) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCERTIFIED__BOOL_);
		method.addBooleanParameter(cert);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCertified(cert);
	}
}

int WeaponObject::getAttackType() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTACKTYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAttackType();
	}
}

void WeaponObject::setAttackType(int a) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETATTACKTYPE__INT_);
		method.addSignedIntParameter(a);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAttackType(a);
	}
}

bool WeaponObject::isCertified() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCERTIFIED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCertified();
	}
}

bool WeaponObject::isEquipped() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISEQUIPPED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isEquipped();
	}
}

int WeaponObject::getPointBlankAccuracy(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOINTBLANKACCURACY__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPointBlankAccuracy(withPup);
	}
}

void WeaponObject::setPointBlankAccuracy(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPOINTBLANKACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPointBlankAccuracy(value);
	}
}

int WeaponObject::getPointBlankRange(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOINTBLANKRANGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPointBlankRange(withPup);
	}
}

int WeaponObject::getIdealRange(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETIDEALRANGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getIdealRange(withPup);
	}
}

void WeaponObject::setIdealRange(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETIDEALRANGE__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setIdealRange(value);
	}
}

int WeaponObject::getMaxRange(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXRANGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMaxRange(withPup);
	}
}

void WeaponObject::setMaxRange(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXRANGE__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaxRange(value);
	}
}

int WeaponObject::getIdealAccuracy(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETIDEALACCURACY__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getIdealAccuracy(withPup);
	}
}

void WeaponObject::setIdealAccuracy(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETIDEALACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setIdealAccuracy(value);
	}
}

void WeaponObject::setArmorPiercing(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETARMORPIERCING__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setArmorPiercing(value);
	}
}

int WeaponObject::getArmorPiercing() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETARMORPIERCING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getArmorPiercing();
	}
}

int WeaponObject::getMaxRangeAccuracy(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXRANGEACCURACY__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMaxRangeAccuracy(withPup);
	}
}

void WeaponObject::setMaxRangeAccuracy(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXRANGEACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaxRangeAccuracy(value);
	}
}

float WeaponObject::getAttackSpeed(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTACKSPEED__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAttackSpeed(withPup);
	}
}

void WeaponObject::setAttackSpeed(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETATTACKSPEED__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAttackSpeed(value);
	}
}

float WeaponObject::getMaxDamage(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXDAMAGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxDamage(withPup);
	}
}

void WeaponObject::setMaxDamage(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXDAMAGE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaxDamage(value);
	}
}

float WeaponObject::getMinDamage(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDAMAGE__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMinDamage(withPup);
	}
}

void WeaponObject::setMinDamage(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMINDAMAGE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMinDamage(value);
	}
}

float WeaponObject::getWoundsRatio(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWOUNDSRATIO__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getWoundsRatio(withPup);
	}
}

void WeaponObject::setWoundsRatio(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWOUNDSRATIO__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setWoundsRatio(value);
	}
}

float WeaponObject::getDamageRadius(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGERADIUS__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getDamageRadius(withPup);
	}
}

void WeaponObject::setDamageRadius(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDAMAGERADIUS__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDamageRadius(value);
	}
}

int WeaponObject::getHealthAttackCost(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEALTHATTACKCOST__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHealthAttackCost(withPup);
	}
}

void WeaponObject::setHealthAttackCost(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHEALTHATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setHealthAttackCost(value);
	}
}

int WeaponObject::getActionAttackCost(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIONATTACKCOST__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getActionAttackCost(withPup);
	}
}

void WeaponObject::setActionAttackCost(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACTIONATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setActionAttackCost(value);
	}
}

int WeaponObject::getMindAttackCost(bool withPup) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDATTACKCOST__BOOL_);
		method.addBooleanParameter(withPup);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMindAttackCost(withPup);
	}
}

void WeaponObject::setMindAttackCost(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMINDATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMindAttackCost(value);
	}
}

float WeaponObject::getForceCost() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCECOST__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getForceCost();
	}
}

void WeaponObject::setForceCost(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCECOST__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setForceCost(value);
	}
}

int WeaponObject::getBladeColor() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBLADECOLOR__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBladeColor();
	}
}

void WeaponObject::setBladeColor(int value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBLADECOLOR__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBladeColor(value);
	}
}

int WeaponObject::getDamageType() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGETYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDamageType();
	}
}

String WeaponObject::getXpType() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETXPTYPE__);

		String _return_getXpType;
		method.executeWithAsciiReturn(_return_getXpType);
		return _return_getXpType;
	} else {
		return _implementation->getXpType();
	}
}

int WeaponObject::getNumberOfDots() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNUMBEROFDOTS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getNumberOfDots();
	}
}

int WeaponObject::getDotType(int index) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTTYPE__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDotType(index);
	}
}

int WeaponObject::getDotAttribute(int index) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTATTRIBUTE__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDotAttribute(index);
	}
}

int WeaponObject::getDotStrength(int index) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTSTRENGTH__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDotStrength(index);
	}
}

int WeaponObject::getDotDuration(int index) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTDURATION__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDotDuration(index);
	}
}

int WeaponObject::getDotPotency(int index) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTPOTENCY__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDotPotency(index);
	}
}

int WeaponObject::getDotUses(int index) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDOTUSES__INT_);
		method.addSignedIntParameter(index);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDotUses(index);
	}
}

void WeaponObject::addDotType(int t) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTTYPE__INT_);
		method.addSignedIntParameter(t);

		method.executeWithVoidReturn();
	} else {
		_implementation->addDotType(t);
	}
}

void WeaponObject::addDotAttribute(int a) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTATTRIBUTE__INT_);
		method.addSignedIntParameter(a);

		method.executeWithVoidReturn();
	} else {
		_implementation->addDotAttribute(a);
	}
}

void WeaponObject::addDotStrength(int s) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTSTRENGTH__INT_);
		method.addSignedIntParameter(s);

		method.executeWithVoidReturn();
	} else {
		_implementation->addDotStrength(s);
	}
}

void WeaponObject::addDotDuration(int du) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTDURATION__INT_);
		method.addSignedIntParameter(du);

		method.executeWithVoidReturn();
	} else {
		_implementation->addDotDuration(du);
	}
}

void WeaponObject::addDotPotency(int po) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTPOTENCY__INT_);
		method.addSignedIntParameter(po);

		method.executeWithVoidReturn();
	} else {
		_implementation->addDotPotency(po);
	}
}

void WeaponObject::addDotUses(int u) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTUSES__INT_);
		method.addSignedIntParameter(u);

		method.executeWithVoidReturn();
	} else {
		_implementation->addDotUses(u);
	}
}

void WeaponObject::setDotUses(int u, int index) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDOTUSES__INT_INT_);
		method.addSignedIntParameter(u);
		method.addSignedIntParameter(index);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDotUses(u, index);
	}
}

String WeaponObject::getWeaponType() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPONTYPE__);

		String _return_getWeaponType;
		method.executeWithAsciiReturn(_return_getWeaponType);
		return _return_getWeaponType;
	} else {
		return _implementation->getWeaponType();
	}
}

bool WeaponObject::isUnarmedWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUNARMEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isUnarmedWeapon();
	}
}

bool WeaponObject::isMeleeWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMeleeWeapon();
	}
}

bool WeaponObject::isRangedWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRANGEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRangedWeapon();
	}
}

bool WeaponObject::isRifleWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRIFLEWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRifleWeapon();
	}
}

bool WeaponObject::isThrownWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTHROWNWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isThrownWeapon();
	}
}

bool WeaponObject::isHeavyWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEAVYWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isHeavyWeapon();
	}
}

bool WeaponObject::isSpecialHeavyWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPECIALHEAVYWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSpecialHeavyWeapon();
	}
}

bool WeaponObject::isLightningRifle() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLIGHTNINGRIFLE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLightningRifle();
	}
}

bool WeaponObject::isFlameThrower() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFLAMETHROWER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFlameThrower();
	}
}

bool WeaponObject::isHeavyAcidRifle() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEAVYACIDRIFLE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isHeavyAcidRifle();
	}
}

bool WeaponObject::isCarbineWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCARBINEWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCarbineWeapon();
	}
}

bool WeaponObject::isPistolWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPISTOLWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPistolWeapon();
	}
}

bool WeaponObject::isOneHandMeleeWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONEHANDMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOneHandMeleeWeapon();
	}
}

bool WeaponObject::isPolearmWeaponObject() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOLEARMWEAPONOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPolearmWeaponObject();
	}
}

bool WeaponObject::isTwoHandMeleeWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTWOHANDMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTwoHandMeleeWeapon();
	}
}

bool WeaponObject::isMineWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMINEWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMineWeapon();
	}
}

bool WeaponObject::isJediWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediWeapon();
	}
}

bool WeaponObject::isJediOneHandedWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIONEHANDEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediOneHandedWeapon();
	}
}

bool WeaponObject::isJediTwoHandedWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDITWOHANDEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediTwoHandedWeapon();
	}
}

bool WeaponObject::isJediPolearmWeapon() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIPOLEARMWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediPolearmWeapon();
	}
}

unsigned int WeaponObject::getWeaponBitmask() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWEAPONBITMASK__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getWeaponBitmask();
	}
}

bool WeaponObject::isWeaponObject() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWEAPONOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isWeaponObject();
	}
}

bool WeaponObject::hasPowerup() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPOWERUP__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasPowerup();
	}
}

bool WeaponObject::applyPowerup(CreatureObject* player, PowerupObject* pup) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYPOWERUP__CREATUREOBJECT_POWERUPOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(pup);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->applyPowerup(player, pup);
	}
}

PowerupObject* WeaponObject::removePowerup() {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEPOWERUP__);

		return static_cast<PowerupObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->removePowerup();
	}
}

void WeaponObject::decreasePowerupUses(CreatureObject* player) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEPOWERUPUSES__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->decreasePowerupUses(player);
	}
}

String WeaponObject::repairAttempt(int repairChance) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REPAIRATTEMPT__INT_);
		method.addSignedIntParameter(repairChance);

		String _return_repairAttempt;
		method.executeWithAsciiReturn(_return_repairAttempt);
		return _return_repairAttempt;
	} else {
		return _implementation->repairAttempt(repairChance);
	}
}

void WeaponObject::decay(CreatureObject* user) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECAY__CREATUREOBJECT_);
		method.addObjectParameter(user);

		method.executeWithVoidReturn();
	} else {
		_implementation->decay(user);
	}
}

void WeaponObject::setDamageSlice(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDAMAGESLICE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDamageSlice(value);
	}
}

void WeaponObject::setSpeedSlice(float value) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPEEDSLICE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSpeedSlice(value);
	}
}

void WeaponObject::applySkillModsTo(CreatureObject* creature) const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYSKILLMODSTO__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->applySkillModsTo(creature);
	}
}

void WeaponObject::removeSkillModsFrom(CreatureObject* creature) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSkillModsFrom(creature);
	}
}

void WeaponObject::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_);
		method.addSignedIntParameter(skillType);
		method.addAsciiParameter(skillMod);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addSkillMod(skillType, skillMod, value, notifyClient);
	}
}

const VectorMap<String, int>* WeaponObject::getWearableSkillMods() const {
	WeaponObjectImplementation* _implementation = static_cast<WeaponObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getWearableSkillMods();
	}
}

DistributedObjectServant* WeaponObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* WeaponObject::_getImplementationForRead() const {
	return _impl;
}

void WeaponObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	WeaponObjectImplementation
 */

WeaponObjectImplementation::WeaponObjectImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


WeaponObjectImplementation::~WeaponObjectImplementation() {
}


void WeaponObjectImplementation::finalize() {
}

void WeaponObjectImplementation::_initializeImplementation() {
	_setClassHelper(WeaponObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void WeaponObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<WeaponObject*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* WeaponObjectImplementation::_getStub() {
	return _this.get();
}

WeaponObjectImplementation::operator const WeaponObject*() {
	return _this.get();
}

void WeaponObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void WeaponObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void WeaponObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void WeaponObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void WeaponObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void WeaponObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void WeaponObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void WeaponObjectImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("WeaponObject");

}

void WeaponObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(WeaponObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool WeaponObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xaf7c0a4b: //WeaponObject.attackType
		TypeInfo<int >::parseFromBinaryStream(&attackType, stream);
		return true;

	case 0xce821459: //WeaponObject.weaponEffect
		TypeInfo<String >::parseFromBinaryStream(&weaponEffect, stream);
		return true;

	case 0x3f0d10bc: //WeaponObject.weaponEffectIndex
		TypeInfo<int >::parseFromBinaryStream(&weaponEffectIndex, stream);
		return true;

	case 0x3115d69d: //WeaponObject.certified
		TypeInfo<bool >::parseFromBinaryStream(&certified, stream);
		return true;

	case 0x6b12d54f: //WeaponObject.armorPiercing
		TypeInfo<int >::parseFromBinaryStream(&armorPiercing, stream);
		return true;

	case 0x152e5f75: //WeaponObject.pointBlankAccuracy
		TypeInfo<int >::parseFromBinaryStream(&pointBlankAccuracy, stream);
		return true;

	case 0x670ae4ff: //WeaponObject.pointBlankRange
		TypeInfo<int >::parseFromBinaryStream(&pointBlankRange, stream);
		return true;

	case 0xc470ee9f: //WeaponObject.idealRange
		TypeInfo<int >::parseFromBinaryStream(&idealRange, stream);
		return true;

	case 0xd480b36e: //WeaponObject.idealAccuracy
		TypeInfo<int >::parseFromBinaryStream(&idealAccuracy, stream);
		return true;

	case 0x9890e346: //WeaponObject.maxRange
		TypeInfo<int >::parseFromBinaryStream(&maxRange, stream);
		return true;

	case 0x2613027b: //WeaponObject.maxRangeAccuracy
		TypeInfo<int >::parseFromBinaryStream(&maxRangeAccuracy, stream);
		return true;

	case 0xb67af664: //WeaponObject.damageType
		TypeInfo<int >::parseFromBinaryStream(&damageType, stream);
		return true;

	case 0x7e68aff1: //WeaponObject.attackSpeed
		TypeInfo<float >::parseFromBinaryStream(&attackSpeed, stream);
		return true;

	case 0x244a18e6: //WeaponObject.minDamage
		TypeInfo<float >::parseFromBinaryStream(&minDamage, stream);
		return true;

	case 0xb1865fc5: //WeaponObject.maxDamage
		TypeInfo<float >::parseFromBinaryStream(&maxDamage, stream);
		return true;

	case 0x80491112: //WeaponObject.damageRadius
		TypeInfo<float >::parseFromBinaryStream(&damageRadius, stream);
		return true;

	case 0xc038e1ce: //WeaponObject.woundsRatio
		TypeInfo<float >::parseFromBinaryStream(&woundsRatio, stream);
		return true;

	case 0x2b72cd02: //WeaponObject.healthAttackCost
		TypeInfo<int >::parseFromBinaryStream(&healthAttackCost, stream);
		return true;

	case 0x9957963b: //WeaponObject.actionAttackCost
		TypeInfo<int >::parseFromBinaryStream(&actionAttackCost, stream);
		return true;

	case 0x987636de: //WeaponObject.mindAttackCost
		TypeInfo<int >::parseFromBinaryStream(&mindAttackCost, stream);
		return true;

	case 0x42b7f5e: //WeaponObject.forceCost
		TypeInfo<int >::parseFromBinaryStream(&forceCost, stream);
		return true;

	case 0xb924163f: //WeaponObject.saberForceCost
		TypeInfo<float >::parseFromBinaryStream(&saberForceCost, stream);
		return true;

	case 0x2e53bceb: //WeaponObject.bladeColor
		TypeInfo<int >::parseFromBinaryStream(&bladeColor, stream);
		return true;

	case 0x39d8ea3d: //WeaponObject.powerupObject
		TypeInfo<ManagedReference<PowerupObject* > >::parseFromBinaryStream(&powerupObject, stream);
		return true;

	case 0x8cf72617: //WeaponObject.damageSlice
		TypeInfo<float >::parseFromBinaryStream(&damageSlice, stream);
		return true;

	case 0x949b206c: //WeaponObject.speedSlice
		TypeInfo<float >::parseFromBinaryStream(&speedSlice, stream);
		return true;

	case 0x40433917: //WeaponObject.dotType
		TypeInfo<Vector<int> >::parseFromBinaryStream(&dotType, stream);
		return true;

	case 0x5662a29d: //WeaponObject.dotAttribute
		TypeInfo<Vector<int> >::parseFromBinaryStream(&dotAttribute, stream);
		return true;

	case 0xe6ae6a5b: //WeaponObject.dotStrength
		TypeInfo<Vector<int> >::parseFromBinaryStream(&dotStrength, stream);
		return true;

	case 0xe8f7f5b9: //WeaponObject.dotDuration
		TypeInfo<Vector<int> >::parseFromBinaryStream(&dotDuration, stream);
		return true;

	case 0x8f640033: //WeaponObject.dotPotency
		TypeInfo<Vector<int> >::parseFromBinaryStream(&dotPotency, stream);
		return true;

	case 0x40a17332: //WeaponObject.dotUses
		TypeInfo<Vector<int> >::parseFromBinaryStream(&dotUses, stream);
		return true;

	case 0xdeec3bb7: //WeaponObject.wearableSkillMods
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&wearableSkillMods, stream);
		return true;

	}

	return false;
}

void WeaponObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = WeaponObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int WeaponObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xaf7c0a4b; //WeaponObject.attackType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&attackType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xce821459; //WeaponObject.weaponEffect
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&weaponEffect, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3f0d10bc; //WeaponObject.weaponEffectIndex
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&weaponEffectIndex, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3115d69d; //WeaponObject.certified
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&certified, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6b12d54f; //WeaponObject.armorPiercing
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&armorPiercing, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x152e5f75; //WeaponObject.pointBlankAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pointBlankAccuracy, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x670ae4ff; //WeaponObject.pointBlankRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pointBlankRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc470ee9f; //WeaponObject.idealRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&idealRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd480b36e; //WeaponObject.idealAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&idealAccuracy, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9890e346; //WeaponObject.maxRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2613027b; //WeaponObject.maxRangeAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxRangeAccuracy, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb67af664; //WeaponObject.damageType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&damageType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7e68aff1; //WeaponObject.attackSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&attackSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x244a18e6; //WeaponObject.minDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&minDamage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb1865fc5; //WeaponObject.maxDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&maxDamage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x80491112; //WeaponObject.damageRadius
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&damageRadius, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc038e1ce; //WeaponObject.woundsRatio
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&woundsRatio, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2b72cd02; //WeaponObject.healthAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&healthAttackCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9957963b; //WeaponObject.actionAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&actionAttackCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x987636de; //WeaponObject.mindAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&mindAttackCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x42b7f5e; //WeaponObject.forceCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forceCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb924163f; //WeaponObject.saberForceCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&saberForceCost, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2e53bceb; //WeaponObject.bladeColor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&bladeColor, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x39d8ea3d; //WeaponObject.powerupObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<PowerupObject* > >::toBinaryStream(&powerupObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8cf72617; //WeaponObject.damageSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&damageSlice, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x949b206c; //WeaponObject.speedSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&speedSlice, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x40433917; //WeaponObject.dotType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5662a29d; //WeaponObject.dotAttribute
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotAttribute, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe6ae6a5b; //WeaponObject.dotStrength
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotStrength, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe8f7f5b9; //WeaponObject.dotDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotDuration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8f640033; //WeaponObject.dotPotency
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotPotency, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x40a17332; //WeaponObject.dotUses
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotUses, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdeec3bb7; //WeaponObject.wearableSkillMods
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&wearableSkillMods, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void WeaponObjectImplementation::writeJSON(nlohmann::json& j) {
	TangibleObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["attackType"] = attackType;

	thisObject["weaponEffect"] = weaponEffect;

	thisObject["weaponEffectIndex"] = weaponEffectIndex;

	thisObject["certified"] = certified;

	thisObject["armorPiercing"] = armorPiercing;

	thisObject["pointBlankAccuracy"] = pointBlankAccuracy;

	thisObject["pointBlankRange"] = pointBlankRange;

	thisObject["idealRange"] = idealRange;

	thisObject["idealAccuracy"] = idealAccuracy;

	thisObject["maxRange"] = maxRange;

	thisObject["maxRangeAccuracy"] = maxRangeAccuracy;

	thisObject["damageType"] = damageType;

	thisObject["attackSpeed"] = attackSpeed;

	thisObject["minDamage"] = minDamage;

	thisObject["maxDamage"] = maxDamage;

	thisObject["damageRadius"] = damageRadius;

	thisObject["woundsRatio"] = woundsRatio;

	thisObject["healthAttackCost"] = healthAttackCost;

	thisObject["actionAttackCost"] = actionAttackCost;

	thisObject["mindAttackCost"] = mindAttackCost;

	thisObject["forceCost"] = forceCost;

	thisObject["saberForceCost"] = saberForceCost;

	thisObject["bladeColor"] = bladeColor;

	thisObject["powerupObject"] = powerupObject;

	thisObject["damageSlice"] = damageSlice;

	thisObject["speedSlice"] = speedSlice;

	thisObject["dotType"] = dotType;

	thisObject["dotAttribute"] = dotAttribute;

	thisObject["dotStrength"] = dotStrength;

	thisObject["dotDuration"] = dotDuration;

	thisObject["dotPotency"] = dotPotency;

	thisObject["dotUses"] = dotUses;

	thisObject["wearableSkillMods"] = wearableSkillMods;

	j["WeaponObject"] = thisObject;
}

WeaponObjectImplementation::WeaponObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		certified = false;
	certified = false;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		armorPiercing = 0;
	armorPiercing = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		healthAttackCost = 0;
	healthAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		actionAttackCost = 0;
	actionAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		mindAttackCost = 0;
	mindAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		forceCost = 0;
	forceCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		saberForceCost = 0.0;
	saberForceCost = 0.0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankAccuracy = 0;
	pointBlankAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankRange = 0;
	pointBlankRange = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealRange = 0;
	idealRange = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealAccuracy = 0;
	idealAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRange = 5;
	maxRange = 5;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRangeAccuracy = 0;
	maxRangeAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageType = 0;
	damageType = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		minDamage = 1;
	minDamage = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxDamage = 10;
	maxDamage = 10;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		woundsRatio = 0;
	woundsRatio = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageRadius = 0;
	damageRadius = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		attackSpeed = 1;
	attackSpeed = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		weaponTemplate = null;
	weaponTemplate = NULL;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		Logger.setLoggingName("WeaponObject");
	Logger::setLoggingName("WeaponObject");
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageSlice = 1;
	damageSlice = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		speedSlice = 1;
	speedSlice = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		wearableSkillMods.setAllowOverwriteInsertPlan();
	(&wearableSkillMods)->setAllowOverwriteInsertPlan();
}

const Vector<String>* WeaponObjectImplementation::getDamageModifiers() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDamageModifiers();
	return weaponTemplate->getDamageModifiers();
}

const Vector<String>* WeaponObjectImplementation::getSpeedModifiers() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getSpeedModifiers();
	return weaponTemplate->getSpeedModifiers();
}

const Vector<String>* WeaponObjectImplementation::getCreatureAccuracyModifiers() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getCreatureAccuracyModifiers();
	return weaponTemplate->getCreatureAccuracyModifiers();
}

const Vector<String>* WeaponObjectImplementation::getCreatureAimModifiers() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getCreatureAimModifiers();
	return weaponTemplate->getCreatureAimModifiers();
}

const Vector<String>* WeaponObjectImplementation::getDefenderDefenseModifiers() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDefenderDefenseModifiers();
	return weaponTemplate->getDefenderDefenseModifiers();
}

const Vector<String>* WeaponObjectImplementation::getDefenderSecondaryDefenseModifiers() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDefenderSecondaryDefenseModifiers();
	return weaponTemplate->getDefenderSecondaryDefenseModifiers();
}

const Vector<String>* WeaponObjectImplementation::getDefenderToughnessModifiers() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDefenderToughnessModifiers();
	return weaponTemplate->getDefenderToughnessModifiers();
}

void WeaponObjectImplementation::setCertified(bool cert) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		certified = cert;
	certified = cert;
}

int WeaponObjectImplementation::getAttackType() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType;
	return attackType;
}

void WeaponObjectImplementation::setAttackType(int a) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		attackType = a;
	attackType = a;
}

bool WeaponObjectImplementation::isCertified() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return certified;
	return certified;
}

void WeaponObjectImplementation::setPointBlankAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankAccuracy = value;
	pointBlankAccuracy = value;
}

void WeaponObjectImplementation::setIdealRange(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealRange = value;
	idealRange = value;
}

void WeaponObjectImplementation::setMaxRange(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRange = value;
	maxRange = value;
}

void WeaponObjectImplementation::setIdealAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealAccuracy = value;
	idealAccuracy = value;
}

void WeaponObjectImplementation::setArmorPiercing(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():   armorPiercing = value;
	armorPiercing = value;
}

int WeaponObjectImplementation::getArmorPiercing() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return armorPiercing;
	return armorPiercing;
}

void WeaponObjectImplementation::setMaxRangeAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRangeAccuracy = value;
	maxRangeAccuracy = value;
}

void WeaponObjectImplementation::setAttackSpeed(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		attackSpeed = value;
	attackSpeed = value;
}

void WeaponObjectImplementation::setMaxDamage(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxDamage = value;
	maxDamage = value;
}

void WeaponObjectImplementation::setMinDamage(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		minDamage = value;
	minDamage = value;
}

void WeaponObjectImplementation::setWoundsRatio(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		woundsRatio = value;
	woundsRatio = value;
}

void WeaponObjectImplementation::setDamageRadius(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageRadius = value;
	damageRadius = value;
}

void WeaponObjectImplementation::setHealthAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		healthAttackCost = value;
	healthAttackCost = value;
}

void WeaponObjectImplementation::setActionAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		actionAttackCost = value;
	actionAttackCost = value;
}

void WeaponObjectImplementation::setMindAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		mindAttackCost = value;
	mindAttackCost = value;
}

float WeaponObjectImplementation::getForceCost() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return saberForceCost;
	return saberForceCost;
}

void WeaponObjectImplementation::setForceCost(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		saberForceCost = value;
	saberForceCost = value;
}

int WeaponObjectImplementation::getBladeColor() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return bladeColor;
	return bladeColor;
}

void WeaponObjectImplementation::setBladeColor(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		bladeColor = value;
	bladeColor = value;
}

int WeaponObjectImplementation::getDamageType() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return damageType;
	return damageType;
}

String WeaponObjectImplementation::getXpType() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getXpType();
	return weaponTemplate->getXpType();
}

int WeaponObjectImplementation::getNumberOfDots() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotType.size();
	return (&dotType)->size();
}

int WeaponObjectImplementation::getDotType(int index) const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotType.elementAt(index);
	return (&dotType)->elementAt(index);
}

int WeaponObjectImplementation::getDotAttribute(int index) const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotAttribute.elementAt(index);
	return (&dotAttribute)->elementAt(index);
}

int WeaponObjectImplementation::getDotStrength(int index) const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotStrength.elementAt(index);
	return (&dotStrength)->elementAt(index);
}

int WeaponObjectImplementation::getDotDuration(int index) const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotDuration.elementAt(index);
	return (&dotDuration)->elementAt(index);
}

int WeaponObjectImplementation::getDotPotency(int index) const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotPotency.elementAt(index);
	return (&dotPotency)->elementAt(index);
}

int WeaponObjectImplementation::getDotUses(int index) const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return dotUses.elementAt(index);
	return (&dotUses)->elementAt(index);
}

void WeaponObjectImplementation::addDotType(int t) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotType.add(t);
	(&dotType)->add(t);
}

void WeaponObjectImplementation::addDotAttribute(int a) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotAttribute.add(a);
	(&dotAttribute)->add(a);
}

void WeaponObjectImplementation::addDotStrength(int s) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotStrength.add(s);
	(&dotStrength)->add(s);
}

void WeaponObjectImplementation::addDotDuration(int du) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotDuration.add(du);
	(&dotDuration)->add(du);
}

void WeaponObjectImplementation::addDotPotency(int po) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotPotency.add(po);
	(&dotPotency)->add(po);
}

void WeaponObjectImplementation::addDotUses(int u) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotUses.add(u);
	(&dotUses)->add(u);
}

void WeaponObjectImplementation::setDotUses(int u, int index) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		dotUses.elementAt(index) = u;
	(&dotUses)->elementAt(index) = u;
}

bool WeaponObjectImplementation::isUnarmedWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.WEAPON || super.gameObjectType == SceneObjectType.MELEEWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::WEAPON || TangibleObjectImplementation::gameObjectType == SceneObjectType::MELEEWEAPON;
}

bool WeaponObjectImplementation::isMeleeWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType == SharedWeaponObjectTemplate.MELEEATTACK;
	return attackType == SharedWeaponObjectTemplate::MELEEATTACK;
}

bool WeaponObjectImplementation::isRangedWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType == SharedWeaponObjectTemplate.RANGEDATTACK;
	return attackType == SharedWeaponObjectTemplate::RANGEDATTACK;
}

bool WeaponObjectImplementation::isRifleWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.RIFLE;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::RIFLE;
}

bool WeaponObjectImplementation::isThrownWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.THROWNWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::THROWNWEAPON;
}

bool WeaponObjectImplementation::isHeavyWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.HEAVYWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::HEAVYWEAPON;
}

bool WeaponObjectImplementation::isSpecialHeavyWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.SPECIALHEAVYWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::SPECIALHEAVYWEAPON;
}

bool WeaponObjectImplementation::isLightningRifle() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getServerObjectCRC() == 397924793;
	return weaponTemplate->getServerObjectCRC() == 397924793;
}

bool WeaponObjectImplementation::isFlameThrower() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/ranged/rifle/rifle_flame_thrower.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/ranged/rifle/rifle_flame_thrower.iff");
}

bool WeaponObjectImplementation::isHeavyAcidRifle() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/ranged/rifle/rifle_acid_beam.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/ranged/rifle/rifle_acid_beam.iff");
}

bool WeaponObjectImplementation::isCarbineWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.CARBINE;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::CARBINE;
}

bool WeaponObjectImplementation::isPistolWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.PISTOL;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::PISTOL;
}

bool WeaponObjectImplementation::isOneHandMeleeWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return (super.gameObjectType == SceneObjectType.ONEHANDMELEEWEAPON && !isJediOneHandedWeapon());
	return (TangibleObjectImplementation::gameObjectType == SceneObjectType::ONEHANDMELEEWEAPON && !isJediOneHandedWeapon());
}

bool WeaponObjectImplementation::isPolearmWeaponObject() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return (super.gameObjectType == SceneObjectType.POLEARM && !isJediPolearmWeapon());
	return (TangibleObjectImplementation::gameObjectType == SceneObjectType::POLEARM && !isJediPolearmWeapon());
}

bool WeaponObjectImplementation::isTwoHandMeleeWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return (super.gameObjectType == SceneObjectType.TWOHANDMELEEWEAPON && !isJediTwoHandedWeapon());
	return (TangibleObjectImplementation::gameObjectType == SceneObjectType::TWOHANDMELEEWEAPON && !isJediTwoHandedWeapon());
}

bool WeaponObjectImplementation::isMineWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObjectType.MINE;
	return TangibleObjectImplementation::gameObjectType == SceneObjectType::MINE;
}

bool WeaponObjectImplementation::isJediWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return isJediOneHandedWeapon() || isJediTwoHandedWeapon() || isJediPolearmWeapon();
	return isJediOneHandedWeapon() || isJediTwoHandedWeapon() || isJediPolearmWeapon();
}

bool WeaponObjectImplementation::isJediOneHandedWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/melee/sword/base/shared_crafted_lightsaber_base.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/melee/sword/base/shared_crafted_lightsaber_base.iff");
}

bool WeaponObjectImplementation::isJediTwoHandedWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/melee/2h_sword/base/shared_crafted_lightsaber_base.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/melee/2h_sword/base/shared_crafted_lightsaber_base.iff");
}

bool WeaponObjectImplementation::isJediPolearmWeapon() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.isDerivedFrom("object/weapon/melee/polearm/base/shared_crafted_lance_lightsaber_base.iff");
	return weaponTemplate->isDerivedFrom("object/weapon/melee/polearm/base/shared_crafted_lance_lightsaber_base.iff");
}

unsigned int WeaponObjectImplementation::getWeaponBitmask() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getWeaponType();
	return weaponTemplate->getWeaponType();
}

bool WeaponObjectImplementation::isWeaponObject() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return true;
	return true;
}

bool WeaponObjectImplementation::hasPowerup() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return powerupObject != null;
	return powerupObject != NULL;
}

void WeaponObjectImplementation::setDamageSlice(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageSlice 
	if (value > 0.5f || value < 0)	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			return;
	return;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageSlice = 1 + value;
	damageSlice = 1 + value;
}

void WeaponObjectImplementation::setSpeedSlice(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		speedSlice 
	if (value > 0.5f || value < 0)	// server/zone/objects/tangible/weapon/WeaponObject.idl():  			return;
	return;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		speedSlice = 1 - value;
	speedSlice = 1 - value;
}

void WeaponObjectImplementation::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		wearableSkillMods.put(skillMod, value);
	(&wearableSkillMods)->put(skillMod, value);
}

const VectorMap<String, int>* WeaponObjectImplementation::getWearableSkillMods() const{
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return wearableSkillMods;
	return (&wearableSkillMods);
}

/*
 *	WeaponObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


WeaponObjectAdapter::WeaponObjectAdapter(WeaponObject* obj) : TangibleObjectAdapter(obj) {
}

void WeaponObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_SENDCONTAINERTO__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendContainerTo(player);
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_CREATECHILDOBJECTS__:
		{
			
			createChildObjects();
			
		}
		break;
	case RPC_ISCERTIFIEDFOR__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isCertifiedFor(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCERTIFIED__BOOL_:
		{
			bool cert = inv->getBooleanParameter();
			
			setCertified(cert);
			
		}
		break;
	case RPC_GETATTACKTYPE__:
		{
			
			int _m_res = getAttackType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETATTACKTYPE__INT_:
		{
			int a = inv->getSignedIntParameter();
			
			setAttackType(a);
			
		}
		break;
	case RPC_ISCERTIFIED__:
		{
			
			bool _m_res = isCertified();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISEQUIPPED__:
		{
			
			bool _m_res = isEquipped();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPOINTBLANKACCURACY__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getPointBlankAccuracy(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETPOINTBLANKACCURACY__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setPointBlankAccuracy(value);
			
		}
		break;
	case RPC_GETPOINTBLANKRANGE__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getPointBlankRange(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETIDEALRANGE__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getIdealRange(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETIDEALRANGE__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setIdealRange(value);
			
		}
		break;
	case RPC_GETMAXRANGE__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getMaxRange(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMAXRANGE__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setMaxRange(value);
			
		}
		break;
	case RPC_GETIDEALACCURACY__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getIdealAccuracy(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETIDEALACCURACY__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setIdealAccuracy(value);
			
		}
		break;
	case RPC_SETARMORPIERCING__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setArmorPiercing(value);
			
		}
		break;
	case RPC_GETARMORPIERCING__:
		{
			
			int _m_res = getArmorPiercing();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMAXRANGEACCURACY__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getMaxRangeAccuracy(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMAXRANGEACCURACY__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setMaxRangeAccuracy(value);
			
		}
		break;
	case RPC_GETATTACKSPEED__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			float _m_res = getAttackSpeed(withPup);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETATTACKSPEED__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setAttackSpeed(value);
			
		}
		break;
	case RPC_GETMAXDAMAGE__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			float _m_res = getMaxDamage(withPup);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETMAXDAMAGE__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setMaxDamage(value);
			
		}
		break;
	case RPC_GETMINDAMAGE__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			float _m_res = getMinDamage(withPup);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETMINDAMAGE__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setMinDamage(value);
			
		}
		break;
	case RPC_GETWOUNDSRATIO__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			float _m_res = getWoundsRatio(withPup);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETWOUNDSRATIO__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setWoundsRatio(value);
			
		}
		break;
	case RPC_GETDAMAGERADIUS__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			float _m_res = getDamageRadius(withPup);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETDAMAGERADIUS__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setDamageRadius(value);
			
		}
		break;
	case RPC_GETHEALTHATTACKCOST__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getHealthAttackCost(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETHEALTHATTACKCOST__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setHealthAttackCost(value);
			
		}
		break;
	case RPC_GETACTIONATTACKCOST__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getActionAttackCost(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETACTIONATTACKCOST__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setActionAttackCost(value);
			
		}
		break;
	case RPC_GETMINDATTACKCOST__BOOL_:
		{
			bool withPup = inv->getBooleanParameter();
			
			int _m_res = getMindAttackCost(withPup);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMINDATTACKCOST__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setMindAttackCost(value);
			
		}
		break;
	case RPC_GETFORCECOST__:
		{
			
			float _m_res = getForceCost();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETFORCECOST__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setForceCost(value);
			
		}
		break;
	case RPC_GETBLADECOLOR__:
		{
			
			int _m_res = getBladeColor();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETBLADECOLOR__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setBladeColor(value);
			
		}
		break;
	case RPC_GETDAMAGETYPE__:
		{
			
			int _m_res = getDamageType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETXPTYPE__:
		{
			
			String _m_res = getXpType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETNUMBEROFDOTS__:
		{
			
			int _m_res = getNumberOfDots();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDOTTYPE__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getDotType(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDOTATTRIBUTE__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getDotAttribute(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDOTSTRENGTH__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getDotStrength(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDOTDURATION__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getDotDuration(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDOTPOTENCY__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getDotPotency(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDOTUSES__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			int _m_res = getDotUses(index);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ADDDOTTYPE__INT_:
		{
			int t = inv->getSignedIntParameter();
			
			addDotType(t);
			
		}
		break;
	case RPC_ADDDOTATTRIBUTE__INT_:
		{
			int a = inv->getSignedIntParameter();
			
			addDotAttribute(a);
			
		}
		break;
	case RPC_ADDDOTSTRENGTH__INT_:
		{
			int s = inv->getSignedIntParameter();
			
			addDotStrength(s);
			
		}
		break;
	case RPC_ADDDOTDURATION__INT_:
		{
			int du = inv->getSignedIntParameter();
			
			addDotDuration(du);
			
		}
		break;
	case RPC_ADDDOTPOTENCY__INT_:
		{
			int po = inv->getSignedIntParameter();
			
			addDotPotency(po);
			
		}
		break;
	case RPC_ADDDOTUSES__INT_:
		{
			int u = inv->getSignedIntParameter();
			
			addDotUses(u);
			
		}
		break;
	case RPC_SETDOTUSES__INT_INT_:
		{
			int u = inv->getSignedIntParameter();
			int index = inv->getSignedIntParameter();
			
			setDotUses(u, index);
			
		}
		break;
	case RPC_GETWEAPONTYPE__:
		{
			
			String _m_res = getWeaponType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISUNARMEDWEAPON__:
		{
			
			bool _m_res = isUnarmedWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISMELEEWEAPON__:
		{
			
			bool _m_res = isMeleeWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISRANGEDWEAPON__:
		{
			
			bool _m_res = isRangedWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISRIFLEWEAPON__:
		{
			
			bool _m_res = isRifleWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISTHROWNWEAPON__:
		{
			
			bool _m_res = isThrownWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISHEAVYWEAPON__:
		{
			
			bool _m_res = isHeavyWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSPECIALHEAVYWEAPON__:
		{
			
			bool _m_res = isSpecialHeavyWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISLIGHTNINGRIFLE__:
		{
			
			bool _m_res = isLightningRifle();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFLAMETHROWER__:
		{
			
			bool _m_res = isFlameThrower();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISHEAVYACIDRIFLE__:
		{
			
			bool _m_res = isHeavyAcidRifle();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCARBINEWEAPON__:
		{
			
			bool _m_res = isCarbineWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPISTOLWEAPON__:
		{
			
			bool _m_res = isPistolWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISONEHANDMELEEWEAPON__:
		{
			
			bool _m_res = isOneHandMeleeWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPOLEARMWEAPONOBJECT__:
		{
			
			bool _m_res = isPolearmWeaponObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISTWOHANDMELEEWEAPON__:
		{
			
			bool _m_res = isTwoHandMeleeWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISMINEWEAPON__:
		{
			
			bool _m_res = isMineWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJEDIWEAPON__:
		{
			
			bool _m_res = isJediWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJEDIONEHANDEDWEAPON__:
		{
			
			bool _m_res = isJediOneHandedWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJEDITWOHANDEDWEAPON__:
		{
			
			bool _m_res = isJediTwoHandedWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJEDIPOLEARMWEAPON__:
		{
			
			bool _m_res = isJediPolearmWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETWEAPONBITMASK__:
		{
			
			unsigned int _m_res = getWeaponBitmask();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_ISWEAPONOBJECT__:
		{
			
			bool _m_res = isWeaponObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASPOWERUP__:
		{
			
			bool _m_res = hasPowerup();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_APPLYPOWERUP__CREATUREOBJECT_POWERUPOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			PowerupObject* pup = static_cast<PowerupObject*>(inv->getObjectParameter());
			
			bool _m_res = applyPowerup(player, pup);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_REMOVEPOWERUP__:
		{
			
			DistributedObject* _m_res = removePowerup();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_DECREASEPOWERUPUSES__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			decreasePowerupUses(player);
			
		}
		break;
	case RPC_REPAIRATTEMPT__INT_:
		{
			int repairChance = inv->getSignedIntParameter();
			
			String _m_res = repairAttempt(repairChance);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_DECAY__CREATUREOBJECT_:
		{
			CreatureObject* user = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			decay(user);
			
		}
		break;
	case RPC_SETDAMAGESLICE__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setDamageSlice(value);
			
		}
		break;
	case RPC_SETSPEEDSLICE__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setSpeedSlice(value);
			
		}
		break;
	case RPC_APPLYSKILLMODSTO__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			applySkillModsTo(creature);
			
		}
		break;
	case RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			removeSkillModsFrom(creature);
			
		}
		break;
	case RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_:
		{
			 int skillType = inv->getSignedIntParameter();
			 String skillMod; inv->getAsciiParameter(skillMod);
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addSkillMod(skillType, skillMod, value, notifyClient);
			
		}
		break;
	default:
		TangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

void WeaponObjectAdapter::initializeTransientMembers() {
	(static_cast<WeaponObject*>(stub))->initializeTransientMembers();
}

void WeaponObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<WeaponObject*>(stub))->sendBaselinesTo(player);
}

void WeaponObjectAdapter::sendContainerTo(CreatureObject* player) {
	(static_cast<WeaponObject*>(stub))->sendContainerTo(player);
}

void WeaponObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<WeaponObject*>(stub))->notifyLoadFromDatabase();
}

void WeaponObjectAdapter::createChildObjects() {
	(static_cast<WeaponObject*>(stub))->createChildObjects();
}

bool WeaponObjectAdapter::isCertifiedFor(CreatureObject* object) const {
	return (static_cast<WeaponObject*>(stub))->isCertifiedFor(object);
}

void WeaponObjectAdapter::setCertified(bool cert) {
	(static_cast<WeaponObject*>(stub))->setCertified(cert);
}

int WeaponObjectAdapter::getAttackType() const {
	return (static_cast<WeaponObject*>(stub))->getAttackType();
}

void WeaponObjectAdapter::setAttackType(int a) {
	(static_cast<WeaponObject*>(stub))->setAttackType(a);
}

bool WeaponObjectAdapter::isCertified() const {
	return (static_cast<WeaponObject*>(stub))->isCertified();
}

bool WeaponObjectAdapter::isEquipped() {
	return (static_cast<WeaponObject*>(stub))->isEquipped();
}

int WeaponObjectAdapter::getPointBlankAccuracy(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getPointBlankAccuracy(withPup);
}

void WeaponObjectAdapter::setPointBlankAccuracy(int value) {
	(static_cast<WeaponObject*>(stub))->setPointBlankAccuracy(value);
}

int WeaponObjectAdapter::getPointBlankRange(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getPointBlankRange(withPup);
}

int WeaponObjectAdapter::getIdealRange(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getIdealRange(withPup);
}

void WeaponObjectAdapter::setIdealRange(int value) {
	(static_cast<WeaponObject*>(stub))->setIdealRange(value);
}

int WeaponObjectAdapter::getMaxRange(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getMaxRange(withPup);
}

void WeaponObjectAdapter::setMaxRange(int value) {
	(static_cast<WeaponObject*>(stub))->setMaxRange(value);
}

int WeaponObjectAdapter::getIdealAccuracy(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getIdealAccuracy(withPup);
}

void WeaponObjectAdapter::setIdealAccuracy(int value) {
	(static_cast<WeaponObject*>(stub))->setIdealAccuracy(value);
}

void WeaponObjectAdapter::setArmorPiercing(int value) {
	(static_cast<WeaponObject*>(stub))->setArmorPiercing(value);
}

int WeaponObjectAdapter::getArmorPiercing() const {
	return (static_cast<WeaponObject*>(stub))->getArmorPiercing();
}

int WeaponObjectAdapter::getMaxRangeAccuracy(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getMaxRangeAccuracy(withPup);
}

void WeaponObjectAdapter::setMaxRangeAccuracy(int value) {
	(static_cast<WeaponObject*>(stub))->setMaxRangeAccuracy(value);
}

float WeaponObjectAdapter::getAttackSpeed(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getAttackSpeed(withPup);
}

void WeaponObjectAdapter::setAttackSpeed(float value) {
	(static_cast<WeaponObject*>(stub))->setAttackSpeed(value);
}

float WeaponObjectAdapter::getMaxDamage(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getMaxDamage(withPup);
}

void WeaponObjectAdapter::setMaxDamage(float value) {
	(static_cast<WeaponObject*>(stub))->setMaxDamage(value);
}

float WeaponObjectAdapter::getMinDamage(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getMinDamage(withPup);
}

void WeaponObjectAdapter::setMinDamage(float value) {
	(static_cast<WeaponObject*>(stub))->setMinDamage(value);
}

float WeaponObjectAdapter::getWoundsRatio(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getWoundsRatio(withPup);
}

void WeaponObjectAdapter::setWoundsRatio(float value) {
	(static_cast<WeaponObject*>(stub))->setWoundsRatio(value);
}

float WeaponObjectAdapter::getDamageRadius(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getDamageRadius(withPup);
}

void WeaponObjectAdapter::setDamageRadius(float value) {
	(static_cast<WeaponObject*>(stub))->setDamageRadius(value);
}

int WeaponObjectAdapter::getHealthAttackCost(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getHealthAttackCost(withPup);
}

void WeaponObjectAdapter::setHealthAttackCost(int value) {
	(static_cast<WeaponObject*>(stub))->setHealthAttackCost(value);
}

int WeaponObjectAdapter::getActionAttackCost(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getActionAttackCost(withPup);
}

void WeaponObjectAdapter::setActionAttackCost(int value) {
	(static_cast<WeaponObject*>(stub))->setActionAttackCost(value);
}

int WeaponObjectAdapter::getMindAttackCost(bool withPup) const {
	return (static_cast<WeaponObject*>(stub))->getMindAttackCost(withPup);
}

void WeaponObjectAdapter::setMindAttackCost(int value) {
	(static_cast<WeaponObject*>(stub))->setMindAttackCost(value);
}

float WeaponObjectAdapter::getForceCost() const {
	return (static_cast<WeaponObject*>(stub))->getForceCost();
}

void WeaponObjectAdapter::setForceCost(float value) {
	(static_cast<WeaponObject*>(stub))->setForceCost(value);
}

int WeaponObjectAdapter::getBladeColor() const {
	return (static_cast<WeaponObject*>(stub))->getBladeColor();
}

void WeaponObjectAdapter::setBladeColor(int value) {
	(static_cast<WeaponObject*>(stub))->setBladeColor(value);
}

int WeaponObjectAdapter::getDamageType() const {
	return (static_cast<WeaponObject*>(stub))->getDamageType();
}

String WeaponObjectAdapter::getXpType() const {
	return (static_cast<WeaponObject*>(stub))->getXpType();
}

int WeaponObjectAdapter::getNumberOfDots() const {
	return (static_cast<WeaponObject*>(stub))->getNumberOfDots();
}

int WeaponObjectAdapter::getDotType(int index) const {
	return (static_cast<WeaponObject*>(stub))->getDotType(index);
}

int WeaponObjectAdapter::getDotAttribute(int index) const {
	return (static_cast<WeaponObject*>(stub))->getDotAttribute(index);
}

int WeaponObjectAdapter::getDotStrength(int index) const {
	return (static_cast<WeaponObject*>(stub))->getDotStrength(index);
}

int WeaponObjectAdapter::getDotDuration(int index) const {
	return (static_cast<WeaponObject*>(stub))->getDotDuration(index);
}

int WeaponObjectAdapter::getDotPotency(int index) const {
	return (static_cast<WeaponObject*>(stub))->getDotPotency(index);
}

int WeaponObjectAdapter::getDotUses(int index) const {
	return (static_cast<WeaponObject*>(stub))->getDotUses(index);
}

void WeaponObjectAdapter::addDotType(int t) {
	(static_cast<WeaponObject*>(stub))->addDotType(t);
}

void WeaponObjectAdapter::addDotAttribute(int a) {
	(static_cast<WeaponObject*>(stub))->addDotAttribute(a);
}

void WeaponObjectAdapter::addDotStrength(int s) {
	(static_cast<WeaponObject*>(stub))->addDotStrength(s);
}

void WeaponObjectAdapter::addDotDuration(int du) {
	(static_cast<WeaponObject*>(stub))->addDotDuration(du);
}

void WeaponObjectAdapter::addDotPotency(int po) {
	(static_cast<WeaponObject*>(stub))->addDotPotency(po);
}

void WeaponObjectAdapter::addDotUses(int u) {
	(static_cast<WeaponObject*>(stub))->addDotUses(u);
}

void WeaponObjectAdapter::setDotUses(int u, int index) {
	(static_cast<WeaponObject*>(stub))->setDotUses(u, index);
}

String WeaponObjectAdapter::getWeaponType() {
	return (static_cast<WeaponObject*>(stub))->getWeaponType();
}

bool WeaponObjectAdapter::isUnarmedWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isUnarmedWeapon();
}

bool WeaponObjectAdapter::isMeleeWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isMeleeWeapon();
}

bool WeaponObjectAdapter::isRangedWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isRangedWeapon();
}

bool WeaponObjectAdapter::isRifleWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isRifleWeapon();
}

bool WeaponObjectAdapter::isThrownWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isThrownWeapon();
}

bool WeaponObjectAdapter::isHeavyWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isHeavyWeapon();
}

bool WeaponObjectAdapter::isSpecialHeavyWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isSpecialHeavyWeapon();
}

bool WeaponObjectAdapter::isLightningRifle() const {
	return (static_cast<WeaponObject*>(stub))->isLightningRifle();
}

bool WeaponObjectAdapter::isFlameThrower() const {
	return (static_cast<WeaponObject*>(stub))->isFlameThrower();
}

bool WeaponObjectAdapter::isHeavyAcidRifle() const {
	return (static_cast<WeaponObject*>(stub))->isHeavyAcidRifle();
}

bool WeaponObjectAdapter::isCarbineWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isCarbineWeapon();
}

bool WeaponObjectAdapter::isPistolWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isPistolWeapon();
}

bool WeaponObjectAdapter::isOneHandMeleeWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isOneHandMeleeWeapon();
}

bool WeaponObjectAdapter::isPolearmWeaponObject() const {
	return (static_cast<WeaponObject*>(stub))->isPolearmWeaponObject();
}

bool WeaponObjectAdapter::isTwoHandMeleeWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isTwoHandMeleeWeapon();
}

bool WeaponObjectAdapter::isMineWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isMineWeapon();
}

bool WeaponObjectAdapter::isJediWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isJediWeapon();
}

bool WeaponObjectAdapter::isJediOneHandedWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isJediOneHandedWeapon();
}

bool WeaponObjectAdapter::isJediTwoHandedWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isJediTwoHandedWeapon();
}

bool WeaponObjectAdapter::isJediPolearmWeapon() const {
	return (static_cast<WeaponObject*>(stub))->isJediPolearmWeapon();
}

unsigned int WeaponObjectAdapter::getWeaponBitmask() const {
	return (static_cast<WeaponObject*>(stub))->getWeaponBitmask();
}

bool WeaponObjectAdapter::isWeaponObject() {
	return (static_cast<WeaponObject*>(stub))->isWeaponObject();
}

bool WeaponObjectAdapter::hasPowerup() const {
	return (static_cast<WeaponObject*>(stub))->hasPowerup();
}

bool WeaponObjectAdapter::applyPowerup(CreatureObject* player, PowerupObject* pup) {
	return (static_cast<WeaponObject*>(stub))->applyPowerup(player, pup);
}

PowerupObject* WeaponObjectAdapter::removePowerup() {
	return (static_cast<WeaponObject*>(stub))->removePowerup();
}

void WeaponObjectAdapter::decreasePowerupUses(CreatureObject* player) {
	(static_cast<WeaponObject*>(stub))->decreasePowerupUses(player);
}

String WeaponObjectAdapter::repairAttempt(int repairChance) {
	return (static_cast<WeaponObject*>(stub))->repairAttempt(repairChance);
}

void WeaponObjectAdapter::decay(CreatureObject* user) {
	(static_cast<WeaponObject*>(stub))->decay(user);
}

void WeaponObjectAdapter::setDamageSlice(float value) {
	(static_cast<WeaponObject*>(stub))->setDamageSlice(value);
}

void WeaponObjectAdapter::setSpeedSlice(float value) {
	(static_cast<WeaponObject*>(stub))->setSpeedSlice(value);
}

void WeaponObjectAdapter::applySkillModsTo(CreatureObject* creature) const {
	(static_cast<WeaponObject*>(stub))->applySkillModsTo(creature);
}

void WeaponObjectAdapter::removeSkillModsFrom(CreatureObject* creature) {
	(static_cast<WeaponObject*>(stub))->removeSkillModsFrom(creature);
}

void WeaponObjectAdapter::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	(static_cast<WeaponObject*>(stub))->addSkillMod(skillType, skillMod, value, notifyClient);
}

/*
 *	WeaponObjectHelper
 */

WeaponObjectHelper* WeaponObjectHelper::staticInitializer = WeaponObjectHelper::instance();

WeaponObjectHelper::WeaponObjectHelper() {
	className = "WeaponObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void WeaponObjectHelper::finalizeHelper() {
	WeaponObjectHelper::finalize();
}

DistributedObject* WeaponObjectHelper::instantiateObject() {
	return new WeaponObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* WeaponObjectHelper::instantiateServant() {
	return new WeaponObjectImplementation();
}

DistributedObjectPOD* WeaponObjectHelper::instantiatePOD() {
	return new WeaponObjectPOD();
}

DistributedObjectAdapter* WeaponObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new WeaponObjectAdapter(static_cast<WeaponObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	WeaponObjectPOD
 */

WeaponObjectPOD::~WeaponObjectPOD() {
	finalize();
}

WeaponObjectPOD::WeaponObjectPOD(void) {
	_className = "WeaponObject";
}


void WeaponObjectPOD::writeJSON(nlohmann::json& j) {
	TangibleObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (attackType)
		thisObject["attackType"] = attackType.value();

	if (weaponEffect)
		thisObject["weaponEffect"] = weaponEffect.value();

	if (weaponEffectIndex)
		thisObject["weaponEffectIndex"] = weaponEffectIndex.value();

	if (certified)
		thisObject["certified"] = certified.value();

	if (armorPiercing)
		thisObject["armorPiercing"] = armorPiercing.value();

	if (pointBlankAccuracy)
		thisObject["pointBlankAccuracy"] = pointBlankAccuracy.value();

	if (pointBlankRange)
		thisObject["pointBlankRange"] = pointBlankRange.value();

	if (idealRange)
		thisObject["idealRange"] = idealRange.value();

	if (idealAccuracy)
		thisObject["idealAccuracy"] = idealAccuracy.value();

	if (maxRange)
		thisObject["maxRange"] = maxRange.value();

	if (maxRangeAccuracy)
		thisObject["maxRangeAccuracy"] = maxRangeAccuracy.value();

	if (damageType)
		thisObject["damageType"] = damageType.value();

	if (attackSpeed)
		thisObject["attackSpeed"] = attackSpeed.value();

	if (minDamage)
		thisObject["minDamage"] = minDamage.value();

	if (maxDamage)
		thisObject["maxDamage"] = maxDamage.value();

	if (damageRadius)
		thisObject["damageRadius"] = damageRadius.value();

	if (woundsRatio)
		thisObject["woundsRatio"] = woundsRatio.value();

	if (healthAttackCost)
		thisObject["healthAttackCost"] = healthAttackCost.value();

	if (actionAttackCost)
		thisObject["actionAttackCost"] = actionAttackCost.value();

	if (mindAttackCost)
		thisObject["mindAttackCost"] = mindAttackCost.value();

	if (forceCost)
		thisObject["forceCost"] = forceCost.value();

	if (saberForceCost)
		thisObject["saberForceCost"] = saberForceCost.value();

	if (bladeColor)
		thisObject["bladeColor"] = bladeColor.value();

	if (powerupObject)
		thisObject["powerupObject"] = powerupObject.value();

	if (damageSlice)
		thisObject["damageSlice"] = damageSlice.value();

	if (speedSlice)
		thisObject["speedSlice"] = speedSlice.value();

	if (dotType)
		thisObject["dotType"] = dotType.value();

	if (dotAttribute)
		thisObject["dotAttribute"] = dotAttribute.value();

	if (dotStrength)
		thisObject["dotStrength"] = dotStrength.value();

	if (dotDuration)
		thisObject["dotDuration"] = dotDuration.value();

	if (dotPotency)
		thisObject["dotPotency"] = dotPotency.value();

	if (dotUses)
		thisObject["dotUses"] = dotUses.value();

	if (wearableSkillMods)
		thisObject["wearableSkillMods"] = wearableSkillMods.value();

	j["WeaponObject"] = thisObject;
}


void WeaponObjectPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = WeaponObjectPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int WeaponObjectPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (attackType) {
	_nameHashCode = 0xaf7c0a4b; //WeaponObject.attackType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&attackType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (weaponEffect) {
	_nameHashCode = 0xce821459; //WeaponObject.weaponEffect
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&weaponEffect.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (weaponEffectIndex) {
	_nameHashCode = 0x3f0d10bc; //WeaponObject.weaponEffectIndex
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&weaponEffectIndex.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (certified) {
	_nameHashCode = 0x3115d69d; //WeaponObject.certified
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&certified.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (armorPiercing) {
	_nameHashCode = 0x6b12d54f; //WeaponObject.armorPiercing
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&armorPiercing.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (pointBlankAccuracy) {
	_nameHashCode = 0x152e5f75; //WeaponObject.pointBlankAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pointBlankAccuracy.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (pointBlankRange) {
	_nameHashCode = 0x670ae4ff; //WeaponObject.pointBlankRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pointBlankRange.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (idealRange) {
	_nameHashCode = 0xc470ee9f; //WeaponObject.idealRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&idealRange.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (idealAccuracy) {
	_nameHashCode = 0xd480b36e; //WeaponObject.idealAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&idealAccuracy.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxRange) {
	_nameHashCode = 0x9890e346; //WeaponObject.maxRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxRange.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxRangeAccuracy) {
	_nameHashCode = 0x2613027b; //WeaponObject.maxRangeAccuracy
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxRangeAccuracy.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (damageType) {
	_nameHashCode = 0xb67af664; //WeaponObject.damageType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&damageType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (attackSpeed) {
	_nameHashCode = 0x7e68aff1; //WeaponObject.attackSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&attackSpeed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (minDamage) {
	_nameHashCode = 0x244a18e6; //WeaponObject.minDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&minDamage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxDamage) {
	_nameHashCode = 0xb1865fc5; //WeaponObject.maxDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&maxDamage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (damageRadius) {
	_nameHashCode = 0x80491112; //WeaponObject.damageRadius
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&damageRadius.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (woundsRatio) {
	_nameHashCode = 0xc038e1ce; //WeaponObject.woundsRatio
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&woundsRatio.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (healthAttackCost) {
	_nameHashCode = 0x2b72cd02; //WeaponObject.healthAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&healthAttackCost.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (actionAttackCost) {
	_nameHashCode = 0x9957963b; //WeaponObject.actionAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&actionAttackCost.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (mindAttackCost) {
	_nameHashCode = 0x987636de; //WeaponObject.mindAttackCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&mindAttackCost.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (forceCost) {
	_nameHashCode = 0x42b7f5e; //WeaponObject.forceCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forceCost.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (saberForceCost) {
	_nameHashCode = 0xb924163f; //WeaponObject.saberForceCost
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&saberForceCost.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (bladeColor) {
	_nameHashCode = 0x2e53bceb; //WeaponObject.bladeColor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&bladeColor.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (powerupObject) {
	_nameHashCode = 0x39d8ea3d; //WeaponObject.powerupObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<PowerupObjectPOD* > >::toBinaryStream(&powerupObject.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (damageSlice) {
	_nameHashCode = 0x8cf72617; //WeaponObject.damageSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&damageSlice.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (speedSlice) {
	_nameHashCode = 0x949b206c; //WeaponObject.speedSlice
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&speedSlice.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dotType) {
	_nameHashCode = 0x40433917; //WeaponObject.dotType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dotAttribute) {
	_nameHashCode = 0x5662a29d; //WeaponObject.dotAttribute
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotAttribute.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dotStrength) {
	_nameHashCode = 0xe6ae6a5b; //WeaponObject.dotStrength
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotStrength.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dotDuration) {
	_nameHashCode = 0xe8f7f5b9; //WeaponObject.dotDuration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotDuration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dotPotency) {
	_nameHashCode = 0x8f640033; //WeaponObject.dotPotency
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotPotency.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dotUses) {
	_nameHashCode = 0x40a17332; //WeaponObject.dotUses
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&dotUses.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (wearableSkillMods) {
	_nameHashCode = 0xdeec3bb7; //WeaponObject.wearableSkillMods
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&wearableSkillMods.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool WeaponObjectPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xaf7c0a4b: //WeaponObject.attackType
		{
			int _mnattackType;
			TypeInfo<int >::parseFromBinaryStream(&_mnattackType, stream);
			attackType = std::move(_mnattackType);
		}
		return true;

	case 0xce821459: //WeaponObject.weaponEffect
		{
			String _mnweaponEffect;
			TypeInfo<String >::parseFromBinaryStream(&_mnweaponEffect, stream);
			weaponEffect = std::move(_mnweaponEffect);
		}
		return true;

	case 0x3f0d10bc: //WeaponObject.weaponEffectIndex
		{
			int _mnweaponEffectIndex;
			TypeInfo<int >::parseFromBinaryStream(&_mnweaponEffectIndex, stream);
			weaponEffectIndex = std::move(_mnweaponEffectIndex);
		}
		return true;

	case 0x3115d69d: //WeaponObject.certified
		{
			bool _mncertified;
			TypeInfo<bool >::parseFromBinaryStream(&_mncertified, stream);
			certified = std::move(_mncertified);
		}
		return true;

	case 0x6b12d54f: //WeaponObject.armorPiercing
		{
			int _mnarmorPiercing;
			TypeInfo<int >::parseFromBinaryStream(&_mnarmorPiercing, stream);
			armorPiercing = std::move(_mnarmorPiercing);
		}
		return true;

	case 0x152e5f75: //WeaponObject.pointBlankAccuracy
		{
			int _mnpointBlankAccuracy;
			TypeInfo<int >::parseFromBinaryStream(&_mnpointBlankAccuracy, stream);
			pointBlankAccuracy = std::move(_mnpointBlankAccuracy);
		}
		return true;

	case 0x670ae4ff: //WeaponObject.pointBlankRange
		{
			int _mnpointBlankRange;
			TypeInfo<int >::parseFromBinaryStream(&_mnpointBlankRange, stream);
			pointBlankRange = std::move(_mnpointBlankRange);
		}
		return true;

	case 0xc470ee9f: //WeaponObject.idealRange
		{
			int _mnidealRange;
			TypeInfo<int >::parseFromBinaryStream(&_mnidealRange, stream);
			idealRange = std::move(_mnidealRange);
		}
		return true;

	case 0xd480b36e: //WeaponObject.idealAccuracy
		{
			int _mnidealAccuracy;
			TypeInfo<int >::parseFromBinaryStream(&_mnidealAccuracy, stream);
			idealAccuracy = std::move(_mnidealAccuracy);
		}
		return true;

	case 0x9890e346: //WeaponObject.maxRange
		{
			int _mnmaxRange;
			TypeInfo<int >::parseFromBinaryStream(&_mnmaxRange, stream);
			maxRange = std::move(_mnmaxRange);
		}
		return true;

	case 0x2613027b: //WeaponObject.maxRangeAccuracy
		{
			int _mnmaxRangeAccuracy;
			TypeInfo<int >::parseFromBinaryStream(&_mnmaxRangeAccuracy, stream);
			maxRangeAccuracy = std::move(_mnmaxRangeAccuracy);
		}
		return true;

	case 0xb67af664: //WeaponObject.damageType
		{
			int _mndamageType;
			TypeInfo<int >::parseFromBinaryStream(&_mndamageType, stream);
			damageType = std::move(_mndamageType);
		}
		return true;

	case 0x7e68aff1: //WeaponObject.attackSpeed
		{
			float _mnattackSpeed;
			TypeInfo<float >::parseFromBinaryStream(&_mnattackSpeed, stream);
			attackSpeed = std::move(_mnattackSpeed);
		}
		return true;

	case 0x244a18e6: //WeaponObject.minDamage
		{
			float _mnminDamage;
			TypeInfo<float >::parseFromBinaryStream(&_mnminDamage, stream);
			minDamage = std::move(_mnminDamage);
		}
		return true;

	case 0xb1865fc5: //WeaponObject.maxDamage
		{
			float _mnmaxDamage;
			TypeInfo<float >::parseFromBinaryStream(&_mnmaxDamage, stream);
			maxDamage = std::move(_mnmaxDamage);
		}
		return true;

	case 0x80491112: //WeaponObject.damageRadius
		{
			float _mndamageRadius;
			TypeInfo<float >::parseFromBinaryStream(&_mndamageRadius, stream);
			damageRadius = std::move(_mndamageRadius);
		}
		return true;

	case 0xc038e1ce: //WeaponObject.woundsRatio
		{
			float _mnwoundsRatio;
			TypeInfo<float >::parseFromBinaryStream(&_mnwoundsRatio, stream);
			woundsRatio = std::move(_mnwoundsRatio);
		}
		return true;

	case 0x2b72cd02: //WeaponObject.healthAttackCost
		{
			int _mnhealthAttackCost;
			TypeInfo<int >::parseFromBinaryStream(&_mnhealthAttackCost, stream);
			healthAttackCost = std::move(_mnhealthAttackCost);
		}
		return true;

	case 0x9957963b: //WeaponObject.actionAttackCost
		{
			int _mnactionAttackCost;
			TypeInfo<int >::parseFromBinaryStream(&_mnactionAttackCost, stream);
			actionAttackCost = std::move(_mnactionAttackCost);
		}
		return true;

	case 0x987636de: //WeaponObject.mindAttackCost
		{
			int _mnmindAttackCost;
			TypeInfo<int >::parseFromBinaryStream(&_mnmindAttackCost, stream);
			mindAttackCost = std::move(_mnmindAttackCost);
		}
		return true;

	case 0x42b7f5e: //WeaponObject.forceCost
		{
			int _mnforceCost;
			TypeInfo<int >::parseFromBinaryStream(&_mnforceCost, stream);
			forceCost = std::move(_mnforceCost);
		}
		return true;

	case 0xb924163f: //WeaponObject.saberForceCost
		{
			float _mnsaberForceCost;
			TypeInfo<float >::parseFromBinaryStream(&_mnsaberForceCost, stream);
			saberForceCost = std::move(_mnsaberForceCost);
		}
		return true;

	case 0x2e53bceb: //WeaponObject.bladeColor
		{
			int _mnbladeColor;
			TypeInfo<int >::parseFromBinaryStream(&_mnbladeColor, stream);
			bladeColor = std::move(_mnbladeColor);
		}
		return true;

	case 0x39d8ea3d: //WeaponObject.powerupObject
		{
			ManagedReference<PowerupObjectPOD* > _mnpowerupObject;
			TypeInfo<ManagedReference<PowerupObjectPOD* > >::parseFromBinaryStream(&_mnpowerupObject, stream);
			powerupObject = std::move(_mnpowerupObject);
		}
		return true;

	case 0x8cf72617: //WeaponObject.damageSlice
		{
			float _mndamageSlice;
			TypeInfo<float >::parseFromBinaryStream(&_mndamageSlice, stream);
			damageSlice = std::move(_mndamageSlice);
		}
		return true;

	case 0x949b206c: //WeaponObject.speedSlice
		{
			float _mnspeedSlice;
			TypeInfo<float >::parseFromBinaryStream(&_mnspeedSlice, stream);
			speedSlice = std::move(_mnspeedSlice);
		}
		return true;

	case 0x40433917: //WeaponObject.dotType
		{
			Vector<int> _mndotType;
			TypeInfo<Vector<int> >::parseFromBinaryStream(&_mndotType, stream);
			dotType = std::move(_mndotType);
		}
		return true;

	case 0x5662a29d: //WeaponObject.dotAttribute
		{
			Vector<int> _mndotAttribute;
			TypeInfo<Vector<int> >::parseFromBinaryStream(&_mndotAttribute, stream);
			dotAttribute = std::move(_mndotAttribute);
		}
		return true;

	case 0xe6ae6a5b: //WeaponObject.dotStrength
		{
			Vector<int> _mndotStrength;
			TypeInfo<Vector<int> >::parseFromBinaryStream(&_mndotStrength, stream);
			dotStrength = std::move(_mndotStrength);
		}
		return true;

	case 0xe8f7f5b9: //WeaponObject.dotDuration
		{
			Vector<int> _mndotDuration;
			TypeInfo<Vector<int> >::parseFromBinaryStream(&_mndotDuration, stream);
			dotDuration = std::move(_mndotDuration);
		}
		return true;

	case 0x8f640033: //WeaponObject.dotPotency
		{
			Vector<int> _mndotPotency;
			TypeInfo<Vector<int> >::parseFromBinaryStream(&_mndotPotency, stream);
			dotPotency = std::move(_mndotPotency);
		}
		return true;

	case 0x40a17332: //WeaponObject.dotUses
		{
			Vector<int> _mndotUses;
			TypeInfo<Vector<int> >::parseFromBinaryStream(&_mndotUses, stream);
			dotUses = std::move(_mndotUses);
		}
		return true;

	case 0xdeec3bb7: //WeaponObject.wearableSkillMods
		{
			VectorMap<String, int> _mnwearableSkillMods;
			TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&_mnwearableSkillMods, stream);
			wearableSkillMods = std::move(_mnwearableSkillMods);
		}
		return true;

	}

	return false;
}

void WeaponObjectPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(WeaponObjectPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void WeaponObjectPOD::writeObjectCompact(ObjectOutputStream* stream) {
	TangibleObjectPOD::writeObjectCompact(stream);

	TypeInfo<int >::toBinaryStream(&attackType.value(), stream);

	TypeInfo<String >::toBinaryStream(&weaponEffect.value(), stream);

	TypeInfo<int >::toBinaryStream(&weaponEffectIndex.value(), stream);

	TypeInfo<bool >::toBinaryStream(&certified.value(), stream);

	TypeInfo<int >::toBinaryStream(&armorPiercing.value(), stream);

	TypeInfo<int >::toBinaryStream(&pointBlankAccuracy.value(), stream);

	TypeInfo<int >::toBinaryStream(&pointBlankRange.value(), stream);

	TypeInfo<int >::toBinaryStream(&idealRange.value(), stream);

	TypeInfo<int >::toBinaryStream(&idealAccuracy.value(), stream);

	TypeInfo<int >::toBinaryStream(&maxRange.value(), stream);

	TypeInfo<int >::toBinaryStream(&maxRangeAccuracy.value(), stream);

	TypeInfo<int >::toBinaryStream(&damageType.value(), stream);

	TypeInfo<float >::toBinaryStream(&attackSpeed.value(), stream);

	TypeInfo<float >::toBinaryStream(&minDamage.value(), stream);

	TypeInfo<float >::toBinaryStream(&maxDamage.value(), stream);

	TypeInfo<float >::toBinaryStream(&damageRadius.value(), stream);

	TypeInfo<float >::toBinaryStream(&woundsRatio.value(), stream);

	TypeInfo<int >::toBinaryStream(&healthAttackCost.value(), stream);

	TypeInfo<int >::toBinaryStream(&actionAttackCost.value(), stream);

	TypeInfo<int >::toBinaryStream(&mindAttackCost.value(), stream);

	TypeInfo<int >::toBinaryStream(&forceCost.value(), stream);

	TypeInfo<float >::toBinaryStream(&saberForceCost.value(), stream);

	TypeInfo<int >::toBinaryStream(&bladeColor.value(), stream);

	TypeInfo<ManagedReference<PowerupObjectPOD* > >::toBinaryStream(&powerupObject.value(), stream);

	TypeInfo<float >::toBinaryStream(&damageSlice.value(), stream);

	TypeInfo<float >::toBinaryStream(&speedSlice.value(), stream);

	TypeInfo<Vector<int> >::toBinaryStream(&dotType.value(), stream);

	TypeInfo<Vector<int> >::toBinaryStream(&dotAttribute.value(), stream);

	TypeInfo<Vector<int> >::toBinaryStream(&dotStrength.value(), stream);

	TypeInfo<Vector<int> >::toBinaryStream(&dotDuration.value(), stream);

	TypeInfo<Vector<int> >::toBinaryStream(&dotPotency.value(), stream);

	TypeInfo<Vector<int> >::toBinaryStream(&dotUses.value(), stream);

	TypeInfo<VectorMap<String, int> >::toBinaryStream(&wearableSkillMods.value(), stream);


}

