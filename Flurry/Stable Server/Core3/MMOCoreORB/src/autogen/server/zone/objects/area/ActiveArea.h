/*
 *	autogen/server/zone/objects/area/ActiveArea.h generated by engine3 IDL compiler 0.70
 */

#ifndef ACTIVEAREA_H_
#define ACTIVEAREA_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace zone {
namespace objects {
namespace area {
namespace areashapes {

class AreaShape;

class AreaShapePOD;

} // namespace areashapes
} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area::areashapes;

namespace server {
namespace zone {
namespace objects {
namespace pathfinding {

class NavArea;

class NavAreaPOD;

} // namespace pathfinding
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::pathfinding;

namespace server {
namespace zone {

class Zone;

class ZonePOD;

} // namespace zone
} // namespace server

using namespace server::zone;

#include "gmock/gmock.h"

#include "system/util/Vector.h"

#include "server/zone/objects/scene/SceneObject.h"

namespace server {
namespace zone {
namespace objects {
namespace area {

class ActiveArea : public SceneObject {
public:
	ActiveArea();

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendTo(SceneObject* player, bool doClose, bool forceLoadContainer = true);

	virtual void enqueueEnterEvent(SceneObject* obj);

	virtual void enqueueExitEvent(SceneObject* obj);

	void notifyEnter(SceneObject* object);

	void notifyExit(SceneObject* object);

	void setZone(Zone* zone);

	bool isActiveArea();

	bool isRegion();

	bool isCityRegion();

	bool isNavArea();

	NavArea* asNavArea();

	bool isNoBuildArea() const;

	bool isCampingPermitted() const;

	bool containsPoint(float x, float y, unsigned long long cellid);

	bool containsPoint(float x, float y);

	float getRadius2();

	void setNoBuildArea(bool val);

	void setCampingPermitted(bool val);

	void setMunicipalZone(bool val);

	void setRadius(float r);

	bool isCampArea();

	void setNoSpawnArea(bool val);

	bool isNoSpawnArea() const;

	bool isMunicipalZone() const;

	unsigned long long getCellObjectID() const;

	void setCellObjectID(unsigned long long celloid);

	void setAreaShape(AreaShape* area);

	AreaShape* getAreaShape() const;

	bool intersectsWith(ActiveArea* area);

	void attachScenery(SceneObject* scene);

	void initializeChildObject(SceneObject* controllerObject);

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	ActiveArea(DummyConstructorParameter* param);

	virtual ~ActiveArea();

	friend class ActiveAreaHelper;
};

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

namespace server {
namespace zone {
namespace objects {
namespace area {

class ActiveAreaImplementation : public SceneObjectImplementation {
protected:
	bool noBuildArea;

	bool campingPermitted;

	bool municipalZone;

	unsigned long long cellObjectID;

	bool noSpawnArea;

	ManagedReference<AreaShape* > areaShape;

	Vector<ManagedReference<SceneObject* > > attachedScenery;

public:
	ActiveAreaImplementation();

	ActiveAreaImplementation(DummyConstructorParameter* param);

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendTo(SceneObject* player, bool doClose, bool forceLoadContainer = true);

	virtual void enqueueEnterEvent(SceneObject* obj);

	virtual void enqueueExitEvent(SceneObject* obj);

	virtual void notifyEnter(SceneObject* object);

	virtual void notifyExit(SceneObject* object);

	void setZone(Zone* zone);

	bool isActiveArea();

	virtual bool isRegion();

	virtual bool isCityRegion();

	virtual bool isNavArea();

	virtual NavArea* asNavArea();

	bool isNoBuildArea() const;

	bool isCampingPermitted() const;

	bool containsPoint(float x, float y, unsigned long long cellid);

	virtual bool containsPoint(float x, float y);

	float getRadius2();

	void setNoBuildArea(bool val);

	void setCampingPermitted(bool val);

	void setMunicipalZone(bool val);

	void setRadius(float r);

	virtual bool isCampArea();

	void setNoSpawnArea(bool val);

	bool isNoSpawnArea() const;

	bool isMunicipalZone() const;

	unsigned long long getCellObjectID() const;

	void setCellObjectID(unsigned long long celloid);

	void setAreaShape(AreaShape* area);

	AreaShape* getAreaShape() const;

	bool intersectsWith(ActiveArea* area);

	void attachScenery(SceneObject* scene);

	void initializeChildObject(SceneObject* controllerObject);

	WeakReference<ActiveArea*> _this;

	operator const ActiveArea*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	virtual void writeJSON(nlohmann::json& j);
protected:
	virtual ~ActiveAreaImplementation();

	void finalize();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class ActiveArea;
};

class ActiveAreaAdapter : public SceneObjectAdapter {
public:
	ActiveAreaAdapter(ActiveArea* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void sendTo(SceneObject* player, bool doClose, bool forceLoadContainer);

	void enqueueEnterEvent(SceneObject* obj);

	void enqueueExitEvent(SceneObject* obj);

	void notifyEnter(SceneObject* object);

	void notifyExit(SceneObject* object);

	void setZone(Zone* zone);

	bool isActiveArea();

	bool isRegion();

	bool isCityRegion();

	bool isNavArea();

	bool isNoBuildArea() const;

	bool isCampingPermitted() const;

	bool containsPoint(float x, float y, unsigned long long cellid);

	bool containsPoint(float x, float y);

	float getRadius2();

	void setNoBuildArea(bool val);

	void setCampingPermitted(bool val);

	void setMunicipalZone(bool val);

	void setRadius(float r);

	bool isCampArea();

	void setNoSpawnArea(bool val);

	bool isNoSpawnArea() const;

	bool isMunicipalZone() const;

	unsigned long long getCellObjectID() const;

	void setCellObjectID(unsigned long long celloid);

	void setAreaShape(AreaShape* area);

	AreaShape* getAreaShape() const;

	bool intersectsWith(ActiveArea* area);

	void attachScenery(SceneObject* scene);

	void initializeChildObject(SceneObject* controllerObject);

};

class ActiveAreaHelper : public DistributedObjectClassHelper, public Singleton<ActiveAreaHelper> {
	static ActiveAreaHelper* staticInitializer;

public:
	ActiveAreaHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<ActiveAreaHelper>;
};

class MockActiveArea : public ActiveArea {
public:

	MOCK_METHOD1(enqueueEnterEvent,void(SceneObject* obj));
	MOCK_METHOD1(enqueueExitEvent,void(SceneObject* obj));
	MOCK_METHOD0(getWorldPositionX,float());
	MOCK_METHOD0(getWorldPositionY,float());
	MOCK_METHOD0(getWorldPositionZ,float());
	MOCK_METHOD0(getWorldPosition,Vector3());

};

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

namespace server {
namespace zone {
namespace objects {
namespace area {

class ActiveAreaPOD : public SceneObjectPOD {
public:
	Optional<bool> noBuildArea;

	Optional<bool> campingPermitted;

	Optional<bool> municipalZone;

	Optional<unsigned long long> cellObjectID;

	Optional<bool> noSpawnArea;

	Optional<ManagedReference<AreaShapePOD* >> areaShape;

	String _className;
	ActiveAreaPOD();
	virtual void writeJSON(nlohmann::json& j);
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~ActiveAreaPOD();

};

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

#endif /*ACTIVEAREAPOD_H_*/
