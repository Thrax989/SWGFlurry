/*
 *	autogen/server/zone/objects/tangible/component/Component.cpp generated by engine3 IDL compiler 0.70
 */

#include "Component.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/objects/creature/CreatureObject.h"

/*
 *	ComponentStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 3918114691,RPC_ISCOMPONENT__,RPC_GENERATELOOTSTATS__STRING_INT_,RPC_COMPARE__COMPONENT_,RPC_HASKEY__STRING_,RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_BOOL_,RPC_GETATTRIBUTEVALUE__STRING_,RPC_GETATTRIBUTEPRECISION__STRING_,RPC_GETATTRIBUTETITLE__STRING_,RPC_GETATTRIBUTEHIDDEN__STRING_,RPC_SETPROPERTYTOHIDDEN__STRING_,RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_,RPC_GETPROPERTYCOUNT__,RPC_GETPROPERTY__INT_,RPC_CHANGEATTRIBUTEVALUE__STRING_FLOAT_};

Component::Component() : TangibleObject(DummyConstructorParameter::instance()) {
	ComponentImplementation* _implementation = new ComponentImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("Component");
}

Component::Component(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("Component");
}

Component::~Component() {
}



void Component::initializeTransientMembers() {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void Component::fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillObjectMenuResponse(menuResponse, player);
	}
}

void Component::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

bool Component::isComponent() {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCOMPONENT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isComponent();
	}
}

void Component::generateLootStats(const String& lootstring, int level) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GENERATELOOTSTATS__STRING_INT_);
		method.addAsciiParameter(lootstring);
		method.addSignedIntParameter(level);

		method.executeWithVoidReturn();
	} else {
		_implementation->generateLootStats(lootstring, level);
	}
}

bool Component::compare(Component* inCmpo) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPARE__COMPONENT_);
		method.addObjectParameter(inCmpo);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->compare(inCmpo);
	}
}

bool Component::hasKey(const String& key) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASKEY__STRING_);
		method.addAsciiParameter(key);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasKey(key);
	}
}

void Component::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updateCraftingValues(values, firstUpdate);
	}
}

void Component::addProperty(const String& attributeName, const float value, const int precision, const String& craftingTitle, const bool hidden) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_BOOL_);
		method.addAsciiParameter(attributeName);
		method.addFloatParameter(value);
		method.addSignedIntParameter(precision);
		method.addAsciiParameter(craftingTitle);
		method.addBooleanParameter(hidden);

		method.executeWithVoidReturn();
	} else {
		_implementation->addProperty(attributeName, value, precision, craftingTitle, hidden);
	}
}

float Component::getAttributeValue(const String& attributeName) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEVALUE__STRING_);
		method.addAsciiParameter(attributeName);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAttributeValue(attributeName);
	}
}

int Component::getAttributePrecision(const String& attributeName) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEPRECISION__STRING_);
		method.addAsciiParameter(attributeName);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAttributePrecision(attributeName);
	}
}

String Component::getAttributeTitle(const String& attributeName) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTETITLE__STRING_);
		method.addAsciiParameter(attributeName);

		String _return_getAttributeTitle;
		method.executeWithAsciiReturn(_return_getAttributeTitle);
		return _return_getAttributeTitle;
	} else {
		return _implementation->getAttributeTitle(attributeName);
	}
}

bool Component::getAttributeHidden(const String& attributeName) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTRIBUTEHIDDEN__STRING_);
		method.addAsciiParameter(attributeName);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getAttributeHidden(attributeName);
	}
}

void Component::setPropertyToHidden(const String& property) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPROPERTYTOHIDDEN__STRING_);
		method.addAsciiParameter(property);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPropertyToHidden(property);
	}
}

void Component::addProperty(const String& attribute, const float value, const int precision, const String& title) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_);
		method.addAsciiParameter(attribute);
		method.addFloatParameter(value);
		method.addSignedIntParameter(precision);
		method.addAsciiParameter(title);

		method.executeWithVoidReturn();
	} else {
		_implementation->addProperty(attribute, value, precision, title);
	}
}

int Component::getPropertyCount() {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPROPERTYCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPropertyCount();
	}
}

String Component::getProperty(const int j) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPROPERTY__INT_);
		method.addSignedIntParameter(j);

		String _return_getProperty;
		method.executeWithAsciiReturn(_return_getProperty);
		return _return_getProperty;
	} else {
		return _implementation->getProperty(j);
	}
}

bool Component::changeAttributeValue(const String& property, float value) {
	ComponentImplementation* _implementation = static_cast<ComponentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHANGEATTRIBUTEVALUE__STRING_FLOAT_);
		method.addAsciiParameter(property);
		method.addFloatParameter(value);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->changeAttributeValue(property, value);
	}
}

DistributedObjectServant* Component::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* Component::_getImplementationForRead() const {
	return _impl;
}

void Component::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ComponentImplementation
 */

ComponentImplementation::ComponentImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


ComponentImplementation::~ComponentImplementation() {
}


void ComponentImplementation::finalize() {
}

void ComponentImplementation::_initializeImplementation() {
	_setClassHelper(ComponentHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ComponentImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<Component*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ComponentImplementation::_getStub() {
	return _this.get();
}

ComponentImplementation::operator const Component*() {
	return _this.get();
}

void ComponentImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ComponentImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ComponentImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ComponentImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ComponentImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ComponentImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ComponentImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ComponentImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("Component");

}

void ComponentImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ComponentImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ComponentImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xc24a10f4: //Component.attributeMap
		TypeInfo<VectorMap<String, float> >::parseFromBinaryStream(&attributeMap, stream);
		return true;

	case 0xc95992bf: //Component.precisionMap
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&precisionMap, stream);
		return true;

	case 0xf7854fbd: //Component.titleMap
		TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&titleMap, stream);
		return true;

	case 0x55e3ae91: //Component.hiddenMap
		TypeInfo<VectorMap<String, bool> >::parseFromBinaryStream(&hiddenMap, stream);
		return true;

	case 0x1ce9d9cf: //Component.keyList
		TypeInfo<Vector<String> >::parseFromBinaryStream(&keyList, stream);
		return true;

	}

	return false;
}

void ComponentImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ComponentImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ComponentImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xc24a10f4; //Component.attributeMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, float> >::toBinaryStream(&attributeMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc95992bf; //Component.precisionMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&precisionMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf7854fbd; //Component.titleMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&titleMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x55e3ae91; //Component.hiddenMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, bool> >::toBinaryStream(&hiddenMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1ce9d9cf; //Component.keyList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&keyList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void ComponentImplementation::writeJSON(nlohmann::json& j) {
	TangibleObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["attributeMap"] = attributeMap;

	thisObject["precisionMap"] = precisionMap;

	thisObject["titleMap"] = titleMap;

	thisObject["hiddenMap"] = hiddenMap;

	thisObject["keyList"] = keyList;

	j["Component"] = thisObject;
}

ComponentImplementation::ComponentImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/component/Component.idl():  		Logger.setLoggingName("Component");
	Logger::setLoggingName("Component");
}

bool ComponentImplementation::isComponent() {
	// server/zone/objects/tangible/component/Component.idl():  		return true;
	return true;
}

bool ComponentImplementation::hasKey(const String& key) {
	// server/zone/objects/tangible/component/Component.idl():  		return 
	for (	// server/zone/objects/tangible/component/Component.idl():  		for (int i = 0;
	int i = 0;
	i < (&keyList)->size();
 ++i) 	// server/zone/objects/tangible/component/Component.idl():  		return 
	if ((&keyList)->get(i) == key)	// server/zone/objects/tangible/component/Component.idl():  				return true;
	return true;
	// server/zone/objects/tangible/component/Component.idl():  		return false;
	return false;
}

/*
 *	ComponentAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ComponentAdapter::ComponentAdapter(Component* obj) : TangibleObjectAdapter(obj) {
}

void ComponentAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_ISCOMPONENT__:
		{
			
			bool _m_res = isComponent();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GENERATELOOTSTATS__STRING_INT_:
		{
			 String lootstring; inv->getAsciiParameter(lootstring);
			int level = inv->getSignedIntParameter();
			
			generateLootStats(lootstring, level);
			
		}
		break;
	case RPC_COMPARE__COMPONENT_:
		{
			Component* inCmpo = static_cast<Component*>(inv->getObjectParameter());
			
			bool _m_res = compare(inCmpo);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASKEY__STRING_:
		{
			 String key; inv->getAsciiParameter(key);
			
			bool _m_res = hasKey(key);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_BOOL_:
		{
			 String attributeName; inv->getAsciiParameter(attributeName);
			 float value = inv->getFloatParameter();
			 int precision = inv->getSignedIntParameter();
			 String craftingTitle; inv->getAsciiParameter(craftingTitle);
			 bool hidden = inv->getBooleanParameter();
			
			addProperty(attributeName, value, precision, craftingTitle, hidden);
			
		}
		break;
	case RPC_GETATTRIBUTEVALUE__STRING_:
		{
			 String attributeName; inv->getAsciiParameter(attributeName);
			
			float _m_res = getAttributeValue(attributeName);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETATTRIBUTEPRECISION__STRING_:
		{
			 String attributeName; inv->getAsciiParameter(attributeName);
			
			int _m_res = getAttributePrecision(attributeName);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETATTRIBUTETITLE__STRING_:
		{
			 String attributeName; inv->getAsciiParameter(attributeName);
			
			String _m_res = getAttributeTitle(attributeName);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETATTRIBUTEHIDDEN__STRING_:
		{
			 String attributeName; inv->getAsciiParameter(attributeName);
			
			bool _m_res = getAttributeHidden(attributeName);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETPROPERTYTOHIDDEN__STRING_:
		{
			 String property; inv->getAsciiParameter(property);
			
			setPropertyToHidden(property);
			
		}
		break;
	case RPC_ADDPROPERTY__STRING_FLOAT_INT_STRING_:
		{
			 String attribute; inv->getAsciiParameter(attribute);
			 float value = inv->getFloatParameter();
			 int precision = inv->getSignedIntParameter();
			 String title; inv->getAsciiParameter(title);
			
			addProperty(attribute, value, precision, title);
			
		}
		break;
	case RPC_GETPROPERTYCOUNT__:
		{
			
			int _m_res = getPropertyCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETPROPERTY__INT_:
		{
			 int j = inv->getSignedIntParameter();
			
			String _m_res = getProperty(j);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_CHANGEATTRIBUTEVALUE__STRING_FLOAT_:
		{
			 String property; inv->getAsciiParameter(property);
			float value = inv->getFloatParameter();
			
			bool _m_res = changeAttributeValue(property, value);
			resp->insertBoolean(_m_res);
		}
		break;
	default:
		TangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

void ComponentAdapter::initializeTransientMembers() {
	(static_cast<Component*>(stub))->initializeTransientMembers();
}

bool ComponentAdapter::isComponent() {
	return (static_cast<Component*>(stub))->isComponent();
}

void ComponentAdapter::generateLootStats(const String& lootstring, int level) {
	(static_cast<Component*>(stub))->generateLootStats(lootstring, level);
}

bool ComponentAdapter::compare(Component* inCmpo) {
	return (static_cast<Component*>(stub))->compare(inCmpo);
}

bool ComponentAdapter::hasKey(const String& key) {
	return (static_cast<Component*>(stub))->hasKey(key);
}

void ComponentAdapter::addProperty(const String& attributeName, const float value, const int precision, const String& craftingTitle, const bool hidden) {
	(static_cast<Component*>(stub))->addProperty(attributeName, value, precision, craftingTitle, hidden);
}

float ComponentAdapter::getAttributeValue(const String& attributeName) {
	return (static_cast<Component*>(stub))->getAttributeValue(attributeName);
}

int ComponentAdapter::getAttributePrecision(const String& attributeName) {
	return (static_cast<Component*>(stub))->getAttributePrecision(attributeName);
}

String ComponentAdapter::getAttributeTitle(const String& attributeName) {
	return (static_cast<Component*>(stub))->getAttributeTitle(attributeName);
}

bool ComponentAdapter::getAttributeHidden(const String& attributeName) {
	return (static_cast<Component*>(stub))->getAttributeHidden(attributeName);
}

void ComponentAdapter::setPropertyToHidden(const String& property) {
	(static_cast<Component*>(stub))->setPropertyToHidden(property);
}

void ComponentAdapter::addProperty(const String& attribute, const float value, const int precision, const String& title) {
	(static_cast<Component*>(stub))->addProperty(attribute, value, precision, title);
}

int ComponentAdapter::getPropertyCount() {
	return (static_cast<Component*>(stub))->getPropertyCount();
}

String ComponentAdapter::getProperty(const int j) {
	return (static_cast<Component*>(stub))->getProperty(j);
}

bool ComponentAdapter::changeAttributeValue(const String& property, float value) {
	return (static_cast<Component*>(stub))->changeAttributeValue(property, value);
}

/*
 *	ComponentHelper
 */

ComponentHelper* ComponentHelper::staticInitializer = ComponentHelper::instance();

ComponentHelper::ComponentHelper() {
	className = "Component";

	Core::getObjectBroker()->registerClass(className, this);
}

void ComponentHelper::finalizeHelper() {
	ComponentHelper::finalize();
}

DistributedObject* ComponentHelper::instantiateObject() {
	return new Component(DummyConstructorParameter::instance());
}

DistributedObjectServant* ComponentHelper::instantiateServant() {
	return new ComponentImplementation();
}

DistributedObjectPOD* ComponentHelper::instantiatePOD() {
	return new ComponentPOD();
}

DistributedObjectAdapter* ComponentHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ComponentAdapter(static_cast<Component*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

const char LuaComponent::className[] = "LuaComponent";

Luna<LuaComponent>::RegType LuaComponent::Register[] = {
	{ "_setObject", &LuaComponent::_setObject },
	{ "_getObject", &LuaComponent::_getObject },
	{ "initializeTransientMembers", &LuaComponent::initializeTransientMembers },
	{ "fillObjectMenuResponse", &LuaComponent::fillObjectMenuResponse },
	{ "fillAttributeList", &LuaComponent::fillAttributeList },
	{ "isComponent", &LuaComponent::isComponent },
	{ "generateLootStats", &LuaComponent::generateLootStats },
	{ "compare", &LuaComponent::compare },
	{ "hasKey", &LuaComponent::hasKey },
	{ "updateCraftingValues", &LuaComponent::updateCraftingValues },
	{ "addProperty", &LuaComponent::addProperty },
	{ "getAttributeValue", &LuaComponent::getAttributeValue },
	{ "getAttributePrecision", &LuaComponent::getAttributePrecision },
	{ "getAttributeTitle", &LuaComponent::getAttributeTitle },
	{ "getAttributeHidden", &LuaComponent::getAttributeHidden },
	{ "setPropertyToHidden", &LuaComponent::setPropertyToHidden },
	{ "getPropertyCount", &LuaComponent::getPropertyCount },
	{ "getProperty", &LuaComponent::getProperty },
	{ "changeAttributeValue", &LuaComponent::changeAttributeValue },
	{ 0, 0 }
};

LuaComponent::LuaComponent(lua_State *L) {
	realObject = static_cast<Component*>(lua_touserdata(L, 1));
}

LuaComponent::~LuaComponent() {
}

int LuaComponent::_setObject(lua_State* L) {
	realObject = static_cast<Component*>(lua_touserdata(L, -1));

	return 0;
}

int LuaComponent::_getObject(lua_State* L) {
	lua_pushlightuserdata(L, realObject.get());

	return 1;
}

int LuaComponent::initializeTransientMembers(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		realObject->initializeTransientMembers();

		return 0;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:initializeTransientMembers()'");
	}
	return 0;
}

int LuaComponent::fillObjectMenuResponse(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				ObjectMenuResponse* menuResponse = static_cast<ObjectMenuResponse*>(lua_touserdata(L, -2));
				CreatureObject* player = static_cast<CreatureObject*>(lua_touserdata(L, -1));

				realObject->fillObjectMenuResponse(menuResponse, player);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:fillObjectMenuResponse(userdata, userdata)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'Component:fillObjectMenuResponse(userdata, userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:fillObjectMenuResponse(userdata, userdata)'");
	}
	return 0;
}

int LuaComponent::fillAttributeList(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				AttributeListMessage* msg = static_cast<AttributeListMessage*>(lua_touserdata(L, -2));
				CreatureObject* object = static_cast<CreatureObject*>(lua_touserdata(L, -1));

				realObject->fillAttributeList(msg, object);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:fillAttributeList(userdata, userdata)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'Component:fillAttributeList(userdata, userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:fillAttributeList(userdata, userdata)'");
	}
	return 0;
}

int LuaComponent::isComponent(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		bool result = realObject->isComponent();

		lua_pushboolean(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:isComponent()'");
	}
	return 0;
}

int LuaComponent::generateLootStats(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (lua_isstring(L, -2)) {
			if (parameterCount == 2) {
				const String lootstring = lua_tostring(L, -2);
				int level = lua_tointeger(L, -1);

				realObject->generateLootStats(lootstring, level);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:generateLootStats(string, integer)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'Component:generateLootStats(string, integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:generateLootStats(string, integer)'");
	}
	return 0;
}

int LuaComponent::compare(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (parameterCount == 1) {
			Component* inCmpo = static_cast<Component*>(lua_touserdata(L, -1));

			bool result = realObject->compare(inCmpo);

			lua_pushboolean(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:compare(userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:compare(userdata)'");
	}
	return 0;
}

int LuaComponent::hasKey(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String key = lua_tostring(L, -1);

			bool result = realObject->hasKey(key);

			lua_pushboolean(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:hasKey(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:hasKey(string)'");
	}
	return 0;
}

int LuaComponent::updateCraftingValues(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isboolean(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				CraftingValues* values = static_cast<CraftingValues*>(lua_touserdata(L, -2));
				bool firstUpdate = lua_toboolean(L, -1);

				realObject->updateCraftingValues(values, firstUpdate);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:updateCraftingValues(userdata, boolean)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'Component:updateCraftingValues(userdata, boolean)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:updateCraftingValues(userdata, boolean)'");
	}
	return 0;
}

int LuaComponent::addProperty(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isboolean(L, -1)) {
		if (lua_isstring(L, -2)) {
			if (lua_isnumber(L, -3)) {
				if (lua_isnumber(L, -4)) {
					if (lua_isstring(L, -5)) {
						if (parameterCount == 5) {
							const String attributeName = lua_tostring(L, -5);
							const float value = lua_tonumber(L, -4);
							const int precision = lua_tointeger(L, -3);
							const String craftingTitle = lua_tostring(L, -2);
							const bool hidden = lua_toboolean(L, -1);

							realObject->addProperty(attributeName, value, precision, craftingTitle, hidden);

							return 0;
						}
					} else {
						throw LuaCallbackException(L, "invalid argument at 4 for lua method 'Component:addProperty(string, number, integer, string, boolean)'");
					}
				} else {
					throw LuaCallbackException(L, "invalid argument at 3 for lua method 'Component:addProperty(string, number, integer, string, boolean)'");
				}
			} else {
				throw LuaCallbackException(L, "invalid argument at 2 for lua method 'Component:addProperty(string, number, integer, string, boolean)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'Component:addProperty(string, number, integer, string, boolean)'");
		}
	} else if (lua_isstring(L, -1)) {
		if (lua_isnumber(L, -2)) {
			if (lua_isnumber(L, -3)) {
				if (lua_isstring(L, -4)) {
					if (parameterCount == 4) {
						const String attribute = lua_tostring(L, -4);
						const float value = lua_tonumber(L, -3);
						const int precision = lua_tointeger(L, -2);
						const String title = lua_tostring(L, -1);

						realObject->addProperty(attribute, value, precision, title);

						return 0;
					}
				} else {
					throw LuaCallbackException(L, "invalid argument at 3 for lua method 'Component:addProperty(string, number, integer, string, boolean)'");
				}
			} else {
				throw LuaCallbackException(L, "invalid argument at 2 for lua method 'Component:addProperty(string, number, integer, string, boolean)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'Component:addProperty(string, number, integer, string, boolean)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:addProperty(string, number, integer, string, boolean)'");
	}
	return 0;
}

int LuaComponent::getAttributeValue(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String attributeName = lua_tostring(L, -1);

			float result = realObject->getAttributeValue(attributeName);

			lua_pushnumber(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:getAttributeValue(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:getAttributeValue(string)'");
	}
	return 0;
}

int LuaComponent::getAttributePrecision(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String attributeName = lua_tostring(L, -1);

			int result = realObject->getAttributePrecision(attributeName);

			lua_pushinteger(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:getAttributePrecision(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:getAttributePrecision(string)'");
	}
	return 0;
}

int LuaComponent::getAttributeTitle(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String attributeName = lua_tostring(L, -1);

			String result = realObject->getAttributeTitle(attributeName);

			lua_pushstring(L, result.toCharArray());
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:getAttributeTitle(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:getAttributeTitle(string)'");
	}
	return 0;
}

int LuaComponent::getAttributeHidden(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String attributeName = lua_tostring(L, -1);

			bool result = realObject->getAttributeHidden(attributeName);

			lua_pushboolean(L, result);
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:getAttributeHidden(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:getAttributeHidden(string)'");
	}
	return 0;
}

int LuaComponent::setPropertyToHidden(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isstring(L, -1)) {
		if (parameterCount == 1) {
			const String property = lua_tostring(L, -1);

			realObject->setPropertyToHidden(property);

			return 0;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:setPropertyToHidden(string)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:setPropertyToHidden(string)'");
	}
	return 0;
}

int LuaComponent::getPropertyCount(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getPropertyCount();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:getPropertyCount()'");
	}
	return 0;
}

int LuaComponent::getProperty(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (parameterCount == 1) {
			const int j = lua_tointeger(L, -1);

			String result = realObject->getProperty(j);

			lua_pushstring(L, result.toCharArray());
			return 1;
		} else {
			throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:getProperty(integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:getProperty(integer)'");
	}
	return 0;
}

int LuaComponent::changeAttributeValue(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (lua_isstring(L, -2)) {
			if (parameterCount == 2) {
				const String property = lua_tostring(L, -2);
				float value = lua_tonumber(L, -1);

				bool result = realObject->changeAttributeValue(property, value);

				lua_pushboolean(L, result);
				return 1;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'Component:changeAttributeValue(string, number)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'Component:changeAttributeValue(string, number)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'Component:changeAttributeValue(string, number)'");
	}
	return 0;
}

/*
 *	ComponentPOD
 */

ComponentPOD::~ComponentPOD() {
	finalize();
}

ComponentPOD::ComponentPOD(void) {
	_className = "Component";
}


void ComponentPOD::writeJSON(nlohmann::json& j) {
	TangibleObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (attributeMap)
		thisObject["attributeMap"] = attributeMap.value();

	if (precisionMap)
		thisObject["precisionMap"] = precisionMap.value();

	if (titleMap)
		thisObject["titleMap"] = titleMap.value();

	if (hiddenMap)
		thisObject["hiddenMap"] = hiddenMap.value();

	if (keyList)
		thisObject["keyList"] = keyList.value();

	j["Component"] = thisObject;
}


void ComponentPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ComponentPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ComponentPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (attributeMap) {
	_nameHashCode = 0xc24a10f4; //Component.attributeMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, float> >::toBinaryStream(&attributeMap.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (precisionMap) {
	_nameHashCode = 0xc95992bf; //Component.precisionMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&precisionMap.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (titleMap) {
	_nameHashCode = 0xf7854fbd; //Component.titleMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&titleMap.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (hiddenMap) {
	_nameHashCode = 0x55e3ae91; //Component.hiddenMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, bool> >::toBinaryStream(&hiddenMap.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (keyList) {
	_nameHashCode = 0x1ce9d9cf; //Component.keyList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&keyList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool ComponentPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xc24a10f4: //Component.attributeMap
		{
			VectorMap<String, float> _mnattributeMap;
			TypeInfo<VectorMap<String, float> >::parseFromBinaryStream(&_mnattributeMap, stream);
			attributeMap = std::move(_mnattributeMap);
		}
		return true;

	case 0xc95992bf: //Component.precisionMap
		{
			VectorMap<String, int> _mnprecisionMap;
			TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&_mnprecisionMap, stream);
			precisionMap = std::move(_mnprecisionMap);
		}
		return true;

	case 0xf7854fbd: //Component.titleMap
		{
			VectorMap<String, String> _mntitleMap;
			TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&_mntitleMap, stream);
			titleMap = std::move(_mntitleMap);
		}
		return true;

	case 0x55e3ae91: //Component.hiddenMap
		{
			VectorMap<String, bool> _mnhiddenMap;
			TypeInfo<VectorMap<String, bool> >::parseFromBinaryStream(&_mnhiddenMap, stream);
			hiddenMap = std::move(_mnhiddenMap);
		}
		return true;

	case 0x1ce9d9cf: //Component.keyList
		{
			Vector<String> _mnkeyList;
			TypeInfo<Vector<String> >::parseFromBinaryStream(&_mnkeyList, stream);
			keyList = std::move(_mnkeyList);
		}
		return true;

	}

	return false;
}

void ComponentPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ComponentPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ComponentPOD::writeObjectCompact(ObjectOutputStream* stream) {
	TangibleObjectPOD::writeObjectCompact(stream);

	TypeInfo<VectorMap<String, float> >::toBinaryStream(&attributeMap.value(), stream);

	TypeInfo<VectorMap<String, int> >::toBinaryStream(&precisionMap.value(), stream);

	TypeInfo<VectorMap<String, String> >::toBinaryStream(&titleMap.value(), stream);

	TypeInfo<VectorMap<String, bool> >::toBinaryStream(&hiddenMap.value(), stream);

	TypeInfo<Vector<String> >::toBinaryStream(&keyList.value(), stream);


}

