/*
 *	autogen/server/zone/managers/frs/FrsManager.h generated by engine3 IDL compiler 0.70
 */

#ifndef FRSMANAGER_H_
#define FRSMANAGER_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace zone {

class ZoneServer;

class ZoneServerPOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace managers {
namespace frs {

class RankMaintenanceTask;

} // namespace frs
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::frs;

namespace server {
namespace zone {
namespace managers {
namespace frs {

class VoteStatusTask;

} // namespace frs
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::frs;

namespace server {
namespace zone {
namespace objects {
namespace building {

class BuildingObject;

class BuildingObjectPOD;

} // namespace building
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::building;

namespace server {
namespace zone {
namespace objects {
namespace player {

class PlayerObject;

class PlayerObjectPOD;

} // namespace player
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::player;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject;

class CreatureObjectPOD;

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObject;

class SceneObjectPOD;

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

namespace server {
namespace zone {
namespace objects {
namespace player {
namespace sui {

class SuiBox;

class SuiBoxPOD;

} // namespace sui
} // namespace player
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::player::sui;

#include "server/zone/managers/frs/FrsRankingData.h"

#include "server/zone/managers/frs/FrsRank.h"

#include "server/zone/managers/frs/FrsManagerData.h"

#include "server/zone/managers/frs/ChallengeVoteData.h"

#include "system/lang/ref/Reference.h"

#include "server/chat/StringIdChatParameter.h"

#include "server/zone/objects/tangible/threat/ThreatMap.h"

#include "engine/core/ManagedService.h"

#include "engine/log/Logger.h"

#include "system/util/VectorMap.h"

#include "system/util/Vector.h"

namespace server {
namespace zone {
namespace managers {
namespace frs {

class FrsManager : public ManagedService {
public:
	static const short COUNCIL_LIGHT = 1;

	static const short COUNCIL_DARK = 2;

	static const short SUI_VOTE_STATUS = 1;

	static const short SUI_VOTE_RECORD = 2;

	static const short SUI_VOTE_ACCEPT_PROMOTE = 3;

	static const short SUI_VOTE_PETITION = 4;

	static const short SUI_VOTE_DEMOTE = 5;

	static const short SUI_FORCE_PHASE_CHANGE = 6;

	static const short SUI_CHAL_VOTE_STATUS = 7;

	static const short SUI_CHAL_VOTE_RECORD = 8;

	static const short SUI_CHAL_VOTE_RECORD_CONFIRM = 9;

	static const short SUI_CHAL_VOTE_ISSUE = 10;

	static const short SUI_ARENA_CHAL_SCORES = 11;

	static const short SUI_ARENA_CHAL_STATUS = 12;

	static const short SUI_ARENA_CHAL_VIEW = 13;

	static const short SUI_ARENA_CHAL_ACCEPT = 14;

	static const short SUI_ARENA_CHAL_ACCEPT_LIST = 15;

	static const short SUI_ARENA_CHAL_ISSUE = 16;

	static const short VOTING_CLOSED = 1;

	static const short PETITIONING = 2;

	static const short VOTING_OPEN = 3;

	static const short WAITING = 4;

	static const short ARENA_OPEN = 1;

	static const short ARENA_CLOSED = 2;

	static const int ARENA_CELL = 3435643;

	unsigned static const long long VOTE_STATUS_TICK;

	FrsManager(ZoneServer* zserv);

	void initialize();

	void loadLuaConfig();

	void loadFrsData();

	void setupEnclaves();

	void setupEnclaveRooms(BuildingObject* enclaveBuilding, const String& groupName);

	Vector<unsigned long long> getFullPlayerList();

	Vector<unsigned long long> getPlayerListByCouncil(int councilType);

	void setPlayerRank(CreatureObject* player, int rank);

	void playerLoggedIn(CreatureObject* player);

	void validatePlayerData(CreatureObject* player);

	void removeFromFrs(CreatureObject* player);

	void handleSkillRevoked(CreatureObject* player, const String& skillName);

	int getSkillRank(const String& skillName, int councilType);

	void updatePlayerSkills(CreatureObject* player);

	void demotePlayer(CreatureObject* player);

	void promotePlayer(CreatureObject* player);

	void adjustFrsExperience(CreatureObject* player, int amount, bool sendSystemMessage = true);

	void deductMaintenanceXp(CreatureObject* player);

	void addExperienceDebt(CreatureObject* player, int amount);

	void verifyRoomAccess(CreatureObject* player, int playerRank);

	bool isValidFrsBattle(CreatureObject* attacker, CreatureObject* victim);

	int calculatePvpExperienceChange(CreatureObject* attacker, CreatureObject* victim, float contribution, bool isVictim);

	int getBaseExperienceGain(PlayerObject* playerGhost, PlayerObject* opponentGhost, bool playerWon);

	int getAvailableRankSlots(FrsRank* rankInfo);

	void sendVoteSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleVoteStatusSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void sendVoteRecordSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVoteRecordSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank, unsigned long long petitionerID);

	void handleAcceptPromotionSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVotePetitionSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void sendVoteDemoteSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVoteDemoteSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank, unsigned long long playerID);

	void sendChallengeVoteSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleChallengeVoteIssueSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteStatusSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteRecordSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteRecordConfirmSui(CreatureObject* player, SceneObject* terminal, int index, unsigned long long challengedID);

	int getVoteWeight(int playerRank, int voteRank);

	int getChallengeVoteWeight(int playerRank, int challengedRank);

	int getRankTier(int rank);

	bool hasPlayerVoted(CreatureObject* player, FrsRank* rankData);

	void runVotingUpdate(FrsRank* rankInfo);

	void runChallengeVoteUpdate();

	void checkForMissedVotes(FrsRank* rankInfo);

	short getEnclaveType(BuildingObject* enclave);

	bool isEligibleForPromotion(CreatureObject* player, int rank);

	void sendMailToVoters(FrsRank* rankData, const String& sub, StringIdChatParameter& body);

	void sendChallengeVoteMail(int challengedRank, const String& sub, StringIdChatParameter& body);

	void sendMailToList(Vector<unsigned long long>* playerList, const String& sub, StringIdChatParameter& body);

	Vector<unsigned long long>* getTopVotes(FrsRank* rankInfo, int numWinners);

	String getTimeString(unsigned long long timestamp);

	void deductDebtExperience(CreatureObject* player);

	int getRoomRequirement(unsigned long long cellID);

	int getMaintenanceInterval() const;

	ZoneServer* getZoneServer();

	FrsRank* getFrsRank(short councilType, int rank);

	bool isFrsEnabled() const;

	unsigned long long getVotingInterval(short status);

	void updateLastMaintenance();

	void updateLastVoteStatus();

	int getArenaStatus();

	bool isFightingInArena(unsigned long long playerID);

	void performArenaMaintenance();

	void updateArenaScores();

	void forcePhaseChange(CreatureObject* player, short enclaveType, int rank);

	void recoverJediItems(CreatureObject* player);

	bool isPlayerInEnclave(CreatureObject* player);

	bool isPlayerInDarkArena(CreatureObject* player);

	void teleportPlayerToDarkArena(CreatureObject* player);

	void sendRankPlayerList(CreatureObject* player, int councilType, int rank);

	int getTotalOpenArenaChallenges(int rank);

	bool playerAbleToChallenge(CreatureObject* player);

	bool hasPlayerAcceptedArenaChallenge(CreatureObject* player);

	bool handleDarkCouncilIncap(CreatureObject* killer, CreatureObject* victim);

	bool handleDarkCouncilDeath(CreatureObject* killer, CreatureObject* victim, bool forfeit = false);

	void handleLeftArena(CreatureObject* player);

	void sendArenaChallengeSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleArenaChallengeViewSui(CreatureObject* player, SceneObject* terminal, SuiBox* suiBox, int index);

	void handleArenaChallengeIssueSui(CreatureObject* player);

	void issueArenaChallenge(CreatureObject* player, int rank);

	void acceptArenaChallenge(CreatureObject* player, unsigned long long challengerID);

	bool rankHasOpenChallenges(int rank);

	bool isArenaOpen();

	void wipeArenaChallenges();

	void forceArenaOpen(CreatureObject* player);

	bool isPlayerFightingInArena(unsigned long long playerID);

	bool canPlayerAcceptArenaChallenge(CreatureObject* player);

	bool canPlayerIssueArenaChallenge(CreatureObject* player);

	void setupSuddenDeath(FrsRank* rankData, bool endPhase);

	void modifySuddenDeathFlags(CreatureObject* player, FrsRank* rankData, bool doRemove);

	void handleSuddenDeathLoss(CreatureObject* player, ThreatMap* threatMap);

	void cancelTasks();

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	FrsManager(DummyConstructorParameter* param);

	virtual ~FrsManager();

	friend class FrsManagerHelper;
};

} // namespace frs
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::frs;

namespace server {
namespace zone {
namespace managers {
namespace frs {

class FrsManagerImplementation : public ManagedServiceImplementation, public Logger {
public:
	static const short COUNCIL_LIGHT = 1;

	static const short COUNCIL_DARK = 2;

	static const short SUI_VOTE_STATUS = 1;

	static const short SUI_VOTE_RECORD = 2;

	static const short SUI_VOTE_ACCEPT_PROMOTE = 3;

	static const short SUI_VOTE_PETITION = 4;

	static const short SUI_VOTE_DEMOTE = 5;

	static const short SUI_FORCE_PHASE_CHANGE = 6;

	static const short SUI_CHAL_VOTE_STATUS = 7;

	static const short SUI_CHAL_VOTE_RECORD = 8;

	static const short SUI_CHAL_VOTE_RECORD_CONFIRM = 9;

	static const short SUI_CHAL_VOTE_ISSUE = 10;

	static const short SUI_ARENA_CHAL_SCORES = 11;

	static const short SUI_ARENA_CHAL_STATUS = 12;

	static const short SUI_ARENA_CHAL_VIEW = 13;

	static const short SUI_ARENA_CHAL_ACCEPT = 14;

	static const short SUI_ARENA_CHAL_ACCEPT_LIST = 15;

	static const short SUI_ARENA_CHAL_ISSUE = 16;

	static const short VOTING_CLOSED = 1;

	static const short PETITIONING = 2;

	static const short VOTING_OPEN = 3;

	static const short WAITING = 4;

	static const short ARENA_OPEN = 1;

	static const short ARENA_CLOSED = 2;

	static const int ARENA_CELL = 3435643;

	unsigned static const long long VOTE_STATUS_TICK;

private:
	ManagedReference<FrsManagerData* > managerData;

	ManagedWeakReference<ZoneServer* > zoneServer;

protected:
	Reference<RankMaintenanceTask* > rankMaintenanceTask;

	Reference<VoteStatusTask* > voteStatusTask;

	ManagedWeakReference<BuildingObject* > lightEnclave;

	ManagedWeakReference<BuildingObject* > darkEnclave;

	VectorMap<unsigned int, Reference<FrsRankingData*> > lightRankingData;

	VectorMap<unsigned int, Reference<FrsRankingData*> > darkRankingData;

	VectorMap<unsigned long long, int> roomRequirements;

	VectorMap<uint64, Vector<int> > experienceValues;

	bool frsEnabled;

	unsigned long long petitionInterval;

	unsigned long long votingInterval;

	unsigned long long acceptanceInterval;

	unsigned long long maintenanceInterval;

	unsigned long long arenaOpenInterval;

	unsigned long long arenaClosedInterval;

	unsigned long long arenaChallengeDuration;

	unsigned long long arenaChallengeCooldown;

	unsigned long long requestDemotionDuration;

	unsigned long long voteChallengeDuration;

	int baseMaintCost;

	int requestDemotionCost;

	int voteChallengeCost;

	int maxPetitioners;

	int maxChallenges;

	int missedVotePenalty;

public:
	FrsManagerImplementation(ZoneServer* zserv);

	FrsManagerImplementation(DummyConstructorParameter* param);

	void initialize();

	void loadLuaConfig();

	void loadFrsData();

	void setupEnclaves();

	void setupEnclaveRooms(BuildingObject* enclaveBuilding, const String& groupName);

	Vector<unsigned long long> getFullPlayerList();

	Vector<unsigned long long> getPlayerListByCouncil(int councilType);

	void setPlayerRank(CreatureObject* player, int rank);

	void playerLoggedIn(CreatureObject* player);

	void validatePlayerData(CreatureObject* player);

	void removeFromFrs(CreatureObject* player);

	void handleSkillRevoked(CreatureObject* player, const String& skillName);

	int getSkillRank(const String& skillName, int councilType);

	void updatePlayerSkills(CreatureObject* player);

	void demotePlayer(CreatureObject* player);

	void promotePlayer(CreatureObject* player);

	void adjustFrsExperience(CreatureObject* player, int amount, bool sendSystemMessage = true);

	void deductMaintenanceXp(CreatureObject* player);

	void addExperienceDebt(CreatureObject* player, int amount);

	void verifyRoomAccess(CreatureObject* player, int playerRank);

	bool isValidFrsBattle(CreatureObject* attacker, CreatureObject* victim);

	int calculatePvpExperienceChange(CreatureObject* attacker, CreatureObject* victim, float contribution, bool isVictim);

	int getBaseExperienceGain(PlayerObject* playerGhost, PlayerObject* opponentGhost, bool playerWon);

	int getAvailableRankSlots(FrsRank* rankInfo);

	void sendVoteSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleVoteStatusSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void sendVoteRecordSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVoteRecordSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank, unsigned long long petitionerID);

	void handleAcceptPromotionSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVotePetitionSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void sendVoteDemoteSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVoteDemoteSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank, unsigned long long playerID);

	void sendChallengeVoteSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleChallengeVoteIssueSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteStatusSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteRecordSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteRecordConfirmSui(CreatureObject* player, SceneObject* terminal, int index, unsigned long long challengedID);

	int getVoteWeight(int playerRank, int voteRank);

	int getChallengeVoteWeight(int playerRank, int challengedRank);

	int getRankTier(int rank);

	bool hasPlayerVoted(CreatureObject* player, FrsRank* rankData);

	void runVotingUpdate(FrsRank* rankInfo);

	void runChallengeVoteUpdate();

	void checkForMissedVotes(FrsRank* rankInfo);

	short getEnclaveType(BuildingObject* enclave);

	bool isEligibleForPromotion(CreatureObject* player, int rank);

	void sendMailToVoters(FrsRank* rankData, const String& sub, StringIdChatParameter& body);

	void sendChallengeVoteMail(int challengedRank, const String& sub, StringIdChatParameter& body);

	void sendMailToList(Vector<unsigned long long>* playerList, const String& sub, StringIdChatParameter& body);

	Vector<unsigned long long>* getTopVotes(FrsRank* rankInfo, int numWinners);

	String getTimeString(unsigned long long timestamp);

	void deductDebtExperience(CreatureObject* player);

	int getRoomRequirement(unsigned long long cellID);

	int getMaintenanceInterval() const;

	ZoneServer* getZoneServer();

	FrsRank* getFrsRank(short councilType, int rank);

	bool isFrsEnabled() const;

	unsigned long long getVotingInterval(short status);

	void updateLastMaintenance();

	void updateLastVoteStatus();

	int getArenaStatus();

	bool isFightingInArena(unsigned long long playerID);

	void performArenaMaintenance();

	void updateArenaScores();

	void forcePhaseChange(CreatureObject* player, short enclaveType, int rank);

	void recoverJediItems(CreatureObject* player);

	bool isPlayerInEnclave(CreatureObject* player);

	bool isPlayerInDarkArena(CreatureObject* player);

	void teleportPlayerToDarkArena(CreatureObject* player);

	void sendRankPlayerList(CreatureObject* player, int councilType, int rank);

	int getTotalOpenArenaChallenges(int rank);

	bool playerAbleToChallenge(CreatureObject* player);

	bool hasPlayerAcceptedArenaChallenge(CreatureObject* player);

	bool handleDarkCouncilIncap(CreatureObject* killer, CreatureObject* victim);

	bool handleDarkCouncilDeath(CreatureObject* killer, CreatureObject* victim, bool forfeit = false);

	void handleLeftArena(CreatureObject* player);

	void sendArenaChallengeSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleArenaChallengeViewSui(CreatureObject* player, SceneObject* terminal, SuiBox* suiBox, int index);

	void handleArenaChallengeIssueSui(CreatureObject* player);

	void issueArenaChallenge(CreatureObject* player, int rank);

	void acceptArenaChallenge(CreatureObject* player, unsigned long long challengerID);

	bool rankHasOpenChallenges(int rank);

	bool isArenaOpen();

	void wipeArenaChallenges();

	void forceArenaOpen(CreatureObject* player);

	bool isPlayerFightingInArena(unsigned long long playerID);

	bool canPlayerAcceptArenaChallenge(CreatureObject* player);

	bool canPlayerIssueArenaChallenge(CreatureObject* player);

	void setupSuddenDeath(FrsRank* rankData, bool endPhase);

	void modifySuddenDeathFlags(CreatureObject* player, FrsRank* rankData, bool doRemove);

	void handleSuddenDeathLoss(CreatureObject* player, ThreatMap* threatMap);

	void cancelTasks();

	WeakReference<FrsManager*> _this;

	operator const FrsManager*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
protected:
	virtual ~FrsManagerImplementation();

	void finalize();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class FrsManager;
};

class FrsManagerAdapter : public ManagedServiceAdapter {
public:
	FrsManagerAdapter(FrsManager* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void initialize();

	void loadLuaConfig();

	void loadFrsData();

	void setupEnclaves();

	void setupEnclaveRooms(BuildingObject* enclaveBuilding, const String& groupName);

	void setPlayerRank(CreatureObject* player, int rank);

	void playerLoggedIn(CreatureObject* player);

	void validatePlayerData(CreatureObject* player);

	void removeFromFrs(CreatureObject* player);

	void handleSkillRevoked(CreatureObject* player, const String& skillName);

	int getSkillRank(const String& skillName, int councilType);

	void updatePlayerSkills(CreatureObject* player);

	void demotePlayer(CreatureObject* player);

	void promotePlayer(CreatureObject* player);

	void adjustFrsExperience(CreatureObject* player, int amount, bool sendSystemMessage);

	void deductMaintenanceXp(CreatureObject* player);

	void addExperienceDebt(CreatureObject* player, int amount);

	void verifyRoomAccess(CreatureObject* player, int playerRank);

	bool isValidFrsBattle(CreatureObject* attacker, CreatureObject* victim);

	int calculatePvpExperienceChange(CreatureObject* attacker, CreatureObject* victim, float contribution, bool isVictim);

	int getBaseExperienceGain(PlayerObject* playerGhost, PlayerObject* opponentGhost, bool playerWon);

	int getAvailableRankSlots(FrsRank* rankInfo);

	void sendVoteSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleVoteStatusSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void sendVoteRecordSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVoteRecordSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank, unsigned long long petitionerID);

	void handleAcceptPromotionSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVotePetitionSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void sendVoteDemoteSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank);

	void handleVoteDemoteSui(CreatureObject* player, SceneObject* terminal, short enclaveType, int rank, unsigned long long playerID);

	void sendChallengeVoteSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleChallengeVoteIssueSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteStatusSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteRecordSui(CreatureObject* player, SceneObject* terminal, unsigned long long challengedID);

	void handleChallengeVoteRecordConfirmSui(CreatureObject* player, SceneObject* terminal, int index, unsigned long long challengedID);

	int getVoteWeight(int playerRank, int voteRank);

	int getChallengeVoteWeight(int playerRank, int challengedRank);

	int getRankTier(int rank);

	bool hasPlayerVoted(CreatureObject* player, FrsRank* rankData);

	void runVotingUpdate(FrsRank* rankInfo);

	void runChallengeVoteUpdate();

	void checkForMissedVotes(FrsRank* rankInfo);

	short getEnclaveType(BuildingObject* enclave);

	bool isEligibleForPromotion(CreatureObject* player, int rank);

	String getTimeString(unsigned long long timestamp);

	void deductDebtExperience(CreatureObject* player);

	int getRoomRequirement(unsigned long long cellID);

	int getMaintenanceInterval() const;

	ZoneServer* getZoneServer();

	bool isFrsEnabled() const;

	unsigned long long getVotingInterval(short status);

	void updateLastMaintenance();

	void updateLastVoteStatus();

	int getArenaStatus();

	bool isFightingInArena(unsigned long long playerID);

	void performArenaMaintenance();

	void updateArenaScores();

	void forcePhaseChange(CreatureObject* player, short enclaveType, int rank);

	void recoverJediItems(CreatureObject* player);

	bool isPlayerInEnclave(CreatureObject* player);

	bool isPlayerInDarkArena(CreatureObject* player);

	void teleportPlayerToDarkArena(CreatureObject* player);

	void sendRankPlayerList(CreatureObject* player, int councilType, int rank);

	int getTotalOpenArenaChallenges(int rank);

	bool playerAbleToChallenge(CreatureObject* player);

	bool hasPlayerAcceptedArenaChallenge(CreatureObject* player);

	bool handleDarkCouncilIncap(CreatureObject* killer, CreatureObject* victim);

	bool handleDarkCouncilDeath(CreatureObject* killer, CreatureObject* victim, bool forfeit);

	void handleLeftArena(CreatureObject* player);

	void sendArenaChallengeSUI(CreatureObject* player, SceneObject* terminal, short suiType, short enclaveType);

	void handleArenaChallengeViewSui(CreatureObject* player, SceneObject* terminal, SuiBox* suiBox, int index);

	void handleArenaChallengeIssueSui(CreatureObject* player);

	void issueArenaChallenge(CreatureObject* player, int rank);

	void acceptArenaChallenge(CreatureObject* player, unsigned long long challengerID);

	bool rankHasOpenChallenges(int rank);

	bool isArenaOpen();

	void wipeArenaChallenges();

	void forceArenaOpen(CreatureObject* player);

	bool isPlayerFightingInArena(unsigned long long playerID);

	bool canPlayerAcceptArenaChallenge(CreatureObject* player);

	bool canPlayerIssueArenaChallenge(CreatureObject* player);

	void setupSuddenDeath(FrsRank* rankData, bool endPhase);

	void modifySuddenDeathFlags(CreatureObject* player, FrsRank* rankData, bool doRemove);

	void cancelTasks();

};

class FrsManagerHelper : public DistributedObjectClassHelper, public Singleton<FrsManagerHelper> {
	static FrsManagerHelper* staticInitializer;

public:
	FrsManagerHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<FrsManagerHelper>;
};

} // namespace frs
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::frs;

namespace server {
namespace zone {
namespace managers {
namespace frs {

class FrsManagerPOD : public ManagedServicePOD {
public:
	Optional<ManagedWeakReference<BuildingObjectPOD* >> lightEnclave;

	Optional<ManagedWeakReference<BuildingObjectPOD* >> darkEnclave;

	String _className;
	FrsManagerPOD();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~FrsManagerPOD();

};

} // namespace frs
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::frs;

#endif /*FRSMANAGERPOD_H_*/
