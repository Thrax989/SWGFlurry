/*
 *	autogen/server/zone/objects/creature/ai/DroidObject.cpp generated by engine3 IDL compiler 0.70
 */

#include "DroidObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/objects/tangible/components/droid/BaseDroidModuleComponent.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/scene/SceneObject.h"

/*
 *	DroidObjectStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 2655348246,RPC_ISDROIDOBJECT__,RPC_GETMAXIMUMHAM__,RPC_SETMAXIMUMHAM__INT_,RPC_SETATTACKSPEED__FLOAT_,RPC_ISCAMOUFLAGED__CREATUREOBJECT_,RPC_HASPOWER__,RPC_USEPOWER__INT_,RPC_RUNMODULEPOWERDRAIN__,RPC_REFRESHPAINT__,RPC_RECHARGEFROMBATTERY__CREATUREOBJECT_,RPC_RECHARGEFROMDROID__,RPC_RECHARGEOTHERDROID__DROIDOBJECT_,RPC_HANDLELOWPOWER__,RPC_ISPOWERDROID__,RPC_GETKINETIC__,RPC_GETENERGY__,RPC_GETELECTRICITY__,RPC_GETSTUN__,RPC_GETBLAST__,RPC_GETHEAT__,RPC_GETCOLD__,RPC_GETACID__,RPC_GETLIGHTSABER__,RPC_GETCHANCEHIT__,RPC_ISMERCHANTBARKER__,RPC_GETPERSONALITYSTF__,RPC_ISADVANCEDMODEL__,RPC_ISCOMBATDROID__,RPC_ISTRAPDROID__,RPC_HASSTORAGE__,RPC_ISMAINTENANCEDROID__,RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_,RPC_HASREACTIONCHATMESSAGES__,RPC_GETREACTIONSTF__,RPC_GETHAMMAXIMUM__,RPC_GETHAMBASE__,RPC_GETDAMAGEMIN__,RPC_GETDAMAGEMAX__,RPC_GETATTACKSPEED__,RPC_CALCULATEATTACKSPEED__INT_};

DroidObject::DroidObject() : AiAgent(DummyConstructorParameter::instance()) {
	DroidObjectImplementation* _implementation = new DroidObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("DroidObject");
}

DroidObject::DroidObject(DummyConstructorParameter* param) : AiAgent(param) {
	_setClassName("DroidObject");
}

DroidObject::~DroidObject() {
}



void DroidObject::initializeTransientMembers() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void DroidObject::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

int DroidObject::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

void DroidObject::fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillObjectMenuResponse(menuResponse, player);
	}
}

void DroidObject::notifyInsertToZone(Zone* zone) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->notifyInsertToZone(zone);
	}
}

bool DroidObject::isDroidObject() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDROIDOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDroidObject();
	}
}

int DroidObject::getMaximumHAM() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXIMUMHAM__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMaximumHAM();
	}
}

void DroidObject::setMaximumHAM(int idx) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXIMUMHAM__INT_);
		method.addSignedIntParameter(idx);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMaximumHAM(idx);
	}
}

void DroidObject::setAttackSpeed(float f) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETATTACKSPEED__FLOAT_);
		method.addFloatParameter(f);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAttackSpeed(f);
	}
}

bool DroidObject::isCamouflaged(CreatureObject* target) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMOUFLAGED__CREATUREOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCamouflaged(target);
	}
}

bool DroidObject::hasPower() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPOWER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasPower();
	}
}

void DroidObject::usePower(int amount) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_USEPOWER__INT_);
		method.addSignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->usePower(amount);
	}
}

void DroidObject::runModulePowerDrain() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RUNMODULEPOWERDRAIN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->runModulePowerDrain();
	}
}

void DroidObject::refreshPaint() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REFRESHPAINT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->refreshPaint();
	}
}

int DroidObject::rechargeFromBattery(CreatureObject* player) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RECHARGEFROMBATTERY__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->rechargeFromBattery(player);
	}
}

void DroidObject::rechargeFromDroid() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RECHARGEFROMDROID__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->rechargeFromDroid();
	}
}

void DroidObject::rechargeOtherDroid(DroidObject* otherDroid) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RECHARGEOTHERDROID__DROIDOBJECT_);
		method.addObjectParameter(otherDroid);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((otherDroid == NULL) || otherDroid->isLockedByCurrentThread());
		_implementation->rechargeOtherDroid(otherDroid);
	}
}

void DroidObject::handleLowPower() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLELOWPOWER__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->handleLowPower();
	}
}

bool DroidObject::isPowerDroid() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOWERDROID__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPowerDroid();
	}
}

void DroidObject::initDroidModules() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->initDroidModules();
	}
}

void DroidObject::initDroidWeapons() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->initDroidWeapons();
	}
}

CraftingStation* DroidObject::getCraftingStation(int type) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCraftingStation(type);
	}
}

String DroidObject::getPersonalityBase() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPersonalityBase();
	}
}

Reference<BaseDroidModuleComponent* > DroidObject::getModule(const String& name) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getModule(name);
	}
}

void DroidObject::onStore() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->onStore();
	}
}

void DroidObject::onCall() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->onCall();
	}
}

void DroidObject::loadSkillMods(CreatureObject* player) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->loadSkillMods(player);
	}
}

void DroidObject::unloadSkillMods(CreatureObject* player) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->unloadSkillMods(player);
	}
}

void DroidObject::handleChat(CreatureObject* speaker, const String& message) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->handleChat(speaker, message);
	}
}

void DroidObject::setArmor(unsigned int level) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setArmor(level);
	}
}

void DroidObject::setHitChance(float v) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setHitChance(v);
	}
}

void DroidObject::setResists(float res) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setResists(res);
	}
}

void DroidObject::setMaxDamage(int i) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMaxDamage(i);
	}
}

void DroidObject::setMinDamage(int i) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMinDamage(i);
	}
}

unsigned int DroidObject::getArmor() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getArmor();
	}
}

float DroidObject::getKinetic() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETKINETIC__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getKinetic();
	}
}

float DroidObject::getEnergy() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENERGY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getEnergy();
	}
}

float DroidObject::getElectricity() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETELECTRICITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getElectricity();
	}
}

float DroidObject::getStun() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTUN__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getStun();
	}
}

float DroidObject::getBlast() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBLAST__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getBlast();
	}
}

float DroidObject::getHeat() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEAT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHeat();
	}
}

float DroidObject::getCold() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOLD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getCold();
	}
}

float DroidObject::getAcid() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACID__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAcid();
	}
}

float DroidObject::getLightSaber() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLIGHTSABER__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getLightSaber();
	}
}

float DroidObject::getChanceHit() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHANCEHIT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getChanceHit();
	}
}

bool DroidObject::isMerchantBarker() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMERCHANTBARKER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMerchantBarker();
	}
}

String DroidObject::getPersonalityStf() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERSONALITYSTF__);

		String _return_getPersonalityStf;
		method.executeWithAsciiReturn(_return_getPersonalityStf);
		return _return_getPersonalityStf;
	} else {
		return _implementation->getPersonalityStf();
	}
}

bool DroidObject::isAdvancedModel() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISADVANCEDMODEL__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAdvancedModel();
	}
}

bool DroidObject::isCombatDroid() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCOMBATDROID__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCombatDroid();
	}
}

bool DroidObject::isTrapDroid() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTRAPDROID__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTrapDroid();
	}
}

bool DroidObject::hasStorage() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSTORAGE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasStorage();
	}
}

bool DroidObject::isMaintenanceDroid() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMAINTENANCEDROID__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMaintenanceDroid();
	}
}

bool DroidObject::assignStructure(StructureObject* structure) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->assignStructure(structure);
	}
}

bool DroidObject::isStructureAssigned(StructureObject* structure) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->isStructureAssigned(structure);
	}
}

bool DroidObject::sendConversationStartTo(SceneObject* player) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->sendConversationStartTo(player);
	}
}

bool DroidObject::hasReactionChatMessages() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASREACTIONCHATMESSAGES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasReactionChatMessages();
	}
}

String DroidObject::getReactionStf() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREACTIONSTF__);

		String _return_getReactionStf;
		method.executeWithAsciiReturn(_return_getReactionStf);
		return _return_getReactionStf;
	} else {
		return _implementation->getReactionStf();
	}
}

int DroidObject::getHamMaximum() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAMMAXIMUM__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHamMaximum();
	}
}

int DroidObject::getHamBase() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAMBASE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHamBase();
	}
}

int DroidObject::getDamageMin() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGEMIN__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDamageMin();
	}
}

int DroidObject::getDamageMax() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGEMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDamageMax();
	}
}

float DroidObject::getAttackSpeed() {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTACKSPEED__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAttackSpeed();
	}
}

float DroidObject::calculateAttackSpeed(int level) {
	DroidObjectImplementation* _implementation = static_cast<DroidObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEATTACKSPEED__INT_);
		method.addSignedIntParameter(level);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->calculateAttackSpeed(level);
	}
}

DistributedObjectServant* DroidObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* DroidObject::_getImplementationForRead() const {
	return _impl;
}

void DroidObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	DroidObjectImplementation
 */

DroidObjectImplementation::DroidObjectImplementation(DummyConstructorParameter* param) : AiAgentImplementation(param) {
	_initializeImplementation();
}


DroidObjectImplementation::~DroidObjectImplementation() {
}


void DroidObjectImplementation::finalize() {
}

void DroidObjectImplementation::_initializeImplementation() {
	_setClassHelper(DroidObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void DroidObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<DroidObject*>(stub);
	AiAgentImplementation::_setStub(stub);
}

DistributedObjectStub* DroidObjectImplementation::_getStub() {
	return _this.get();
}

DroidObjectImplementation::operator const DroidObject*() {
	return _this.get();
}

void DroidObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void DroidObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void DroidObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void DroidObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void DroidObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void DroidObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void DroidObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void DroidObjectImplementation::_serializationHelperMethod() {
	AiAgentImplementation::_serializationHelperMethod();

	_setClassName("DroidObject");

}

void DroidObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(DroidObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool DroidObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (AiAgentImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x218c5291: //DroidObject.power
		TypeInfo<int >::parseFromBinaryStream(&power, stream);
		return true;

	case 0xa682ccec: //DroidObject.paintCount
		TypeInfo<int >::parseFromBinaryStream(&paintCount, stream);
		return true;

	case 0x7f717010: //DroidObject.armor
		TypeInfo<unsigned int >::parseFromBinaryStream(&armor, stream);
		return true;

	case 0x101f9836: //DroidObject.resist
		TypeInfo<float >::parseFromBinaryStream(&resist, stream);
		return true;

	case 0xcb0ee94a: //DroidObject.hitChance
		TypeInfo<float >::parseFromBinaryStream(&hitChance, stream);
		return true;

	case 0xc98c59c: //DroidObject.maximumHam
		TypeInfo<int >::parseFromBinaryStream(&maximumHam, stream);
		return true;

	case 0x7563048d: //DroidObject.minDamage
		TypeInfo<int >::parseFromBinaryStream(&minDamage, stream);
		return true;

	case 0xe0af43ae: //DroidObject.maxDamage
		TypeInfo<int >::parseFromBinaryStream(&maxDamage, stream);
		return true;

	case 0x5be7df9d: //DroidObject.attackSpeed
		TypeInfo<float >::parseFromBinaryStream(&attackSpeed, stream);
		return true;

	}

	return false;
}

void DroidObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = DroidObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int DroidObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = AiAgentImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x218c5291; //DroidObject.power
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&power, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa682ccec; //DroidObject.paintCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&paintCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7f717010; //DroidObject.armor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&armor, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x101f9836; //DroidObject.resist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&resist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcb0ee94a; //DroidObject.hitChance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&hitChance, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc98c59c; //DroidObject.maximumHam
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maximumHam, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7563048d; //DroidObject.minDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&minDamage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe0af43ae; //DroidObject.maxDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxDamage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5be7df9d; //DroidObject.attackSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&attackSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void DroidObjectImplementation::writeJSON(nlohmann::json& j) {
	AiAgentImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["power"] = power;

	thisObject["paintCount"] = paintCount;

	thisObject["armor"] = armor;

	thisObject["resist"] = resist;

	thisObject["hitChance"] = hitChance;

	thisObject["maximumHam"] = maximumHam;

	thisObject["minDamage"] = minDamage;

	thisObject["maxDamage"] = maxDamage;

	thisObject["attackSpeed"] = attackSpeed;

	j["DroidObject"] = thisObject;
}

DroidObjectImplementation::DroidObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/ai/DroidObject.idl():  		Logger.setLoggingName("DroidObject");
	Logger::setLoggingName("DroidObject");
	// server/zone/objects/creature/ai/DroidObject.idl():  		Logger.setLogging(false);
	Logger::setLogging(false);
	// server/zone/objects/creature/ai/DroidObject.idl():  		Logger.setGlobalLogging(true);
	Logger::setGlobalLogging(true);
	// server/zone/objects/creature/ai/DroidObject.idl():  		power = MAX_POWER;
	power = MAX_POWER;
	// server/zone/objects/creature/ai/DroidObject.idl():  		paintCount = 0;
	paintCount = 0;
	// server/zone/objects/creature/ai/DroidObject.idl():  		maximumHam = 55;
	maximumHam = 55;
	// server/zone/objects/creature/ai/DroidObject.idl():  		minDamage = 1;
	minDamage = 1;
	// server/zone/objects/creature/ai/DroidObject.idl():  		maxDamage = 1;
	maxDamage = 1;
	// server/zone/objects/creature/ai/DroidObject.idl():  		attackSpeed = 2.0;
	attackSpeed = 2.0;
	// server/zone/objects/creature/ai/DroidObject.idl():  		armor = 0;
	armor = 0;
	// server/zone/objects/creature/ai/DroidObject.idl():  		resist = 0;
	resist = 0;
	// server/zone/objects/creature/ai/DroidObject.idl():  		hitChance = 0.2;
	hitChance = 0.2;
}

bool DroidObjectImplementation::isDroidObject() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return true;
	return true;
}

int DroidObjectImplementation::getMaximumHAM() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return maximumHam;
	return maximumHam;
}

void DroidObjectImplementation::setMaximumHAM(int idx) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		maximumHam = idx;
	maximumHam = idx;
}

void DroidObjectImplementation::setAttackSpeed(float f) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		attackSpeed = f;
	attackSpeed = f;
}

bool DroidObjectImplementation::isCamouflaged(CreatureObject* target) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return isAggressiveTo(target) && isConcealed(target);
	return isAggressiveTo(target) && isConcealed(target);
}

bool DroidObjectImplementation::hasPower() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return power > 0;
	return power > 0;
}

void DroidObjectImplementation::usePower(int amount) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		power = power - amount;
	power = power - amount;
	// server/zone/objects/creature/ai/DroidObject.idl():  	}
	if (power <= 0){
	// server/zone/objects/creature/ai/DroidObject.idl():  			power = 0;
	power = 0;
	// server/zone/objects/creature/ai/DroidObject.idl():  			handleLowPower();
	handleLowPower();
}
}

void DroidObjectImplementation::refreshPaint() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		paintCount = PAINTCHARGES;
	paintCount = PAINTCHARGES;
}

void DroidObjectImplementation::setArmor(unsigned int level) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		armor = level;
	armor = level;
}

void DroidObjectImplementation::setHitChance(float v) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		hitChance = v;
	hitChance = v;
}

void DroidObjectImplementation::setResists(float res) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		resist = res;
	resist = res;
}

void DroidObjectImplementation::setMaxDamage(int i) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		maxDamage = i;
	maxDamage = i;
}

void DroidObjectImplementation::setMinDamage(int i) {
	// server/zone/objects/creature/ai/DroidObject.idl():  		minDamage = i;
	minDamage = i;
}

unsigned int DroidObjectImplementation::getArmor() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return armor;
	return armor;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getArmor();
	return AiAgentImplementation::getArmor();
}
}

float DroidObjectImplementation::getKinetic() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return resist;
	return resist;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getKinetic();
	return AiAgentImplementation::getKinetic();
}
}

float DroidObjectImplementation::getEnergy() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return resist;
	return resist;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getEnergy();
	return AiAgentImplementation::getEnergy();
}
}

float DroidObjectImplementation::getElectricity() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return resist;
	return resist;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getElectricity();
	return AiAgentImplementation::getElectricity();
}
}

float DroidObjectImplementation::getStun() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return resist;
	return resist;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getStun();
	return AiAgentImplementation::getStun();
}
}

float DroidObjectImplementation::getBlast() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return resist;
	return resist;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getBlast();
	return AiAgentImplementation::getBlast();
}
}

float DroidObjectImplementation::getHeat() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return resist;
	return resist;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getHeat();
	return AiAgentImplementation::getHeat();
}
}

float DroidObjectImplementation::getCold() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return resist;
	return resist;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getCold();
	return AiAgentImplementation::getCold();
}
}

float DroidObjectImplementation::getAcid() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return resist;
	return resist;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getAcid();
	return AiAgentImplementation::getAcid();
}
}

float DroidObjectImplementation::getLightSaber() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return -1;
	return -1;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getLightSaber();
	return AiAgentImplementation::getLightSaber();
}
}

float DroidObjectImplementation::getChanceHit() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		}
	if (isPet()){
	// server/zone/objects/creature/ai/DroidObject.idl():  			return hitChance;
	return hitChance;
}

	else {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getChanceHit();
	return AiAgentImplementation::getChanceHit();
}
}

bool DroidObjectImplementation::hasReactionChatMessages() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return getPersonalityBase() != "" || super.hasReactionChatMessages();
	return getPersonalityBase() != "" || AiAgentImplementation::hasReactionChatMessages();
}

String DroidObjectImplementation::getReactionStf() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return 
	if (getPersonalityBase() != "")	// server/zone/objects/creature/ai/DroidObject.idl():  			return getPersonalityBase();
	return getPersonalityBase();
	// server/zone/objects/creature/ai/DroidObject.idl():  		return super.getReactionStf();
	return AiAgentImplementation::getReactionStf();
}

int DroidObjectImplementation::getHamMaximum() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return maximumHam;
	return maximumHam;
}

int DroidObjectImplementation::getHamBase() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return maximumHam;
	return maximumHam;
}

int DroidObjectImplementation::getDamageMin() {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getDamageMin();
	if (isPet())	// server/zone/objects/creature/ai/DroidObject.idl():  			return minDamage;
	return minDamage;

	else 	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getDamageMin();
	return AiAgentImplementation::getDamageMin();
}

int DroidObjectImplementation::getDamageMax() {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getDamageMax();
	if (isPet())	// server/zone/objects/creature/ai/DroidObject.idl():  			return maxDamage;
	return maxDamage;

	else 	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.getDamageMax();
	return AiAgentImplementation::getDamageMax();
}

float DroidObjectImplementation::getAttackSpeed() {
	// server/zone/objects/creature/ai/DroidObject.idl():  		return attackSpeed;
	return attackSpeed;
}

float DroidObjectImplementation::calculateAttackSpeed(int level) {
	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.calculateAttackSpeed(level);
	if (isPet())	// server/zone/objects/creature/ai/DroidObject.idl():  			return attackSpeed;
	return attackSpeed;

	else 	// server/zone/objects/creature/ai/DroidObject.idl():  			return super.calculateAttackSpeed(level);
	return AiAgentImplementation::calculateAttackSpeed(level);
}

/*
 *	DroidObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


DroidObjectAdapter::DroidObjectAdapter(DroidObject* obj) : AiAgentAdapter(obj) {
}

void DroidObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_ISDROIDOBJECT__:
		{
			
			bool _m_res = isDroidObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETMAXIMUMHAM__:
		{
			
			int _m_res = getMaximumHAM();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMAXIMUMHAM__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			setMaximumHAM(idx);
			
		}
		break;
	case RPC_SETATTACKSPEED__FLOAT_:
		{
			float f = inv->getFloatParameter();
			
			setAttackSpeed(f);
			
		}
		break;
	case RPC_ISCAMOUFLAGED__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isCamouflaged(target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASPOWER__:
		{
			
			bool _m_res = hasPower();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_USEPOWER__INT_:
		{
			int amount = inv->getSignedIntParameter();
			
			usePower(amount);
			
		}
		break;
	case RPC_RUNMODULEPOWERDRAIN__:
		{
			
			runModulePowerDrain();
			
		}
		break;
	case RPC_REFRESHPAINT__:
		{
			
			refreshPaint();
			
		}
		break;
	case RPC_RECHARGEFROMBATTERY__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			int _m_res = rechargeFromBattery(player);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_RECHARGEFROMDROID__:
		{
			
			rechargeFromDroid();
			
		}
		break;
	case RPC_RECHARGEOTHERDROID__DROIDOBJECT_:
		{
			DroidObject* otherDroid = static_cast<DroidObject*>(inv->getObjectParameter());
			
			rechargeOtherDroid(otherDroid);
			
		}
		break;
	case RPC_HANDLELOWPOWER__:
		{
			
			handleLowPower();
			
		}
		break;
	case RPC_ISPOWERDROID__:
		{
			
			bool _m_res = isPowerDroid();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETKINETIC__:
		{
			
			float _m_res = getKinetic();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETENERGY__:
		{
			
			float _m_res = getEnergy();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETELECTRICITY__:
		{
			
			float _m_res = getElectricity();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETSTUN__:
		{
			
			float _m_res = getStun();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBLAST__:
		{
			
			float _m_res = getBlast();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHEAT__:
		{
			
			float _m_res = getHeat();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCOLD__:
		{
			
			float _m_res = getCold();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETACID__:
		{
			
			float _m_res = getAcid();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETLIGHTSABER__:
		{
			
			float _m_res = getLightSaber();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCHANCEHIT__:
		{
			
			float _m_res = getChanceHit();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ISMERCHANTBARKER__:
		{
			
			bool _m_res = isMerchantBarker();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPERSONALITYSTF__:
		{
			
			String _m_res = getPersonalityStf();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISADVANCEDMODEL__:
		{
			
			bool _m_res = isAdvancedModel();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCOMBATDROID__:
		{
			
			bool _m_res = isCombatDroid();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISTRAPDROID__:
		{
			
			bool _m_res = isTrapDroid();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASSTORAGE__:
		{
			
			bool _m_res = hasStorage();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISMAINTENANCEDROID__:
		{
			
			bool _m_res = isMaintenanceDroid();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = sendConversationStartTo(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASREACTIONCHATMESSAGES__:
		{
			
			bool _m_res = hasReactionChatMessages();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETREACTIONSTF__:
		{
			
			String _m_res = getReactionStf();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETHAMMAXIMUM__:
		{
			
			int _m_res = getHamMaximum();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETHAMBASE__:
		{
			
			int _m_res = getHamBase();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDAMAGEMIN__:
		{
			
			int _m_res = getDamageMin();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDAMAGEMAX__:
		{
			
			int _m_res = getDamageMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETATTACKSPEED__:
		{
			
			float _m_res = getAttackSpeed();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_CALCULATEATTACKSPEED__INT_:
		{
			int level = inv->getSignedIntParameter();
			
			float _m_res = calculateAttackSpeed(level);
			resp->insertFloat(_m_res);
		}
		break;
	default:
		AiAgentAdapter::invokeMethod(methid, inv);
	}
}

void DroidObjectAdapter::initializeTransientMembers() {
	(static_cast<DroidObject*>(stub))->initializeTransientMembers();
}

bool DroidObjectAdapter::isDroidObject() {
	return (static_cast<DroidObject*>(stub))->isDroidObject();
}

int DroidObjectAdapter::getMaximumHAM() {
	return (static_cast<DroidObject*>(stub))->getMaximumHAM();
}

void DroidObjectAdapter::setMaximumHAM(int idx) {
	(static_cast<DroidObject*>(stub))->setMaximumHAM(idx);
}

void DroidObjectAdapter::setAttackSpeed(float f) {
	(static_cast<DroidObject*>(stub))->setAttackSpeed(f);
}

bool DroidObjectAdapter::isCamouflaged(CreatureObject* target) {
	return (static_cast<DroidObject*>(stub))->isCamouflaged(target);
}

bool DroidObjectAdapter::hasPower() {
	return (static_cast<DroidObject*>(stub))->hasPower();
}

void DroidObjectAdapter::usePower(int amount) {
	(static_cast<DroidObject*>(stub))->usePower(amount);
}

void DroidObjectAdapter::runModulePowerDrain() {
	(static_cast<DroidObject*>(stub))->runModulePowerDrain();
}

void DroidObjectAdapter::refreshPaint() {
	(static_cast<DroidObject*>(stub))->refreshPaint();
}

int DroidObjectAdapter::rechargeFromBattery(CreatureObject* player) {
	return (static_cast<DroidObject*>(stub))->rechargeFromBattery(player);
}

void DroidObjectAdapter::rechargeFromDroid() {
	(static_cast<DroidObject*>(stub))->rechargeFromDroid();
}

void DroidObjectAdapter::rechargeOtherDroid(DroidObject* otherDroid) {
	(static_cast<DroidObject*>(stub))->rechargeOtherDroid(otherDroid);
}

void DroidObjectAdapter::handleLowPower() {
	(static_cast<DroidObject*>(stub))->handleLowPower();
}

bool DroidObjectAdapter::isPowerDroid() {
	return (static_cast<DroidObject*>(stub))->isPowerDroid();
}

float DroidObjectAdapter::getKinetic() {
	return (static_cast<DroidObject*>(stub))->getKinetic();
}

float DroidObjectAdapter::getEnergy() {
	return (static_cast<DroidObject*>(stub))->getEnergy();
}

float DroidObjectAdapter::getElectricity() {
	return (static_cast<DroidObject*>(stub))->getElectricity();
}

float DroidObjectAdapter::getStun() {
	return (static_cast<DroidObject*>(stub))->getStun();
}

float DroidObjectAdapter::getBlast() {
	return (static_cast<DroidObject*>(stub))->getBlast();
}

float DroidObjectAdapter::getHeat() {
	return (static_cast<DroidObject*>(stub))->getHeat();
}

float DroidObjectAdapter::getCold() {
	return (static_cast<DroidObject*>(stub))->getCold();
}

float DroidObjectAdapter::getAcid() {
	return (static_cast<DroidObject*>(stub))->getAcid();
}

float DroidObjectAdapter::getLightSaber() {
	return (static_cast<DroidObject*>(stub))->getLightSaber();
}

float DroidObjectAdapter::getChanceHit() {
	return (static_cast<DroidObject*>(stub))->getChanceHit();
}

bool DroidObjectAdapter::isMerchantBarker() {
	return (static_cast<DroidObject*>(stub))->isMerchantBarker();
}

String DroidObjectAdapter::getPersonalityStf() {
	return (static_cast<DroidObject*>(stub))->getPersonalityStf();
}

bool DroidObjectAdapter::isAdvancedModel() {
	return (static_cast<DroidObject*>(stub))->isAdvancedModel();
}

bool DroidObjectAdapter::isCombatDroid() {
	return (static_cast<DroidObject*>(stub))->isCombatDroid();
}

bool DroidObjectAdapter::isTrapDroid() {
	return (static_cast<DroidObject*>(stub))->isTrapDroid();
}

bool DroidObjectAdapter::hasStorage() {
	return (static_cast<DroidObject*>(stub))->hasStorage();
}

bool DroidObjectAdapter::isMaintenanceDroid() {
	return (static_cast<DroidObject*>(stub))->isMaintenanceDroid();
}

bool DroidObjectAdapter::sendConversationStartTo(SceneObject* player) {
	return (static_cast<DroidObject*>(stub))->sendConversationStartTo(player);
}

bool DroidObjectAdapter::hasReactionChatMessages() {
	return (static_cast<DroidObject*>(stub))->hasReactionChatMessages();
}

String DroidObjectAdapter::getReactionStf() {
	return (static_cast<DroidObject*>(stub))->getReactionStf();
}

int DroidObjectAdapter::getHamMaximum() {
	return (static_cast<DroidObject*>(stub))->getHamMaximum();
}

int DroidObjectAdapter::getHamBase() {
	return (static_cast<DroidObject*>(stub))->getHamBase();
}

int DroidObjectAdapter::getDamageMin() {
	return (static_cast<DroidObject*>(stub))->getDamageMin();
}

int DroidObjectAdapter::getDamageMax() {
	return (static_cast<DroidObject*>(stub))->getDamageMax();
}

float DroidObjectAdapter::getAttackSpeed() {
	return (static_cast<DroidObject*>(stub))->getAttackSpeed();
}

float DroidObjectAdapter::calculateAttackSpeed(int level) {
	return (static_cast<DroidObject*>(stub))->calculateAttackSpeed(level);
}

/*
 *	DroidObjectHelper
 */

DroidObjectHelper* DroidObjectHelper::staticInitializer = DroidObjectHelper::instance();

DroidObjectHelper::DroidObjectHelper() {
	className = "DroidObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void DroidObjectHelper::finalizeHelper() {
	DroidObjectHelper::finalize();
}

DistributedObject* DroidObjectHelper::instantiateObject() {
	return new DroidObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* DroidObjectHelper::instantiateServant() {
	return new DroidObjectImplementation();
}

DistributedObjectPOD* DroidObjectHelper::instantiatePOD() {
	return new DroidObjectPOD();
}

DistributedObjectAdapter* DroidObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new DroidObjectAdapter(static_cast<DroidObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	DroidObjectPOD
 */

DroidObjectPOD::~DroidObjectPOD() {
	finalize();
}

DroidObjectPOD::DroidObjectPOD(void) {
	_className = "DroidObject";
}


void DroidObjectPOD::writeJSON(nlohmann::json& j) {
	AiAgentPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (power)
		thisObject["power"] = power.value();

	if (paintCount)
		thisObject["paintCount"] = paintCount.value();

	if (armor)
		thisObject["armor"] = armor.value();

	if (resist)
		thisObject["resist"] = resist.value();

	if (hitChance)
		thisObject["hitChance"] = hitChance.value();

	if (maximumHam)
		thisObject["maximumHam"] = maximumHam.value();

	if (minDamage)
		thisObject["minDamage"] = minDamage.value();

	if (maxDamage)
		thisObject["maxDamage"] = maxDamage.value();

	if (attackSpeed)
		thisObject["attackSpeed"] = attackSpeed.value();

	j["DroidObject"] = thisObject;
}


void DroidObjectPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = DroidObjectPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int DroidObjectPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = AiAgentPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (power) {
	_nameHashCode = 0x218c5291; //DroidObject.power
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&power.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (paintCount) {
	_nameHashCode = 0xa682ccec; //DroidObject.paintCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&paintCount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (armor) {
	_nameHashCode = 0x7f717010; //DroidObject.armor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&armor.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (resist) {
	_nameHashCode = 0x101f9836; //DroidObject.resist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&resist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (hitChance) {
	_nameHashCode = 0xcb0ee94a; //DroidObject.hitChance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&hitChance.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maximumHam) {
	_nameHashCode = 0xc98c59c; //DroidObject.maximumHam
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maximumHam.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (minDamage) {
	_nameHashCode = 0x7563048d; //DroidObject.minDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&minDamage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxDamage) {
	_nameHashCode = 0xe0af43ae; //DroidObject.maxDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxDamage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (attackSpeed) {
	_nameHashCode = 0x5be7df9d; //DroidObject.attackSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&attackSpeed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool DroidObjectPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (AiAgentPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x218c5291: //DroidObject.power
		{
			int _mnpower;
			TypeInfo<int >::parseFromBinaryStream(&_mnpower, stream);
			power = std::move(_mnpower);
		}
		return true;

	case 0xa682ccec: //DroidObject.paintCount
		{
			int _mnpaintCount;
			TypeInfo<int >::parseFromBinaryStream(&_mnpaintCount, stream);
			paintCount = std::move(_mnpaintCount);
		}
		return true;

	case 0x7f717010: //DroidObject.armor
		{
			unsigned int _mnarmor;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnarmor, stream);
			armor = std::move(_mnarmor);
		}
		return true;

	case 0x101f9836: //DroidObject.resist
		{
			float _mnresist;
			TypeInfo<float >::parseFromBinaryStream(&_mnresist, stream);
			resist = std::move(_mnresist);
		}
		return true;

	case 0xcb0ee94a: //DroidObject.hitChance
		{
			float _mnhitChance;
			TypeInfo<float >::parseFromBinaryStream(&_mnhitChance, stream);
			hitChance = std::move(_mnhitChance);
		}
		return true;

	case 0xc98c59c: //DroidObject.maximumHam
		{
			int _mnmaximumHam;
			TypeInfo<int >::parseFromBinaryStream(&_mnmaximumHam, stream);
			maximumHam = std::move(_mnmaximumHam);
		}
		return true;

	case 0x7563048d: //DroidObject.minDamage
		{
			int _mnminDamage;
			TypeInfo<int >::parseFromBinaryStream(&_mnminDamage, stream);
			minDamage = std::move(_mnminDamage);
		}
		return true;

	case 0xe0af43ae: //DroidObject.maxDamage
		{
			int _mnmaxDamage;
			TypeInfo<int >::parseFromBinaryStream(&_mnmaxDamage, stream);
			maxDamage = std::move(_mnmaxDamage);
		}
		return true;

	case 0x5be7df9d: //DroidObject.attackSpeed
		{
			float _mnattackSpeed;
			TypeInfo<float >::parseFromBinaryStream(&_mnattackSpeed, stream);
			attackSpeed = std::move(_mnattackSpeed);
		}
		return true;

	}

	return false;
}

void DroidObjectPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(DroidObjectPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void DroidObjectPOD::writeObjectCompact(ObjectOutputStream* stream) {
	AiAgentPOD::writeObjectCompact(stream);

	TypeInfo<int >::toBinaryStream(&power.value(), stream);

	TypeInfo<int >::toBinaryStream(&paintCount.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&armor.value(), stream);

	TypeInfo<float >::toBinaryStream(&resist.value(), stream);

	TypeInfo<float >::toBinaryStream(&hitChance.value(), stream);

	TypeInfo<int >::toBinaryStream(&maximumHam.value(), stream);

	TypeInfo<int >::toBinaryStream(&minDamage.value(), stream);

	TypeInfo<int >::toBinaryStream(&maxDamage.value(), stream);

	TypeInfo<float >::toBinaryStream(&attackSpeed.value(), stream);


}

