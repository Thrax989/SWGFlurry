/*
 *	autogen/server/zone/objects/pathfinding/NavArea.cpp generated by engine3 IDL compiler 0.70
 */

#include "NavArea.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/Zone.h"

/*
 *	NavAreaStub
 */

enum {RPC_INITIALIZE__,RPC_NOTIFYENTER__SCENEOBJECT_,RPC_NOTIFYEXIT__SCENEOBJECT_,RPC_DESTROYOBJECTFROMWORLD__BOOL_,RPC_NOTIFYLOADFROMDATABASE__,RPC_ISNAVAREA__,RPC_ASNAVAREA__,RPC_OBJECTINMESH__SCENEOBJECT_,RPC_GETMESHNAME__,RPC_SETMESHNAME__STRING_,RPC_ISINRANGE__FLOAT_FLOAT_FLOAT_,RPC_UPDATENAVMESH__SCENEOBJECT_BOOL_,RPC_CONTAINSPOINT__FLOAT_FLOAT_,RPC_ISNAVMESHLOADED__,RPC_GETCONTAINEDOBJECTSCOUNT__,RPC_GETAREATERRAINHEIGHT__,RPC_SETAREATERRAINHEIGHT__FLOAT_};

NavArea::NavArea() : ActiveArea(DummyConstructorParameter::instance()) {
	NavAreaImplementation* _implementation = new NavAreaImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("NavArea");
}

NavArea::NavArea(DummyConstructorParameter* param) : ActiveArea(param) {
	_setClassName("NavArea");
}

NavArea::~NavArea() {
}



void NavArea::initializeNavArea(Vector3& position, float radius, Zone* zone, const String& name, bool forceRebuild) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->initializeNavArea(position, radius, zone, name, forceRebuild);
	}
}

void NavArea::initialize() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->initialize();
	}
}

void NavArea::notifyEnter(SceneObject* object) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYENTER__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyEnter(object);
	}
}

void NavArea::notifyExit(SceneObject* object) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYEXIT__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyExit(object);
	}
}

void NavArea::destroyObjectFromWorld(bool sendSelfDestroy) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMWORLD__BOOL_);
		method.addBooleanParameter(sendSelfDestroy);

		method.executeWithVoidReturn();
	} else {
		_implementation->destroyObjectFromWorld(sendSelfDestroy);
	}
}

void NavArea::notifyLoadFromDatabase() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

const AABB* NavArea::getMeshBounds() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getMeshBounds();
	}
}

RecastNavMesh* NavArea::getNavMesh() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getNavMesh();
	}
}

void NavArea::disableMeshUpdates(bool disable) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->disableMeshUpdates(disable);
	}
}

bool NavArea::isNavArea() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNAVAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNavArea();
	}
}

NavArea* NavArea::asNavArea() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ASNAVAREA__);

		return static_cast<NavArea*>(method.executeWithObjectReturn());
	} else {
		return _implementation->asNavArea();
	}
}

bool NavArea::objectInMesh(SceneObject* obj) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_OBJECTINMESH__SCENEOBJECT_);
		method.addObjectParameter(obj);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->objectInMesh(obj);
	}
}

String NavArea::getMeshName() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMESHNAME__);

		String _return_getMeshName;
		method.executeWithAsciiReturn(_return_getMeshName);
		return _return_getMeshName;
	} else {
		return _implementation->getMeshName();
	}
}

void NavArea::setMeshName(const String& name) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMESHNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMeshName(name);
	}
}

bool NavArea::isInRange(float x, float y, float range) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINRANGE__FLOAT_FLOAT_FLOAT_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addFloatParameter(range);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInRange(x, y, range);
	}
}

void NavArea::updateNavMesh(const AABB& area) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updateNavMesh(area);
	}
}

void NavArea::updateNavMesh(SceneObject* object, bool toRemove) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATENAVMESH__SCENEOBJECT_BOOL_);
		method.addObjectParameter(object);
		method.addBooleanParameter(toRemove);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateNavMesh(object, toRemove);
	}
}

void NavArea::setRadius(float f) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRadius(f);
	}
}

AABB NavArea::getBoundingBox() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getBoundingBox();
	}
}

bool NavArea::containsPoint(float x, float y) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONTAINSPOINT__FLOAT_FLOAT_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->containsPoint(x, y);
	}
}

bool NavArea::isNavMeshLoaded() const {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNAVMESHLOADED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNavMeshLoaded();
	}
}

int NavArea::getContainedObjectsCount() {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTAINEDOBJECTSCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getContainedObjectsCount();
	}
}

float NavArea::getAreaTerrainHeight() const {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAREATERRAINHEIGHT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAreaTerrainHeight();
	}
}

void NavArea::setAreaTerrainHeight(float value) {
	NavAreaImplementation* _implementation = static_cast<NavAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAREATERRAINHEIGHT__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAreaTerrainHeight(value);
	}
}

DistributedObjectServant* NavArea::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* NavArea::_getImplementationForRead() const {
	return _impl;
}

void NavArea::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	NavAreaImplementation
 */

NavAreaImplementation::NavAreaImplementation(DummyConstructorParameter* param) : ActiveAreaImplementation(param) {
	_initializeImplementation();
}


NavAreaImplementation::~NavAreaImplementation() {
}


void NavAreaImplementation::finalize() {
}

void NavAreaImplementation::_initializeImplementation() {
	_setClassHelper(NavAreaHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void NavAreaImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<NavArea*>(stub);
	ActiveAreaImplementation::_setStub(stub);
}

DistributedObjectStub* NavAreaImplementation::_getStub() {
	return _this.get();
}

NavAreaImplementation::operator const NavArea*() {
	return _this.get();
}

void NavAreaImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void NavAreaImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void NavAreaImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void NavAreaImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void NavAreaImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void NavAreaImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void NavAreaImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void NavAreaImplementation::_serializationHelperMethod() {
	ActiveAreaImplementation::_serializationHelperMethod();

	_setClassName("NavArea");

}

void NavAreaImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(NavAreaImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool NavAreaImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ActiveAreaImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xbd165d01: //NavArea.meshName
		TypeInfo<String >::parseFromBinaryStream(&meshName, stream);
		return true;

	case 0xd72dfeb8: //NavArea.recastNavMesh
		TypeInfo<RecastNavMesh >::parseFromBinaryStream(&recastNavMesh, stream);
		return true;

	case 0x71c9b071: //NavArea.disableUpdates
		TypeInfo<bool >::parseFromBinaryStream(&disableUpdates, stream);
		return true;

	case 0xd656aa90: //NavArea.meshBounds
		TypeInfo<AABB >::parseFromBinaryStream(&meshBounds, stream);
		return true;

	case 0xf921eb2c: //NavArea.containedObjects
		TypeInfo<HashSet<unsigned long long> >::parseFromBinaryStream(&containedObjects, stream);
		return true;

	}

	return false;
}

void NavAreaImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = NavAreaImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int NavAreaImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ActiveAreaImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xbd165d01; //NavArea.meshName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&meshName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd72dfeb8; //NavArea.recastNavMesh
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<RecastNavMesh >::toBinaryStream(&recastNavMesh, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x71c9b071; //NavArea.disableUpdates
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&disableUpdates, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd656aa90; //NavArea.meshBounds
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AABB >::toBinaryStream(&meshBounds, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf921eb2c; //NavArea.containedObjects
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<HashSet<unsigned long long> >::toBinaryStream(&containedObjects, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

NavAreaImplementation::NavAreaImplementation() : ActiveAreaImplementation() {
	_initializeImplementation();
	// server/zone/objects/pathfinding/NavArea.idl():  		disableUpdates = false;
	disableUpdates = false;
	// server/zone/objects/pathfinding/NavArea.idl():  		meshName = "navmesh";
	meshName = "navmesh";
	// server/zone/objects/pathfinding/NavArea.idl():  		terrainHeight = 0;
	terrainHeight = 0;
}

const AABB* NavAreaImplementation::getMeshBounds() {
	// server/zone/objects/pathfinding/NavArea.idl():  		return meshBounds;
	return (&meshBounds);
}

RecastNavMesh* NavAreaImplementation::getNavMesh() {
	// server/zone/objects/pathfinding/NavArea.idl():  		return recastNavMesh;
	return (&recastNavMesh);
}

void NavAreaImplementation::disableMeshUpdates(bool disable) {
	// server/zone/objects/pathfinding/NavArea.idl():  		disableUpdates = disable;
	disableUpdates = disable;
}

bool NavAreaImplementation::isNavArea() {
	// server/zone/objects/pathfinding/NavArea.idl():  		return true;
	return true;
}

String NavAreaImplementation::getMeshName() {
	// server/zone/objects/pathfinding/NavArea.idl():  		return meshName;
	return meshName;
}

void NavAreaImplementation::setMeshName(const String& name) {
	// server/zone/objects/pathfinding/NavArea.idl():  		meshName = name;
	meshName = name;
}

bool NavAreaImplementation::isNavMeshLoaded() const{
	// server/zone/objects/pathfinding/NavArea.idl():  		return recastNavMesh.isLoaded();
	return (&recastNavMesh)->isLoaded();
}

int NavAreaImplementation::getContainedObjectsCount() {
	// server/zone/objects/pathfinding/NavArea.idl():  		return containedObjects.size();
	return (&containedObjects)->size();
}

float NavAreaImplementation::getAreaTerrainHeight() const{
	// server/zone/objects/pathfinding/NavArea.idl():  		return terrainHeight;
	return terrainHeight;
}

void NavAreaImplementation::setAreaTerrainHeight(float value) {
	// server/zone/objects/pathfinding/NavArea.idl():  		terrainHeight = value;
	terrainHeight = value;
}

/*
 *	NavAreaAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


NavAreaAdapter::NavAreaAdapter(NavArea* obj) : ActiveAreaAdapter(obj) {
}

void NavAreaAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZE__:
		{
			
			initialize();
			
		}
		break;
	case RPC_NOTIFYENTER__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyEnter(object);
			
		}
		break;
	case RPC_NOTIFYEXIT__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyExit(object);
			
		}
		break;
	case RPC_DESTROYOBJECTFROMWORLD__BOOL_:
		{
			bool sendSelfDestroy = inv->getBooleanParameter();
			
			destroyObjectFromWorld(sendSelfDestroy);
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_ISNAVAREA__:
		{
			
			bool _m_res = isNavArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ASNAVAREA__:
		{
			
			DistributedObject* _m_res = asNavArea();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_OBJECTINMESH__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = objectInMesh(obj);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETMESHNAME__:
		{
			
			String _m_res = getMeshName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETMESHNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setMeshName(name);
			
		}
		break;
	case RPC_ISINRANGE__FLOAT_FLOAT_FLOAT_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			float range = inv->getFloatParameter();
			
			bool _m_res = isInRange(x, y, range);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_UPDATENAVMESH__SCENEOBJECT_BOOL_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			bool toRemove = inv->getBooleanParameter();
			
			updateNavMesh(object, toRemove);
			
		}
		break;
	case RPC_CONTAINSPOINT__FLOAT_FLOAT_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			
			bool _m_res = containsPoint(x, y);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNAVMESHLOADED__:
		{
			
			bool _m_res = isNavMeshLoaded();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCONTAINEDOBJECTSCOUNT__:
		{
			
			int _m_res = getContainedObjectsCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETAREATERRAINHEIGHT__:
		{
			
			float _m_res = getAreaTerrainHeight();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETAREATERRAINHEIGHT__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setAreaTerrainHeight(value);
			
		}
		break;
	default:
		ActiveAreaAdapter::invokeMethod(methid, inv);
	}
}

void NavAreaAdapter::initialize() {
	(static_cast<NavArea*>(stub))->initialize();
}

void NavAreaAdapter::notifyEnter(SceneObject* object) {
	(static_cast<NavArea*>(stub))->notifyEnter(object);
}

void NavAreaAdapter::notifyExit(SceneObject* object) {
	(static_cast<NavArea*>(stub))->notifyExit(object);
}

void NavAreaAdapter::destroyObjectFromWorld(bool sendSelfDestroy) {
	(static_cast<NavArea*>(stub))->destroyObjectFromWorld(sendSelfDestroy);
}

void NavAreaAdapter::notifyLoadFromDatabase() {
	(static_cast<NavArea*>(stub))->notifyLoadFromDatabase();
}

bool NavAreaAdapter::isNavArea() {
	return (static_cast<NavArea*>(stub))->isNavArea();
}

NavArea* NavAreaAdapter::asNavArea() {
	return (static_cast<NavArea*>(stub))->asNavArea();
}

bool NavAreaAdapter::objectInMesh(SceneObject* obj) {
	return (static_cast<NavArea*>(stub))->objectInMesh(obj);
}

String NavAreaAdapter::getMeshName() {
	return (static_cast<NavArea*>(stub))->getMeshName();
}

void NavAreaAdapter::setMeshName(const String& name) {
	(static_cast<NavArea*>(stub))->setMeshName(name);
}

bool NavAreaAdapter::isInRange(float x, float y, float range) {
	return (static_cast<NavArea*>(stub))->isInRange(x, y, range);
}

void NavAreaAdapter::updateNavMesh(SceneObject* object, bool toRemove) {
	(static_cast<NavArea*>(stub))->updateNavMesh(object, toRemove);
}

bool NavAreaAdapter::containsPoint(float x, float y) {
	return (static_cast<NavArea*>(stub))->containsPoint(x, y);
}

bool NavAreaAdapter::isNavMeshLoaded() const {
	return (static_cast<NavArea*>(stub))->isNavMeshLoaded();
}

int NavAreaAdapter::getContainedObjectsCount() {
	return (static_cast<NavArea*>(stub))->getContainedObjectsCount();
}

float NavAreaAdapter::getAreaTerrainHeight() const {
	return (static_cast<NavArea*>(stub))->getAreaTerrainHeight();
}

void NavAreaAdapter::setAreaTerrainHeight(float value) {
	(static_cast<NavArea*>(stub))->setAreaTerrainHeight(value);
}

/*
 *	NavAreaHelper
 */

NavAreaHelper* NavAreaHelper::staticInitializer = NavAreaHelper::instance();

NavAreaHelper::NavAreaHelper() {
	className = "NavArea";

	Core::getObjectBroker()->registerClass(className, this);
}

void NavAreaHelper::finalizeHelper() {
	NavAreaHelper::finalize();
}

DistributedObject* NavAreaHelper::instantiateObject() {
	return new NavArea(DummyConstructorParameter::instance());
}

DistributedObjectServant* NavAreaHelper::instantiateServant() {
	return new NavAreaImplementation();
}

DistributedObjectPOD* NavAreaHelper::instantiatePOD() {
	return new NavAreaPOD();
}

DistributedObjectAdapter* NavAreaHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new NavAreaAdapter(static_cast<NavArea*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	NavAreaPOD
 */

NavAreaPOD::~NavAreaPOD() {
	finalize();
}

NavAreaPOD::NavAreaPOD(void) {
	_className = "NavArea";
}


void NavAreaPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = NavAreaPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int NavAreaPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ActiveAreaPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (meshName) {
	_nameHashCode = 0xbd165d01; //NavArea.meshName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&meshName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (recastNavMesh) {
	_nameHashCode = 0xd72dfeb8; //NavArea.recastNavMesh
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<RecastNavMesh >::toBinaryStream(&recastNavMesh.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (disableUpdates) {
	_nameHashCode = 0x71c9b071; //NavArea.disableUpdates
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&disableUpdates.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (meshBounds) {
	_nameHashCode = 0xd656aa90; //NavArea.meshBounds
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AABB >::toBinaryStream(&meshBounds.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (containedObjects) {
	_nameHashCode = 0xf921eb2c; //NavArea.containedObjects
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<HashSet<unsigned long long> >::toBinaryStream(&containedObjects.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool NavAreaPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ActiveAreaPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xbd165d01: //NavArea.meshName
		{
			String _mnmeshName;
			TypeInfo<String >::parseFromBinaryStream(&_mnmeshName, stream);
			meshName = std::move(_mnmeshName);
		}
		return true;

	case 0xd72dfeb8: //NavArea.recastNavMesh
		{
			RecastNavMesh _mnrecastNavMesh;
			TypeInfo<RecastNavMesh >::parseFromBinaryStream(&_mnrecastNavMesh, stream);
			recastNavMesh = std::move(_mnrecastNavMesh);
		}
		return true;

	case 0x71c9b071: //NavArea.disableUpdates
		{
			bool _mndisableUpdates;
			TypeInfo<bool >::parseFromBinaryStream(&_mndisableUpdates, stream);
			disableUpdates = std::move(_mndisableUpdates);
		}
		return true;

	case 0xd656aa90: //NavArea.meshBounds
		{
			AABB _mnmeshBounds;
			TypeInfo<AABB >::parseFromBinaryStream(&_mnmeshBounds, stream);
			meshBounds = std::move(_mnmeshBounds);
		}
		return true;

	case 0xf921eb2c: //NavArea.containedObjects
		{
			HashSet<unsigned long long> _mncontainedObjects;
			TypeInfo<HashSet<unsigned long long> >::parseFromBinaryStream(&_mncontainedObjects, stream);
			containedObjects = std::move(_mncontainedObjects);
		}
		return true;

	}

	return false;
}

void NavAreaPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(NavAreaPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void NavAreaPOD::writeObjectCompact(ObjectOutputStream* stream) {
	ActiveAreaPOD::writeObjectCompact(stream);

	TypeInfo<String >::toBinaryStream(&meshName.value(), stream);

	TypeInfo<RecastNavMesh >::toBinaryStream(&recastNavMesh.value(), stream);

	TypeInfo<bool >::toBinaryStream(&disableUpdates.value(), stream);

	TypeInfo<AABB >::toBinaryStream(&meshBounds.value(), stream);

	TypeInfo<HashSet<unsigned long long> >::toBinaryStream(&containedObjects.value(), stream);


}

