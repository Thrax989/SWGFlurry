/*
 *	autogen/server/zone/managers/gcw/GCWManager.cpp generated by engine3 IDL compiler 0.70
 */

#include "GCWManager.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/objects/structure/StructureObject.h"

#include "server/zone/objects/building/BuildingObject.h"

#include "server/zone/objects/installation/InstallationObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/creature/ai/AiAgent.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/tangible/deed/Deed.h"

#include "server/zone/managers/gcw/TerminalSpawn.h"

/*
 *	GCWManagerStub
 */

enum {RPC_GETZONE__ = 3465843338,RPC_INITIALIZE__,RPC_START__,RPC_LOADLUACONFIG__,RPC_STOP__,RPC_PERFORMGCWTASKS__BOOL_,RPC_CANPLACEMOREBASES__CREATUREOBJECT_,RPC_GETBASECOUNT__CREATUREOBJECT_,RPC_HASTOOMANYBASESNEARBY__INT_INT_,RPC_REGISTERGCWBASE__BUILDINGOBJECT_BOOL_,RPC_UNREGISTERGCWBASE__BUILDINGOBJECT_,RPC_ADDMINEFIELD__BUILDINGOBJECT_SCENEOBJECT_,RPC_ADDSCANNER__BUILDINGOBJECT_SCENEOBJECT_,RPC_ADDTURRET__BUILDINGOBJECT_SCENEOBJECT_,RPC_STARTVULNERABILITY__BUILDINGOBJECT_,RPC_ENDVULNERABILITY__BUILDINGOBJECT_,RPC_INITIALIZENEWVULNERABILITY__BUILDINGOBJECT_,RPC_GETVULNERABLESTATUS__BUILDINGOBJECT_CREATUREOBJECT_,RPC_ISBASEVULNERABLE__BUILDINGOBJECT_,RPC_ISBANDIDENTIFIED__BUILDINGOBJECT_,RPC_ISUPLINKJAMMED__BUILDINGOBJECT_,RPC_ISTERMINALDAMAGED__TANGIBLEOBJECT_,RPC_ISSECURITYTERMSLICED__BUILDINGOBJECT_,RPC_ISDNASAMPLED__BUILDINGOBJECT_,RPC_ISPOWEROVERLOADED__BUILDINGOBJECT_,RPC_ISSHUTDOWNSEQUENCESTARTED__BUILDINGOBJECT_,RPC_ISFACILITYREBOOTING__BUILDINGOBJECT_,RPC_CANUSETERMINALS__CREATUREOBJECT_BUILDINGOBJECT_SCENEOBJECT_,RPC_AREOPPOSINGFACTIONS__INT_INT_,RPC_AWARDSLICINGXP__CREATUREOBJECT_STRING_INT_,RPC_SENDJAMUPLINKMENU__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_,RPC_VERIFYUPLINKBAND__CREATUREOBJECT_BUILDINGOBJECT_INT_TANGIBLEOBJECT_,RPC_CANSTARTSLICE__CREATUREOBJECT_TANGIBLEOBJECT_,RPC_COMPLETESECURITYSLICE__CREATUREOBJECT_TANGIBLEOBJECT_,RPC_FAILSECURITYSLICE__TANGIBLEOBJECT_,RPC_REPAIRTERMINAL__CREATUREOBJECT_TANGIBLEOBJECT_,RPC_SENDDNASAMPLEMENU__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_,RPC_PROCESSDNASAMPLE__CREATUREOBJECT_TANGIBLEOBJECT_INT_,RPC_SENDPOWERREGULATORCONTROLS__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_,RPC_HANDLEPOWERREGULATORSWITCH__CREATUREOBJECT_TANGIBLEOBJECT_INT_,RPC_SCHEDULEBASEDESTRUCTION__BUILDINGOBJECT_CREATUREOBJECT_,RPC_DOBASEDESTRUCTION__STRUCTUREOBJECT_,RPC_DOBASEDESTRUCTION__BUILDINGOBJECT_,RPC_STARTABORTSEQUENCEDELAY__BUILDINGOBJECT_CREATUREOBJECT_SCENEOBJECT_,RPC_ABORTSHUTDOWNSEQUENCE__BUILDINGOBJECT_CREATUREOBJECT_,RPC_RESETVULNERABILITY__CREATUREOBJECT_BUILDINGOBJECT_,RPC_HASRESETTIMERPAST__BUILDINGOBJECT_,RPC_SENDBASEDEFENSESTATUS__CREATUREOBJECT_BUILDINGOBJECT_,RPC_SENDREMOVEDEFENSECONFIRMATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_,RPC_REMOVEDEFENSE__BUILDINGOBJECT_CREATUREOBJECT_LONG_,RPC_NOTIFYINSTALLATIONDESTRUCTION__INSTALLATIONOBJECT_,RPC_NOTIFYTURRETDESTRUCTION__BUILDINGOBJECT_INSTALLATIONOBJECT_,RPC_NOTIFYMINEFIELDDESTRUCTION__BUILDINGOBJECT_INSTALLATIONOBJECT_,RPC_SENDSELECTDEEDTODONATE__BUILDINGOBJECT_CREATUREOBJECT_,RPC_PERFORMDEFENSEDONATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_,RPC_SENDTURRETATTACKLISTTO__CREATUREOBJECT_SCENEOBJECT_,RPC_CANUSETURRET__TANGIBLEOBJECT_SCENEOBJECT_CREATUREOBJECT_,RPC_GETGCWDISCOUNT__CREATUREOBJECT_,RPC_RUNCRACKDOWNSCAN__AIAGENT_CREATUREOBJECT_,RPC_ISSTRONGHOLDCITY__STRING_,RPC_GETMAXBASESPERPLAYER__,RPC_ISPLANETCAPPED__,RPC_GETIMPERIALBASECOUNT__,RPC_GETREBELBASECOUNT__,RPC_GETTURRETAUTOFIRETIMEOUT__,RPC_GETDESTRUCTIONTIMER__,RPC_GETOVERTCOOLDOWN__,RPC_GETRESETTIMER__};

GCWManager::GCWManager(Zone* zne) : ManagedService(DummyConstructorParameter::instance()) {
	GCWManagerImplementation* _implementation = new GCWManagerImplementation(zne);
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("GCWManager");
}

GCWManager::GCWManager(DummyConstructorParameter* param) : ManagedService(param) {
	_setClassName("GCWManager");
}

GCWManager::~GCWManager() {
}



Zone* GCWManager::getZone() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETZONE__);

		return static_cast<Zone*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getZone();
	}
}

void GCWManager::initialize() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initialize();
	}
}

void GCWManager::start() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_START__);

		method.executeWithVoidReturn();
	} else {
		_implementation->start();
	}
}

void GCWManager::loadLuaConfig() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOADLUACONFIG__);

		method.executeWithVoidReturn();
	} else {
		_implementation->loadLuaConfig();
	}
}

void GCWManager::stop() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->stop();
	}
}

void GCWManager::performGCWTasks(bool initial) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PERFORMGCWTASKS__BOOL_);
		method.addBooleanParameter(initial);

		method.executeWithVoidReturn();
	} else {
		_implementation->performGCWTasks(initial);
	}
}

bool GCWManager::canPlaceMoreBases(CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANPLACEMOREBASES__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canPlaceMoreBases(creature);
	}
}

int GCWManager::getBaseCount(CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASECOUNT__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseCount(creature);
	}
}

bool GCWManager::hasTooManyBasesNearby(int x, int y) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASTOOMANYBASESNEARBY__INT_INT_);
		method.addSignedIntParameter(x);
		method.addSignedIntParameter(y);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasTooManyBasesNearby(x, y);
	}
}

void GCWManager::registerGCWBase(BuildingObject* building, bool initializeBase) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REGISTERGCWBASE__BUILDINGOBJECT_BOOL_);
		method.addObjectParameter(building);
		method.addBooleanParameter(initializeBase);

		method.executeWithVoidReturn();
	} else {
		_implementation->registerGCWBase(building, initializeBase);
	}
}

void GCWManager::unregisterGCWBase(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNREGISTERGCWBASE__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else {
		_implementation->unregisterGCWBase(building);
	}
}

void GCWManager::addMinefield(BuildingObject* building, SceneObject* minefield) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDMINEFIELD__BUILDINGOBJECT_SCENEOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(minefield);

		method.executeWithVoidReturn();
	} else {
		_implementation->addMinefield(building, minefield);
	}
}

void GCWManager::addScanner(BuildingObject* building, SceneObject* scanner) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSCANNER__BUILDINGOBJECT_SCENEOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(scanner);

		method.executeWithVoidReturn();
	} else {
		_implementation->addScanner(building, scanner);
	}
}

void GCWManager::addTurret(BuildingObject* building, SceneObject* turret) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTURRET__BUILDINGOBJECT_SCENEOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(turret);

		method.executeWithVoidReturn();
	} else {
		_implementation->addTurret(building, turret);
	}
}

void GCWManager::startVulnerability(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTVULNERABILITY__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else {
		_implementation->startVulnerability(building);
	}
}

void GCWManager::endVulnerability(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENDVULNERABILITY__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else {
		_implementation->endVulnerability(building);
	}
}

void GCWManager::initializeNewVulnerability(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZENEWVULNERABILITY__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeNewVulnerability(building);
	}
}

String GCWManager::getVulnerableStatus(BuildingObject* building, CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVULNERABLESTATUS__BUILDINGOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);

		String _return_getVulnerableStatus;
		method.executeWithAsciiReturn(_return_getVulnerableStatus);
		return _return_getVulnerableStatus;
	} else {
		return _implementation->getVulnerableStatus(building, creature);
	}
}

bool GCWManager::isBaseVulnerable(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBASEVULNERABLE__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isBaseVulnerable(building);
	}
}

bool GCWManager::isBandIdentified(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBANDIDENTIFIED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isBandIdentified(building);
	}
}

bool GCWManager::isUplinkJammed(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUPLINKJAMMED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isUplinkJammed(building);
	}
}

bool GCWManager::isTerminalDamaged(TangibleObject* securityTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTERMINALDAMAGED__TANGIBLEOBJECT_);
		method.addObjectParameter(securityTerminal);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTerminalDamaged(securityTerminal);
	}
}

bool GCWManager::isSecurityTermSliced(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSECURITYTERMSLICED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSecurityTermSliced(building);
	}
}

bool GCWManager::isDNASampled(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDNASAMPLED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDNASampled(building);
	}
}

bool GCWManager::isPowerOverloaded(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOWEROVERLOADED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPowerOverloaded(building);
	}
}

bool GCWManager::isShutdownSequenceStarted(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSHUTDOWNSEQUENCESTARTED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isShutdownSequenceStarted(building);
	}
}

bool GCWManager::isFacilityRebooting(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFACILITYREBOOTING__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFacilityRebooting(building);
	}
}

bool GCWManager::canUseTerminals(CreatureObject* creature, BuildingObject* building, SceneObject* terminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANUSETERMINALS__CREATUREOBJECT_BUILDINGOBJECT_SCENEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addObjectParameter(terminal);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canUseTerminals(creature, building, terminal);
	}
}

bool GCWManager::areOpposingFactions(int faction1, int faction2) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AREOPPOSINGFACTIONS__INT_INT_);
		method.addSignedIntParameter(faction1);
		method.addSignedIntParameter(faction2);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->areOpposingFactions(faction1, faction2);
	}
}

void GCWManager::awardSlicingXP(CreatureObject* creature, const String& xpType, int value) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AWARDSLICINGXP__CREATUREOBJECT_STRING_INT_);
		method.addObjectParameter(creature);
		method.addAsciiParameter(xpType);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->awardSlicingXP(creature, xpType, value);
	}
}

void GCWManager::sendJamUplinkMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* uplinkTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDJAMUPLINKMENU__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addObjectParameter(uplinkTerminal);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendJamUplinkMenu(creature, building, uplinkTerminal);
	}
}

void GCWManager::verifyUplinkBand(CreatureObject* creature, BuildingObject* building, int band, TangibleObject* uplinkTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VERIFYUPLINKBAND__CREATUREOBJECT_BUILDINGOBJECT_INT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addSignedIntParameter(band);
		method.addObjectParameter(uplinkTerminal);

		method.executeWithVoidReturn();
	} else {
		_implementation->verifyUplinkBand(creature, building, band, uplinkTerminal);
	}
}

bool GCWManager::canStartSlice(CreatureObject* creature, TangibleObject* terminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANSTARTSLICE__CREATUREOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(terminal);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canStartSlice(creature, terminal);
	}
}

void GCWManager::completeSecuritySlice(CreatureObject* creature, TangibleObject* securityTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETESECURITYSLICE__CREATUREOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(securityTerminal);

		method.executeWithVoidReturn();
	} else {
		_implementation->completeSecuritySlice(creature, securityTerminal);
	}
}

void GCWManager::failSecuritySlice(TangibleObject* securityTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FAILSECURITYSLICE__TANGIBLEOBJECT_);
		method.addObjectParameter(securityTerminal);

		method.executeWithVoidReturn();
	} else {
		_implementation->failSecuritySlice(securityTerminal);
	}
}

void GCWManager::repairTerminal(CreatureObject* creature, TangibleObject* securityTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REPAIRTERMINAL__CREATUREOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(securityTerminal);

		method.executeWithVoidReturn();
	} else {
		_implementation->repairTerminal(creature, securityTerminal);
	}
}

void GCWManager::sendDNASampleMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* overrideTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDDNASAMPLEMENU__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addObjectParameter(overrideTerminal);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendDNASampleMenu(creature, building, overrideTerminal);
	}
}

void GCWManager::processDNASample(CreatureObject* creature, TangibleObject* overrideTerminal, int indx) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PROCESSDNASAMPLE__CREATUREOBJECT_TANGIBLEOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(overrideTerminal);
		method.addSignedIntParameter(indx);

		method.executeWithVoidReturn();
	} else {
		_implementation->processDNASample(creature, overrideTerminal, indx);
	}
}

void GCWManager::sendPowerRegulatorControls(CreatureObject* creature, BuildingObject* building, TangibleObject* powerRegulator) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDPOWERREGULATORCONTROLS__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addObjectParameter(powerRegulator);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendPowerRegulatorControls(creature, building, powerRegulator);
	}
}

void GCWManager::handlePowerRegulatorSwitch(CreatureObject* creature, TangibleObject* powerRegulator, int indx) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEPOWERREGULATORSWITCH__CREATUREOBJECT_TANGIBLEOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(powerRegulator);
		method.addSignedIntParameter(indx);

		method.executeWithVoidReturn();
	} else {
		_implementation->handlePowerRegulatorSwitch(creature, powerRegulator, indx);
	}
}

void GCWManager::scheduleBaseDestruction(BuildingObject* building, CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEBASEDESTRUCTION__BUILDINGOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->scheduleBaseDestruction(building, creature);
	}
}

void GCWManager::doBaseDestruction(StructureObject* structure) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOBASEDESTRUCTION__STRUCTUREOBJECT_);
		method.addObjectParameter(structure);

		method.executeWithVoidReturn();
	} else {
		_implementation->doBaseDestruction(structure);
	}
}

void GCWManager::doBaseDestruction(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOBASEDESTRUCTION__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else {
		_implementation->doBaseDestruction(building);
	}
}

void GCWManager::broadcastBuilding(BuildingObject* building, StringIdChatParameter& params) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->broadcastBuilding(building, params);
	}
}

void GCWManager::startAbortSequenceDelay(BuildingObject* building, CreatureObject* creature, SceneObject* hqTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTABORTSEQUENCEDELAY__BUILDINGOBJECT_CREATUREOBJECT_SCENEOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);
		method.addObjectParameter(hqTerminal);

		method.executeWithVoidReturn();
	} else {
		_implementation->startAbortSequenceDelay(building, creature, hqTerminal);
	}
}

void GCWManager::abortShutdownSequence(BuildingObject* building, CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ABORTSHUTDOWNSEQUENCE__BUILDINGOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->abortShutdownSequence(building, creature);
	}
}

void GCWManager::resetVulnerability(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETVULNERABILITY__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else {
		_implementation->resetVulnerability(creature, building);
	}
}

bool GCWManager::hasResetTimerPast(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASRESETTIMERPAST__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasResetTimerPast(building);
	}
}

void GCWManager::sendBaseDefenseStatus(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASEDEFENSESTATUS__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaseDefenseStatus(creature, building);
	}
}

void GCWManager::sendRemoveDefenseConfirmation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDREMOVEDEFENSECONFIRMATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(deedOID);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendRemoveDefenseConfirmation(building, creature, deedOID);
	}
}

void GCWManager::removeDefense(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEDEFENSE__BUILDINGOBJECT_CREATUREOBJECT_LONG_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(deedOID);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeDefense(building, creature, deedOID);
	}
}

void GCWManager::notifyInstallationDestruction(InstallationObject* installation) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYINSTALLATIONDESTRUCTION__INSTALLATIONOBJECT_);
		method.addObjectParameter(installation);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyInstallationDestruction(installation);
	}
}

void GCWManager::notifyTurretDestruction(BuildingObject* building, InstallationObject* turret) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYTURRETDESTRUCTION__BUILDINGOBJECT_INSTALLATIONOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(turret);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyTurretDestruction(building, turret);
	}
}

void GCWManager::notifyMinefieldDestruction(BuildingObject* building, InstallationObject* turret) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYMINEFIELDDESTRUCTION__BUILDINGOBJECT_INSTALLATIONOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(turret);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyMinefieldDestruction(building, turret);
	}
}

void GCWManager::sendSelectDeedToDonate(BuildingObject* building, CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSELECTDEEDTODONATE__BUILDINGOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendSelectDeedToDonate(building, creature);
	}
}

void GCWManager::performDefenseDonation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PERFORMDEFENSEDONATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(deedOID);

		method.executeWithVoidReturn();
	} else {
		_implementation->performDefenseDonation(building, creature, deedOID);
	}
}

void GCWManager::sendTurretAttackListTo(CreatureObject* creature, SceneObject* turretControlTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTURRETATTACKLISTTO__CREATUREOBJECT_SCENEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(turretControlTerminal);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendTurretAttackListTo(creature, turretControlTerminal);
	}
}

bool GCWManager::canUseTurret(TangibleObject* turret, SceneObject* terminal, CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANUSETURRET__TANGIBLEOBJECT_SCENEOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(turret);
		method.addObjectParameter(terminal);
		method.addObjectParameter(creature);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canUseTurret(turret, terminal, creature);
	}
}

float GCWManager::getGCWDiscount(CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGCWDISCOUNT__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getGCWDiscount(creature);
	}
}

void GCWManager::runCrackdownScan(AiAgent* scanner, CreatureObject* player) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RUNCRACKDOWNSCAN__AIAGENT_CREATUREOBJECT_);
		method.addObjectParameter(scanner);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->runCrackdownScan(scanner, player);
	}
}

int GCWManager::isStrongholdCity(String& city) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTRONGHOLDCITY__STRING_);
		method.addAsciiParameter(city);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->isStrongholdCity(city);
	}
}

int GCWManager::getMaxBasesPerPlayer() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXBASESPERPLAYER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMaxBasesPerPlayer();
	}
}

bool GCWManager::isPlanetCapped() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLANETCAPPED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPlanetCapped();
	}
}

int GCWManager::getImperialBaseCount() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETIMPERIALBASECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getImperialBaseCount();
	}
}

int GCWManager::getRebelBaseCount() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREBELBASECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getRebelBaseCount();
	}
}

int GCWManager::getRebelScore() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getRebelScore();
	}
}

int GCWManager::getImperialScore() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getImperialScore();
	}
}

void GCWManager::setRebelScore(int val) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setRebelScore(val);
	}
}

void GCWManager::setImperialScore(int val) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setImperialScore(val);
	}
}

unsigned int GCWManager::getWinningFaction() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getWinningFaction();
	}
}

int GCWManager::getWinningFactionDifficultyScaling() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getWinningFactionDifficultyScaling();
	}
}

int GCWManager::getGCWXPBonus() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getGCWXPBonus();
	}
}

int GCWManager::getPointValue(const String& templateString) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPointValue(templateString);
	}
}

void GCWManager::addPointValue(const String& templateString, int val) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addPointValue(templateString, val);
	}
}

void GCWManager::addRacialPenalty(int race, float val) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addRacialPenalty(race, val);
	}
}

float GCWManager::getRacialPenalty(int race) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getRacialPenalty(race);
	}
}

bool GCWManager::isRacialPenaltyEnabled() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->isRacialPenaltyEnabled();
	}
}

bool GCWManager::shouldSpawnDefenses() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->shouldSpawnDefenses();
	}
}

int GCWManager::getInitialVulnerabilityDelay() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getInitialVulnerabilityDelay();
	}
}

int GCWManager::getTurretAutoFireTimeout() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTURRETAUTOFIRETIMEOUT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getTurretAutoFireTimeout();
	}
}

int GCWManager::getDestructionTimer() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDESTRUCTIONTIMER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDestructionTimer();
	}
}

int GCWManager::getOvertCooldown() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOVERTCOOLDOWN__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getOvertCooldown();
	}
}

int GCWManager::getResetTimer() const {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRESETTIMER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getResetTimer();
	}
}

DistributedObjectServant* GCWManager::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* GCWManager::_getImplementationForRead() const {
	return _impl;
}

void GCWManager::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	GCWManagerImplementation
 */

GCWManagerImplementation::GCWManagerImplementation(DummyConstructorParameter* param) : ManagedServiceImplementation(param) {
	_initializeImplementation();
}


GCWManagerImplementation::~GCWManagerImplementation() {
}


void GCWManagerImplementation::finalize() {
}

void GCWManagerImplementation::_initializeImplementation() {
	_setClassHelper(GCWManagerHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void GCWManagerImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<GCWManager*>(stub);
	ManagedServiceImplementation::_setStub(stub);
}

DistributedObjectStub* GCWManagerImplementation::_getStub() {
	return _this.get();
}

GCWManagerImplementation::operator const GCWManager*() {
	return _this.get();
}

void GCWManagerImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void GCWManagerImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void GCWManagerImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void GCWManagerImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void GCWManagerImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void GCWManagerImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void GCWManagerImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void GCWManagerImplementation::_serializationHelperMethod() {
	ManagedServiceImplementation::_serializationHelperMethod();

	_setClassName("GCWManager");

}

void GCWManagerImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(GCWManagerImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool GCWManagerImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ManagedServiceImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xbd7d1995: //GCWManager.zone
		TypeInfo<ManagedReference<Zone* > >::parseFromBinaryStream(&zone, stream);
		return true;

	}

	return false;
}

void GCWManagerImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = GCWManagerImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int GCWManagerImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ManagedServiceImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xbd7d1995; //GCWManager.zone
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<Zone* > >::toBinaryStream(&zone, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

GCWManagerImplementation::GCWManagerImplementation(Zone* zne) {
	_initializeImplementation();
	// server/zone/managers/gcw/GCWManager.idl():  		imperialBases = 0;
	imperialBases = 0;
	// server/zone/managers/gcw/GCWManager.idl():  		imperialScore = 0;
	imperialScore = 0;
	// server/zone/managers/gcw/GCWManager.idl():  		rebelBases = 0;
	rebelBases = 0;
	// server/zone/managers/gcw/GCWManager.idl():  		rebelScore = 0;
	rebelScore = 0;
	// server/zone/managers/gcw/GCWManager.idl():  		winningFaction = Factions.FACTIONNEUTRAL;
	winningFaction = Factions::FACTIONNEUTRAL;
	// server/zone/managers/gcw/GCWManager.idl():  		winnerDifficultyScaling = 1;
	winnerDifficultyScaling = 1;
	// server/zone/managers/gcw/GCWManager.idl():  		gcwCheckTimer = 3600;
	gcwCheckTimer = 3600;
	// server/zone/managers/gcw/GCWManager.idl():  		vulnerabilityDuration = 7200;
	vulnerabilityDuration = 7200;
	// server/zone/managers/gcw/GCWManager.idl():  		vulnerabilityFrequency = 172800;
	vulnerabilityFrequency = 172800;
	// server/zone/managers/gcw/GCWManager.idl():  		resetTimer = 604800;
	resetTimer = 604800;
	// server/zone/managers/gcw/GCWManager.idl():  		sliceCooldown = 120;
	sliceCooldown = 120;
	// server/zone/managers/gcw/GCWManager.idl():  		totalDNASamples = 10;
	totalDNASamples = 10;
	// server/zone/managers/gcw/GCWManager.idl():  		dnaStrandLength = 23;
	dnaStrandLength = 23;
	// server/zone/managers/gcw/GCWManager.idl():  		destructionTimer = 600;
	destructionTimer = 600;
	// server/zone/managers/gcw/GCWManager.idl():  		maxBases = -1;
	maxBases = -1;
	// server/zone/managers/gcw/GCWManager.idl():  		powerSwitchCount = 7;
	powerSwitchCount = 7;
	// server/zone/managers/gcw/GCWManager.idl():  		overtCooldown = 300;
	overtCooldown = 300;
	// server/zone/managers/gcw/GCWManager.idl():  		reactivationTimer = 300;
	reactivationTimer = 300;
	// server/zone/managers/gcw/GCWManager.idl():  		turretAutoFireTimeout = 20;
	turretAutoFireTimeout = 20;
	// server/zone/managers/gcw/GCWManager.idl():  		maxBasesPerPlayer = 3;
	maxBasesPerPlayer = 3;
	// server/zone/managers/gcw/GCWManager.idl():  		bonusXP = 15;
	bonusXP = 15;
	// server/zone/managers/gcw/GCWManager.idl():  		loserBonus = 0;
	loserBonus = 0;
	// server/zone/managers/gcw/GCWManager.idl():  		winnerBonus = 30;
	winnerBonus = 30;
	// server/zone/managers/gcw/GCWManager.idl():  		racialPenaltyEnabled = true;
	racialPenaltyEnabled = true;
	// server/zone/managers/gcw/GCWManager.idl():  		spawnDefenses = true;
	spawnDefenses = true;
	// server/zone/managers/gcw/GCWManager.idl():  		initialVulnerabilityDelay = 0;
	initialVulnerabilityDelay = 0;
	// server/zone/managers/gcw/GCWManager.idl():  		Logger.setLoggingName("GCWManager " + zne.getZoneName());
	Logger::setLoggingName("GCWManager " + zne->getZoneName());
	// server/zone/managers/gcw/GCWManager.idl():  		Logger.info("instantiated", true);
	Logger::info("instantiated", true);
	// server/zone/managers/gcw/GCWManager.idl():  		gcwBaseList.setNoDuplicateInsertPlan();
	(&gcwBaseList)->setNoDuplicateInsertPlan();
	// server/zone/managers/gcw/GCWManager.idl():  		zone = zne;
	zone = zne;
	// server/zone/managers/gcw/GCWManager.idl():  		gcwStartTasks.setNoDuplicateInsertPlan();
	(&gcwStartTasks)->setNoDuplicateInsertPlan();
	// server/zone/managers/gcw/GCWManager.idl():  		gcwStartTasks.setNullValue(null);
	(&gcwStartTasks)->setNullValue(NULL);
	// server/zone/managers/gcw/GCWManager.idl():  		gcwEndTasks.setNoDuplicateInsertPlan();
	(&gcwEndTasks)->setNoDuplicateInsertPlan();
	// server/zone/managers/gcw/GCWManager.idl():  		gcwEndTasks.setNullValue(null);
	(&gcwEndTasks)->setNullValue(NULL);
	// server/zone/managers/gcw/GCWManager.idl():  		gcwDestroyTasks.setNoDuplicateInsertPlan();
	(&gcwDestroyTasks)->setNoDuplicateInsertPlan();
	// server/zone/managers/gcw/GCWManager.idl():  		gcwDestroyTasks.setNullValue(null);
	(&gcwDestroyTasks)->setNullValue(NULL);
	// server/zone/managers/gcw/GCWManager.idl():  		baseValue.setNoDuplicateInsertPlan();
	(&baseValue)->setNoDuplicateInsertPlan();
}

Zone* GCWManagerImplementation::getZone() {
	// server/zone/managers/gcw/GCWManager.idl():  		return zone;
	return zone;
}

bool GCWManagerImplementation::hasBase(BuildingObject* building) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwBaseList.contains(building);
	return (&gcwBaseList)->contains(building);
}

bool GCWManagerImplementation::dropBase(BuildingObject* building) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwBaseList.drop(building);
	return (&gcwBaseList)->drop(building);
}

void GCWManagerImplementation::addBase(BuildingObject* building) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		gcwBaseList.put(building);
	(&gcwBaseList)->put(building);
}

BuildingObject* GCWManagerImplementation::getBase(int indx) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwBaseList.get(indx);
	return (&gcwBaseList)->get(indx);
}

bool GCWManagerImplementation::hasStartTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwStartTasks.contains(id);
	return (&gcwStartTasks)->contains(id);
}

bool GCWManagerImplementation::addStartTask(unsigned long long id, Reference<Task*> newTask) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return 
	if (!(&gcwStartTasks)->contains(id)){
	// server/zone/managers/gcw/GCWManager.idl():  			return gcwStartTasks.put(id, newTask);
	return (&gcwStartTasks)->put(id, newTask);
}
	// server/zone/managers/gcw/GCWManager.idl():  		return false;
	return false;
}

Reference<Task*> GCWManagerImplementation::getStartTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwStartTasks.get(id);
	return (&gcwStartTasks)->get(id);
}

bool GCWManagerImplementation::dropStartTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwStartTasks.drop(id);
	return (&gcwStartTasks)->drop(id);
}

bool GCWManagerImplementation::hasEndTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwEndTasks.contains(id);
	return (&gcwEndTasks)->contains(id);
}

bool GCWManagerImplementation::addEndTask(unsigned long long id, Reference<Task*> newTask) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return 
	if (!(&gcwEndTasks)->contains(id)){
	// server/zone/managers/gcw/GCWManager.idl():  			return	gcwEndTasks.put(id, newTask);
	return (&gcwEndTasks)->put(id, newTask);
}
	// server/zone/managers/gcw/GCWManager.idl():  		return false;
	return false;
}

Reference<Task*> GCWManagerImplementation::getEndTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwEndTasks.get(id);
	return (&gcwEndTasks)->get(id);
}

bool GCWManagerImplementation::dropEndTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwEndTasks.drop(id);
	return (&gcwEndTasks)->drop(id);
}

bool GCWManagerImplementation::hasDestroyTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwDestroyTasks.contains(id);
	return (&gcwDestroyTasks)->contains(id);
}

bool GCWManagerImplementation::addDestroyTask(unsigned long long id, Reference<Task*> newTask) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return 
	if (!(&gcwDestroyTasks)->contains(id)){
	// server/zone/managers/gcw/GCWManager.idl():  			return gcwDestroyTasks.put(id, newTask);
	return (&gcwDestroyTasks)->put(id, newTask);
}
	// server/zone/managers/gcw/GCWManager.idl():  		return false;
	return false;
}

Reference<Task*> GCWManagerImplementation::getDestroyTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwDestroyTasks.get(id);
	return (&gcwDestroyTasks)->get(id);
}

bool GCWManagerImplementation::dropDestroyTask(unsigned long long id) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwDestroyTasks.drop(id);
	return (&gcwDestroyTasks)->drop(id);
}

int GCWManagerImplementation::getMaxBasesPerPlayer() {
	// server/zone/managers/gcw/GCWManager.idl():  		return maxBasesPerPlayer;
	return maxBasesPerPlayer;
}

bool GCWManagerImplementation::isPlanetCapped() {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/managers/gcw/GCWManager.idl():  		return maxBases <= gcwBaseList.size();
	return maxBases <= (&gcwBaseList)->size();
}

int GCWManagerImplementation::getImperialBaseCount() {
	// server/zone/managers/gcw/GCWManager.idl():  		return imperialBases;
	return imperialBases;
}

int GCWManagerImplementation::getRebelBaseCount() {
	// server/zone/managers/gcw/GCWManager.idl():  		return rebelBases;
	return rebelBases;
}

int GCWManagerImplementation::getRebelScore() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return rebelScore;
	return rebelScore;
}

int GCWManagerImplementation::getImperialScore() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return imperialScore;
	return imperialScore;
}

void GCWManagerImplementation::setRebelScore(int val) {
	// server/zone/managers/gcw/GCWManager.idl():  		rebelScore = val;
	rebelScore = val;
}

void GCWManagerImplementation::setImperialScore(int val) {
	// server/zone/managers/gcw/GCWManager.idl():  		imperialScore = val;
	imperialScore = val;
}

void GCWManagerImplementation::setRebelBaseCount(int val) {
	// server/zone/managers/gcw/GCWManager.idl():  		rebelBases = val;
	rebelBases = val;
}

void GCWManagerImplementation::setImperialBaseCount(int val) {
	// server/zone/managers/gcw/GCWManager.idl():  		imperialBases = val;
	imperialBases = val;
}

unsigned int GCWManagerImplementation::getWinningFaction() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return winningFaction;
	return winningFaction;
}

int GCWManagerImplementation::getWinningFactionDifficultyScaling() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return winnerDifficultyScaling;
	return winnerDifficultyScaling;
}

int GCWManagerImplementation::getGCWXPBonus() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return bonusXP;
	return bonusXP;
}

int GCWManagerImplementation::getPointValue(const String& templateString) {
	// server/zone/managers/gcw/GCWManager.idl():  		}
{
	Locker _locker((&baseMutex));
	// server/zone/managers/gcw/GCWManager.idl():  			return baseValue.get(templateString);
	return (&baseValue)->get(templateString);
}
}

void GCWManagerImplementation::addPointValue(const String& templateString, int val) {
	// server/zone/managers/gcw/GCWManager.idl():  		baseValue.put(templateString, val);
	(&baseValue)->put(templateString, val);
}

void GCWManagerImplementation::addRacialPenalty(int race, float val) {
	// server/zone/managers/gcw/GCWManager.idl():  		racialPenaltyMap.put(race, val);
	(&racialPenaltyMap)->put(race, val);
}

float GCWManagerImplementation::getRacialPenalty(int race) {
	// server/zone/managers/gcw/GCWManager.idl():  		}
{
	Locker _locker((&baseMutex));
	// server/zone/managers/gcw/GCWManager.idl():  			return racialPenaltyMap.get(race);
	return (&racialPenaltyMap)->get(race);
}
}

bool GCWManagerImplementation::isRacialPenaltyEnabled() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return racialPenaltyEnabled;
	return racialPenaltyEnabled;
}

bool GCWManagerImplementation::shouldSpawnDefenses() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return spawnDefenses;
	return spawnDefenses;
}

int GCWManagerImplementation::getInitialVulnerabilityDelay() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return initialVulnerabilityDelay;
	return initialVulnerabilityDelay;
}

int GCWManagerImplementation::getTurretAutoFireTimeout() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return turretAutoFireTimeout;
	return turretAutoFireTimeout;
}

int GCWManagerImplementation::getDestructionTimer() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return destructionTimer;
	return destructionTimer;
}

int GCWManagerImplementation::getOvertCooldown() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return overtCooldown;
	return overtCooldown;
}

int GCWManagerImplementation::getResetTimer() const{
	// server/zone/managers/gcw/GCWManager.idl():  		return resetTimer;
	return resetTimer;
}

/*
 *	GCWManagerAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


GCWManagerAdapter::GCWManagerAdapter(GCWManager* obj) : ManagedServiceAdapter(obj) {
}

void GCWManagerAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_GETZONE__:
		{
			
			DistributedObject* _m_res = getZone();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_INITIALIZE__:
		{
			
			initialize();
			
		}
		break;
	case RPC_START__:
		{
			
			start();
			
		}
		break;
	case RPC_LOADLUACONFIG__:
		{
			
			loadLuaConfig();
			
		}
		break;
	case RPC_STOP__:
		{
			
			stop();
			
		}
		break;
	case RPC_PERFORMGCWTASKS__BOOL_:
		{
			bool initial = inv->getBooleanParameter();
			
			performGCWTasks(initial);
			
		}
		break;
	case RPC_CANPLACEMOREBASES__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = canPlaceMoreBases(creature);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETBASECOUNT__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			int _m_res = getBaseCount(creature);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASTOOMANYBASESNEARBY__INT_INT_:
		{
			int x = inv->getSignedIntParameter();
			int y = inv->getSignedIntParameter();
			
			bool _m_res = hasTooManyBasesNearby(x, y);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_REGISTERGCWBASE__BUILDINGOBJECT_BOOL_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			bool initializeBase = inv->getBooleanParameter();
			
			registerGCWBase(building, initializeBase);
			
		}
		break;
	case RPC_UNREGISTERGCWBASE__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			unregisterGCWBase(building);
			
		}
		break;
	case RPC_ADDMINEFIELD__BUILDINGOBJECT_SCENEOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			SceneObject* minefield = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addMinefield(building, minefield);
			
		}
		break;
	case RPC_ADDSCANNER__BUILDINGOBJECT_SCENEOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			SceneObject* scanner = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addScanner(building, scanner);
			
		}
		break;
	case RPC_ADDTURRET__BUILDINGOBJECT_SCENEOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			SceneObject* turret = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addTurret(building, turret);
			
		}
		break;
	case RPC_STARTVULNERABILITY__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			startVulnerability(building);
			
		}
		break;
	case RPC_ENDVULNERABILITY__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			endVulnerability(building);
			
		}
		break;
	case RPC_INITIALIZENEWVULNERABILITY__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			initializeNewVulnerability(building);
			
		}
		break;
	case RPC_GETVULNERABLESTATUS__BUILDINGOBJECT_CREATUREOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			String _m_res = getVulnerableStatus(building, creature);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISBASEVULNERABLE__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = isBaseVulnerable(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISBANDIDENTIFIED__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = isBandIdentified(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISUPLINKJAMMED__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = isUplinkJammed(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISTERMINALDAMAGED__TANGIBLEOBJECT_:
		{
			TangibleObject* securityTerminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			bool _m_res = isTerminalDamaged(securityTerminal);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSECURITYTERMSLICED__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = isSecurityTermSliced(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDNASAMPLED__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = isDNASampled(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPOWEROVERLOADED__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = isPowerOverloaded(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSHUTDOWNSEQUENCESTARTED__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = isShutdownSequenceStarted(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFACILITYREBOOTING__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = isFacilityRebooting(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANUSETERMINALS__CREATUREOBJECT_BUILDINGOBJECT_SCENEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			SceneObject* terminal = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = canUseTerminals(creature, building, terminal);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_AREOPPOSINGFACTIONS__INT_INT_:
		{
			int faction1 = inv->getSignedIntParameter();
			int faction2 = inv->getSignedIntParameter();
			
			bool _m_res = areOpposingFactions(faction1, faction2);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_AWARDSLICINGXP__CREATUREOBJECT_STRING_INT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			 String xpType; inv->getAsciiParameter(xpType);
			int value = inv->getSignedIntParameter();
			
			awardSlicingXP(creature, xpType, value);
			
		}
		break;
	case RPC_SENDJAMUPLINKMENU__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			TangibleObject* uplinkTerminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			sendJamUplinkMenu(creature, building, uplinkTerminal);
			
		}
		break;
	case RPC_VERIFYUPLINKBAND__CREATUREOBJECT_BUILDINGOBJECT_INT_TANGIBLEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			int band = inv->getSignedIntParameter();
			TangibleObject* uplinkTerminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			verifyUplinkBand(creature, building, band, uplinkTerminal);
			
		}
		break;
	case RPC_CANSTARTSLICE__CREATUREOBJECT_TANGIBLEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			TangibleObject* terminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			bool _m_res = canStartSlice(creature, terminal);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_COMPLETESECURITYSLICE__CREATUREOBJECT_TANGIBLEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			TangibleObject* securityTerminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			completeSecuritySlice(creature, securityTerminal);
			
		}
		break;
	case RPC_FAILSECURITYSLICE__TANGIBLEOBJECT_:
		{
			TangibleObject* securityTerminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			failSecuritySlice(securityTerminal);
			
		}
		break;
	case RPC_REPAIRTERMINAL__CREATUREOBJECT_TANGIBLEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			TangibleObject* securityTerminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			repairTerminal(creature, securityTerminal);
			
		}
		break;
	case RPC_SENDDNASAMPLEMENU__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			TangibleObject* overrideTerminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			sendDNASampleMenu(creature, building, overrideTerminal);
			
		}
		break;
	case RPC_PROCESSDNASAMPLE__CREATUREOBJECT_TANGIBLEOBJECT_INT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			TangibleObject* overrideTerminal = static_cast<TangibleObject*>(inv->getObjectParameter());
			int indx = inv->getSignedIntParameter();
			
			processDNASample(creature, overrideTerminal, indx);
			
		}
		break;
	case RPC_SENDPOWERREGULATORCONTROLS__CREATUREOBJECT_BUILDINGOBJECT_TANGIBLEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			TangibleObject* powerRegulator = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			sendPowerRegulatorControls(creature, building, powerRegulator);
			
		}
		break;
	case RPC_HANDLEPOWERREGULATORSWITCH__CREATUREOBJECT_TANGIBLEOBJECT_INT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			TangibleObject* powerRegulator = static_cast<TangibleObject*>(inv->getObjectParameter());
			int indx = inv->getSignedIntParameter();
			
			handlePowerRegulatorSwitch(creature, powerRegulator, indx);
			
		}
		break;
	case RPC_SCHEDULEBASEDESTRUCTION__BUILDINGOBJECT_CREATUREOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			scheduleBaseDestruction(building, creature);
			
		}
		break;
	case RPC_DOBASEDESTRUCTION__STRUCTUREOBJECT_:
		{
			StructureObject* structure = static_cast<StructureObject*>(inv->getObjectParameter());
			
			doBaseDestruction(structure);
			
		}
		break;
	case RPC_DOBASEDESTRUCTION__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			doBaseDestruction(building);
			
		}
		break;
	case RPC_STARTABORTSEQUENCEDELAY__BUILDINGOBJECT_CREATUREOBJECT_SCENEOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			SceneObject* hqTerminal = static_cast<SceneObject*>(inv->getObjectParameter());
			
			startAbortSequenceDelay(building, creature, hqTerminal);
			
		}
		break;
	case RPC_ABORTSHUTDOWNSEQUENCE__BUILDINGOBJECT_CREATUREOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			abortShutdownSequence(building, creature);
			
		}
		break;
	case RPC_RESETVULNERABILITY__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			resetVulnerability(creature, building);
			
		}
		break;
	case RPC_HASRESETTIMERPAST__BUILDINGOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			bool _m_res = hasResetTimerPast(building);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDBASEDEFENSESTATUS__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			sendBaseDefenseStatus(creature, building);
			
		}
		break;
	case RPC_SENDREMOVEDEFENSECONFIRMATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long deedOID = inv->getUnsignedLongParameter();
			
			sendRemoveDefenseConfirmation(building, creature, deedOID);
			
		}
		break;
	case RPC_REMOVEDEFENSE__BUILDINGOBJECT_CREATUREOBJECT_LONG_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long deedOID = inv->getUnsignedLongParameter();
			
			removeDefense(building, creature, deedOID);
			
		}
		break;
	case RPC_NOTIFYINSTALLATIONDESTRUCTION__INSTALLATIONOBJECT_:
		{
			InstallationObject* installation = static_cast<InstallationObject*>(inv->getObjectParameter());
			
			notifyInstallationDestruction(installation);
			
		}
		break;
	case RPC_NOTIFYTURRETDESTRUCTION__BUILDINGOBJECT_INSTALLATIONOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			InstallationObject* turret = static_cast<InstallationObject*>(inv->getObjectParameter());
			
			notifyTurretDestruction(building, turret);
			
		}
		break;
	case RPC_NOTIFYMINEFIELDDESTRUCTION__BUILDINGOBJECT_INSTALLATIONOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			InstallationObject* turret = static_cast<InstallationObject*>(inv->getObjectParameter());
			
			notifyMinefieldDestruction(building, turret);
			
		}
		break;
	case RPC_SENDSELECTDEEDTODONATE__BUILDINGOBJECT_CREATUREOBJECT_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendSelectDeedToDonate(building, creature);
			
		}
		break;
	case RPC_PERFORMDEFENSEDONATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_:
		{
			BuildingObject* building = static_cast<BuildingObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long deedOID = inv->getUnsignedLongParameter();
			
			performDefenseDonation(building, creature, deedOID);
			
		}
		break;
	case RPC_SENDTURRETATTACKLISTTO__CREATUREOBJECT_SCENEOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			SceneObject* turretControlTerminal = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendTurretAttackListTo(creature, turretControlTerminal);
			
		}
		break;
	case RPC_CANUSETURRET__TANGIBLEOBJECT_SCENEOBJECT_CREATUREOBJECT_:
		{
			TangibleObject* turret = static_cast<TangibleObject*>(inv->getObjectParameter());
			SceneObject* terminal = static_cast<SceneObject*>(inv->getObjectParameter());
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = canUseTurret(turret, terminal, creature);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETGCWDISCOUNT__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			float _m_res = getGCWDiscount(creature);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_RUNCRACKDOWNSCAN__AIAGENT_CREATUREOBJECT_:
		{
			AiAgent* scanner = static_cast<AiAgent*>(inv->getObjectParameter());
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			runCrackdownScan(scanner, player);
			
		}
		break;
	case RPC_ISSTRONGHOLDCITY__STRING_:
		{
			String city; inv->getAsciiParameter(city);
			
			int _m_res = isStrongholdCity(city);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMAXBASESPERPLAYER__:
		{
			
			int _m_res = getMaxBasesPerPlayer();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISPLANETCAPPED__:
		{
			
			bool _m_res = isPlanetCapped();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETIMPERIALBASECOUNT__:
		{
			
			int _m_res = getImperialBaseCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETREBELBASECOUNT__:
		{
			
			int _m_res = getRebelBaseCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETTURRETAUTOFIRETIMEOUT__:
		{
			
			int _m_res = getTurretAutoFireTimeout();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDESTRUCTIONTIMER__:
		{
			
			int _m_res = getDestructionTimer();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETOVERTCOOLDOWN__:
		{
			
			int _m_res = getOvertCooldown();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETRESETTIMER__:
		{
			
			int _m_res = getResetTimer();
			resp->insertSignedInt(_m_res);
		}
		break;
	default:
		ManagedServiceAdapter::invokeMethod(methid, inv);
	}
}

Zone* GCWManagerAdapter::getZone() {
	return (static_cast<GCWManager*>(stub))->getZone();
}

void GCWManagerAdapter::initialize() {
	(static_cast<GCWManager*>(stub))->initialize();
}

void GCWManagerAdapter::start() {
	(static_cast<GCWManager*>(stub))->start();
}

void GCWManagerAdapter::loadLuaConfig() {
	(static_cast<GCWManager*>(stub))->loadLuaConfig();
}

void GCWManagerAdapter::stop() {
	(static_cast<GCWManager*>(stub))->stop();
}

void GCWManagerAdapter::performGCWTasks(bool initial) {
	(static_cast<GCWManager*>(stub))->performGCWTasks(initial);
}

bool GCWManagerAdapter::canPlaceMoreBases(CreatureObject* creature) {
	return (static_cast<GCWManager*>(stub))->canPlaceMoreBases(creature);
}

int GCWManagerAdapter::getBaseCount(CreatureObject* creature) {
	return (static_cast<GCWManager*>(stub))->getBaseCount(creature);
}

bool GCWManagerAdapter::hasTooManyBasesNearby(int x, int y) {
	return (static_cast<GCWManager*>(stub))->hasTooManyBasesNearby(x, y);
}

void GCWManagerAdapter::registerGCWBase(BuildingObject* building, bool initializeBase) {
	(static_cast<GCWManager*>(stub))->registerGCWBase(building, initializeBase);
}

void GCWManagerAdapter::unregisterGCWBase(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->unregisterGCWBase(building);
}

void GCWManagerAdapter::addMinefield(BuildingObject* building, SceneObject* minefield) {
	(static_cast<GCWManager*>(stub))->addMinefield(building, minefield);
}

void GCWManagerAdapter::addScanner(BuildingObject* building, SceneObject* scanner) {
	(static_cast<GCWManager*>(stub))->addScanner(building, scanner);
}

void GCWManagerAdapter::addTurret(BuildingObject* building, SceneObject* turret) {
	(static_cast<GCWManager*>(stub))->addTurret(building, turret);
}

void GCWManagerAdapter::startVulnerability(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->startVulnerability(building);
}

void GCWManagerAdapter::endVulnerability(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->endVulnerability(building);
}

void GCWManagerAdapter::initializeNewVulnerability(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->initializeNewVulnerability(building);
}

String GCWManagerAdapter::getVulnerableStatus(BuildingObject* building, CreatureObject* creature) {
	return (static_cast<GCWManager*>(stub))->getVulnerableStatus(building, creature);
}

bool GCWManagerAdapter::isBaseVulnerable(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isBaseVulnerable(building);
}

bool GCWManagerAdapter::isBandIdentified(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isBandIdentified(building);
}

bool GCWManagerAdapter::isUplinkJammed(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isUplinkJammed(building);
}

bool GCWManagerAdapter::isTerminalDamaged(TangibleObject* securityTerminal) {
	return (static_cast<GCWManager*>(stub))->isTerminalDamaged(securityTerminal);
}

bool GCWManagerAdapter::isSecurityTermSliced(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isSecurityTermSliced(building);
}

bool GCWManagerAdapter::isDNASampled(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isDNASampled(building);
}

bool GCWManagerAdapter::isPowerOverloaded(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isPowerOverloaded(building);
}

bool GCWManagerAdapter::isShutdownSequenceStarted(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isShutdownSequenceStarted(building);
}

bool GCWManagerAdapter::isFacilityRebooting(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isFacilityRebooting(building);
}

bool GCWManagerAdapter::canUseTerminals(CreatureObject* creature, BuildingObject* building, SceneObject* terminal) {
	return (static_cast<GCWManager*>(stub))->canUseTerminals(creature, building, terminal);
}

bool GCWManagerAdapter::areOpposingFactions(int faction1, int faction2) {
	return (static_cast<GCWManager*>(stub))->areOpposingFactions(faction1, faction2);
}

void GCWManagerAdapter::awardSlicingXP(CreatureObject* creature, const String& xpType, int value) {
	(static_cast<GCWManager*>(stub))->awardSlicingXP(creature, xpType, value);
}

void GCWManagerAdapter::sendJamUplinkMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* uplinkTerminal) {
	(static_cast<GCWManager*>(stub))->sendJamUplinkMenu(creature, building, uplinkTerminal);
}

void GCWManagerAdapter::verifyUplinkBand(CreatureObject* creature, BuildingObject* building, int band, TangibleObject* uplinkTerminal) {
	(static_cast<GCWManager*>(stub))->verifyUplinkBand(creature, building, band, uplinkTerminal);
}

bool GCWManagerAdapter::canStartSlice(CreatureObject* creature, TangibleObject* terminal) {
	return (static_cast<GCWManager*>(stub))->canStartSlice(creature, terminal);
}

void GCWManagerAdapter::completeSecuritySlice(CreatureObject* creature, TangibleObject* securityTerminal) {
	(static_cast<GCWManager*>(stub))->completeSecuritySlice(creature, securityTerminal);
}

void GCWManagerAdapter::failSecuritySlice(TangibleObject* securityTerminal) {
	(static_cast<GCWManager*>(stub))->failSecuritySlice(securityTerminal);
}

void GCWManagerAdapter::repairTerminal(CreatureObject* creature, TangibleObject* securityTerminal) {
	(static_cast<GCWManager*>(stub))->repairTerminal(creature, securityTerminal);
}

void GCWManagerAdapter::sendDNASampleMenu(CreatureObject* creature, BuildingObject* building, TangibleObject* overrideTerminal) {
	(static_cast<GCWManager*>(stub))->sendDNASampleMenu(creature, building, overrideTerminal);
}

void GCWManagerAdapter::processDNASample(CreatureObject* creature, TangibleObject* overrideTerminal, int indx) {
	(static_cast<GCWManager*>(stub))->processDNASample(creature, overrideTerminal, indx);
}

void GCWManagerAdapter::sendPowerRegulatorControls(CreatureObject* creature, BuildingObject* building, TangibleObject* powerRegulator) {
	(static_cast<GCWManager*>(stub))->sendPowerRegulatorControls(creature, building, powerRegulator);
}

void GCWManagerAdapter::handlePowerRegulatorSwitch(CreatureObject* creature, TangibleObject* powerRegulator, int indx) {
	(static_cast<GCWManager*>(stub))->handlePowerRegulatorSwitch(creature, powerRegulator, indx);
}

void GCWManagerAdapter::scheduleBaseDestruction(BuildingObject* building, CreatureObject* creature) {
	(static_cast<GCWManager*>(stub))->scheduleBaseDestruction(building, creature);
}

void GCWManagerAdapter::doBaseDestruction(StructureObject* structure) {
	(static_cast<GCWManager*>(stub))->doBaseDestruction(structure);
}

void GCWManagerAdapter::doBaseDestruction(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->doBaseDestruction(building);
}

void GCWManagerAdapter::startAbortSequenceDelay(BuildingObject* building, CreatureObject* creature, SceneObject* hqTerminal) {
	(static_cast<GCWManager*>(stub))->startAbortSequenceDelay(building, creature, hqTerminal);
}

void GCWManagerAdapter::abortShutdownSequence(BuildingObject* building, CreatureObject* creature) {
	(static_cast<GCWManager*>(stub))->abortShutdownSequence(building, creature);
}

void GCWManagerAdapter::resetVulnerability(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->resetVulnerability(creature, building);
}

bool GCWManagerAdapter::hasResetTimerPast(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->hasResetTimerPast(building);
}

void GCWManagerAdapter::sendBaseDefenseStatus(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->sendBaseDefenseStatus(creature, building);
}

void GCWManagerAdapter::sendRemoveDefenseConfirmation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	(static_cast<GCWManager*>(stub))->sendRemoveDefenseConfirmation(building, creature, deedOID);
}

void GCWManagerAdapter::removeDefense(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	(static_cast<GCWManager*>(stub))->removeDefense(building, creature, deedOID);
}

void GCWManagerAdapter::notifyInstallationDestruction(InstallationObject* installation) {
	(static_cast<GCWManager*>(stub))->notifyInstallationDestruction(installation);
}

void GCWManagerAdapter::notifyTurretDestruction(BuildingObject* building, InstallationObject* turret) {
	(static_cast<GCWManager*>(stub))->notifyTurretDestruction(building, turret);
}

void GCWManagerAdapter::notifyMinefieldDestruction(BuildingObject* building, InstallationObject* turret) {
	(static_cast<GCWManager*>(stub))->notifyMinefieldDestruction(building, turret);
}

void GCWManagerAdapter::sendSelectDeedToDonate(BuildingObject* building, CreatureObject* creature) {
	(static_cast<GCWManager*>(stub))->sendSelectDeedToDonate(building, creature);
}

void GCWManagerAdapter::performDefenseDonation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	(static_cast<GCWManager*>(stub))->performDefenseDonation(building, creature, deedOID);
}

void GCWManagerAdapter::sendTurretAttackListTo(CreatureObject* creature, SceneObject* turretControlTerminal) {
	(static_cast<GCWManager*>(stub))->sendTurretAttackListTo(creature, turretControlTerminal);
}

bool GCWManagerAdapter::canUseTurret(TangibleObject* turret, SceneObject* terminal, CreatureObject* creature) {
	return (static_cast<GCWManager*>(stub))->canUseTurret(turret, terminal, creature);
}

float GCWManagerAdapter::getGCWDiscount(CreatureObject* creature) {
	return (static_cast<GCWManager*>(stub))->getGCWDiscount(creature);
}

void GCWManagerAdapter::runCrackdownScan(AiAgent* scanner, CreatureObject* player) {
	(static_cast<GCWManager*>(stub))->runCrackdownScan(scanner, player);
}

int GCWManagerAdapter::isStrongholdCity(String& city) {
	return (static_cast<GCWManager*>(stub))->isStrongholdCity(city);
}

int GCWManagerAdapter::getMaxBasesPerPlayer() {
	return (static_cast<GCWManager*>(stub))->getMaxBasesPerPlayer();
}

bool GCWManagerAdapter::isPlanetCapped() {
	return (static_cast<GCWManager*>(stub))->isPlanetCapped();
}

int GCWManagerAdapter::getImperialBaseCount() {
	return (static_cast<GCWManager*>(stub))->getImperialBaseCount();
}

int GCWManagerAdapter::getRebelBaseCount() {
	return (static_cast<GCWManager*>(stub))->getRebelBaseCount();
}

int GCWManagerAdapter::getTurretAutoFireTimeout() const {
	return (static_cast<GCWManager*>(stub))->getTurretAutoFireTimeout();
}

int GCWManagerAdapter::getDestructionTimer() const {
	return (static_cast<GCWManager*>(stub))->getDestructionTimer();
}

int GCWManagerAdapter::getOvertCooldown() const {
	return (static_cast<GCWManager*>(stub))->getOvertCooldown();
}

int GCWManagerAdapter::getResetTimer() const {
	return (static_cast<GCWManager*>(stub))->getResetTimer();
}

/*
 *	GCWManagerHelper
 */

GCWManagerHelper* GCWManagerHelper::staticInitializer = GCWManagerHelper::instance();

GCWManagerHelper::GCWManagerHelper() {
	className = "GCWManager";

	Core::getObjectBroker()->registerClass(className, this);
}

void GCWManagerHelper::finalizeHelper() {
	GCWManagerHelper::finalize();
}

DistributedObject* GCWManagerHelper::instantiateObject() {
	return new GCWManager(DummyConstructorParameter::instance());
}

DistributedObjectServant* GCWManagerHelper::instantiateServant() {
	return new GCWManagerImplementation(DummyConstructorParameter::instance());
}

DistributedObjectPOD* GCWManagerHelper::instantiatePOD() {
	return new GCWManagerPOD();
}

DistributedObjectAdapter* GCWManagerHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new GCWManagerAdapter(static_cast<GCWManager*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	GCWManagerPOD
 */

GCWManagerPOD::~GCWManagerPOD() {
}

GCWManagerPOD::GCWManagerPOD(void) {
	_className = "GCWManager";
}


void GCWManagerPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = GCWManagerPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int GCWManagerPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ManagedServicePOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (zone) {
	_nameHashCode = 0xbd7d1995; //GCWManager.zone
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<ZonePOD* > >::toBinaryStream(&zone.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool GCWManagerPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ManagedServicePOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xbd7d1995: //GCWManager.zone
		{
			ManagedReference<ZonePOD* > _mnzone;
			TypeInfo<ManagedReference<ZonePOD* > >::parseFromBinaryStream(&_mnzone, stream);
			zone = std::move(_mnzone);
		}
		return true;

	}

	return false;
}

void GCWManagerPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(GCWManagerPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void GCWManagerPOD::writeObjectCompact(ObjectOutputStream* stream) {
	ManagedServicePOD::writeObjectCompact(stream);

	TypeInfo<ManagedReference<ZonePOD* > >::toBinaryStream(&zone.value(), stream);


}

