/*
 *	autogen/server/zone/managers/player/PlayerManager.h generated by engine3 IDL compiler 0.70
 */

#ifndef PLAYERMANAGER_H_
#define PLAYERMANAGER_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace zone {

class ZoneProcessServer;

class ZoneProcessServerPOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace tangible {

class TangibleObject;

class TangibleObjectPOD;

} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible;

namespace server {
namespace zone {

class ZoneServer;

class ZoneServerPOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace wearables {

class ArmorObject;

class ArmorObjectPOD;

} // namespace wearables
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::wearables;

namespace server {
namespace zone {
namespace objects {
namespace player {

class PlayerObject;

class PlayerObjectPOD;

} // namespace player
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::player;

namespace server {
namespace zone {
namespace objects {
namespace structure {

class StructureObject;

class StructureObjectPOD;

} // namespace structure
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::structure;

namespace server {
namespace zone {

class Zone;

class ZonePOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class Creature;

class CreaturePOD;

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace tool {

class CraftingStation;

class CraftingStationPOD;

} // namespace tool
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::tool;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject;

class CreatureObjectPOD;

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObject;

class SceneObjectPOD;

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

namespace server {
namespace login {
namespace account {

class Account;

class AccountPOD;

} // namespace account
} // namespace login
} // namespace server

using namespace server::login::account;

namespace server {
namespace zone {

class CloseObjectsVector;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {

class ZoneClientSession;

class ZoneClientSessionPOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace player {
namespace events {

class OnlinePlayerLogTask;

} // namespace events
} // namespace player
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::player::events;

#include "server/zone/packets/charcreation/ClientCreateCharacterCallback.h"

#include "system/util/SynchronizedVector.h"

#include "server/zone/managers/player/StartingLocationList.h"

#include "server/zone/managers/player/StartingLocation.h"

#include "server/zone/objects/player/ValidatedPosition.h"

#include "server/zone/objects/tangible/threat/ThreatMap.h"

#include "server/zone/managers/player/CharacterNameMap.h"

#include "server/zone/managers/player/PermissionLevelList.h"

#include "server/zone/objects/creature/variables/Skill.h"

#include "server/zone/managers/player/OnlineZoneClientMap.h"

#include "server/zone/managers/collision/IntersectionResults.h"

#include "server/zone/managers/player/VeteranRewardList.h"

#include "server/zone/managers/player/JukeboxSong.h"

#include "server/zone/managers/player/QuestInfo.h"

#include "server/zone/objects/player/badges/Badge.h"

#include "system/util/Vector.h"

#include "system/lang/ref/Reference.h"

#include "server/zone/managers/player/XpBonusList.h"

#include "engine/util/JSONSerializationType.h"

#include "engine/log/Logger.h"

#include "system/util/SortedVector.h"

#include "system/util/VectorMap.h"

#include "engine/core/ManagedObject.h"

#include "engine/util/Observer.h"

#include "engine/util/Observable.h"

#include "system/thread/ReadWriteLock.h"

#include "system/thread/Mutex.h"

#include "system/lang/Time.h"

namespace server {
namespace zone {
namespace managers {
namespace player {

class PlayerManager : public Observer {
public:
	PlayerManager(ZoneServer* zoneServer, ZoneProcessServer* impl, bool trackOnlineUsers);

	void loadNameMap();

	void sendStartingLocationsTo(CreatureObject* player);

	StartingLocation* getStartingLocation(const String& city);

	/**
	 * Kicks a user
	 *
	 */
	bool kickUser(const String& name, const String& admin, String& reason, bool doBan = true);

	bool createPlayer(ClientCreateCharacterCallback* callback);

	bool checkPlayerName(ClientCreateCharacterCallback* callback);

	String setFirstName(CreatureObject* creature, const String& newFirstName);

	String setLastName(CreatureObject* creature, const String& newLastName, bool skipVerify = false);

	int notifyObserverEvent(unsigned int eventType, Observable* observable, ManagedObject* arg1, long long arg2);

	/**
	 * @pre { destructor and destructedObject locked }
	 * @post { destructor and destructedObject locked }
	 */
	int notifyDestruction(TangibleObject* destructor, TangibleObject* destructedObject, int condition, bool isCombatAction);

	bool shouldRescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai);

	void rescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai);

	bool canGroupMemberHarvestCorpse(CreatureObject* player, Creature* creature);

	/**
	 * @pre { attacker and player locked }
	 * @post { attacker and player locked }
	 */
	void killPlayer(TangibleObject* attacker, CreatureObject* player, int typeofdeath = 0, bool isCombatAction = false);

	/**
	 * Calculates the length of time that incapacitation should last. Cannot exceed 1 minute.
	 * \return Returns the number of seconds until the player should recover from incapacitation.
	 */
	byte calculateIncapacitationTimer(CreatureObject* player, int condition);

	/**
	 * Check for enough encumbrances
	 */
	bool checkEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void applyEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void removeEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void awardBadge(PlayerObject* ghost, unsigned int badge);

	void awardBadge(PlayerObject* ghost, const Badge* badge);

	void setExperienceMultiplier(float globalMultiplier);

	int awardExperience(CreatureObject* player, const String& xpType, int amount, bool sendSystemMessage = true, float localMultiplier = 1.0f, bool applyModifiers = true);

	SortedVector<ManagedReference<SceneObject* > > getInsurableItems(CreatureObject* player, bool onlyInsurable = true);

	void addInsurableItemsRecursive(SceneObject* obj, SortedVector<ManagedReference<SceneObject* > >* items, bool onlyInsurable);

	void handleAbortTradeMessage(CreatureObject* player);

	void handleAddItemToTradeWindow(CreatureObject* player, unsigned long long itemID);

	void handleGiveMoneyMessage(CreatureObject* player, unsigned int value);

	void handleAcceptTransactionMessage(CreatureObject* player);

	void handleUnAcceptTransactionMessage(CreatureObject* player);

	void handleVerifyTradeMessage(CreatureObject* player);

	bool checkTradeItems(CreatureObject* player, CreatureObject* receiver);

	/**
	 * Finds the closest structure in range with Administration priveleges.
	 * This is primarily used for commands that require a building or installation.
	 * First checks the passed targetID, then checks if the player is inside a building. Finally searches for an installation in range.
	 * @pre: creature locked, zone unlocked

	 * @post: creature locked, zone unlocked
	 * @param targetID The object id of the players target.
	 */
	SceneObject* getInRangeStructureWithAdminRights(CreatureObject* creature, unsigned long long targetID = 0);

	StructureObject* getInRangeOwnedStructure(CreatureObject* creature, float range = 128);

	void sendBattleFatigueMessage(CreatureObject* player, CreatureObject* target);

	void stopWatch(CreatureObject* creature, unsigned long long entid, bool doSendPackets = true, bool forced = false, bool doLock = true, bool outOfRange = false);

	void stopListen(CreatureObject* creature, unsigned long long entid, bool doSendPackets = true, bool forced = false, bool doLock = true, bool outOfRange = false);

	void startWatch(CreatureObject* creature, unsigned long long entid);

	void startListen(CreatureObject* creature, unsigned long long entid);

	void lootAll(CreatureObject* player, CreatureObject* creature);

	/**
	 * Starts the ProposeUnitySession
	 * @param askingPlayer Player iniating the proposal
	 * @param respondingPlayer Player responding to the proposal
	 * @param askingPlayerRing The ring object selected by the player iniating the propsal
	 * @pre askingPlayer locked
	 * @post askingPlayer locked
	 */
	void proposeUnity(CreatureObject* askingPlayer, CreatureObject* respondingPlayer, SceneObject* askingPlayerRing);

	/**
	 * Responder has denied unity
	 * @param respondingPlayer Player responding to the proposal
	 * @pre respondingPlayer locked
	 * @post respondingPlayer locked
	 */
	void denyUnity(CreatureObject* respondingPlayer);

	/**
	 * Responder has accepted unity;  Prompt for ring
	 * @param respondingPlayer Player responding to the proposal
	 * @pre respondingPlayer locked
	 * @post respondingPlayer locked
	 */
	void acceptUnity(CreatureObject* respondingPlayer);

	/**
	 * Responder has selected a ring; Exchange rings with asker and assign as spouse
	 * @param respondingPlayer Player responding to the proposal
	 * @pre respondingPlayer locked
	 * @post respondingPlayer locked
	 */
	void completeUnity(CreatureObject* respondingPlayer, unsigned long long respondingPlayerRing);

	/**
	 * Prompt player to confirm divorce
	 * @param Player requesting divorce
	 * @pre player locked
	 * @post player locked
	 */
	void promptDivorce(CreatureObject* player);

	/**
	 * Nullify unity
	 * @param Player requesting divorce
	 * @pre player locked
	 * @post player locked
	 */
	void grantDivorce(CreatureObject* player);

	/**
	 * Checks whether the player qualifies for any veteran rewards
	 * and prompts for selection of reward if so
	 * @param Player requesting veteran rewards
	 * @pre player locked
	 * @post player locked
	 */
	void claimVeteranRewards(CreatureObject* player);

	/**
	 * Returns the minimum veteran reward milestone the for which the account is eligible
	 * Returns -1 if not eligible
	 * @param playerGhost player requesting veteran rewards
	 * @param account requesting veteran rewards
	 */
	int getEligibleMilestone(PlayerObject* playerGhost, Account* account);

	/**
	 * Returns the next veteran reward milestone the account will be eligible for
	 * Returns -1 if no further rewards
	 * @param playerGhost player requesting veteran rewards
	 * @param account requesting veteran rewards
	 */
	int getFirstIneligibleMilestone(PlayerObject* playerGhost, Account* account);

	/**
	 * Cancels the current reward session
	 * @param player requesting veteran rewards
	 */
	void cancelVeteranRewardSession(CreatureObject* player);

	/**
	 * Asks the player to confirm selection of the given veteran reward
	 * @param player requesting veteran rewards
	 * @param itemIndex index to item in veteranRewards list
	 */
	void confirmVeteranReward(CreatureObject* player, int itemIndex);

	/**
	 * Generates the selected reward for the player. Starts a new reward session
	 * if player is eligible for additional milestones
	 * @param player requesting veteran rewards
	 * @param itemIndex index to item in veteranRewards list
	 */
	void generateVeteranReward(CreatureObject* player);

	/**
	 * Enhances the patients attribute by a specified amount for a specified duration.
	 * @param patient The patient to enhance.
	 * @param attribute The attribute to enhance.
	 * @param buffvalue The amount to enhance the attribute.
	 * @param duration The duration in seconds the enhancement will last.
	 * @return The amount that was enhanced. If a buff existed, this is the amount exceeding the previous buff.
	 */
	int healEnhance(CreatureObject* enhancer, CreatureObject* patient, byte attribute, int buffvalue, float duration, int absorption = 0);

	void disseminateExperience(TangibleObject* destructedObject, ThreatMap* threatMap, SynchronizedVector<ManagedReference<CreatureObject* > >* lairSpawnedCreatures = NULL, Zone* lairZone = NULL);

	int calculatePlayerLevel(CreatureObject* player);

	int calculatePlayerLevel(CreatureObject* player, String& xpType);

	void sendLoginMessage(CreatureObject* player);

	void resendLoginMessageToAll();

	void sendActivateCloneRequest(CreatureObject* player, int typeofdeath = 0);

	bool isValidClosestCloner(CreatureObject* player, SceneObject* cloner);

	void sendPlayerToCloner(CreatureObject* player, unsigned long long clonerID, int typeofdeath = 0);

	void ejectPlayerFromBuilding(CreatureObject* player);

	bool checkExistentNameInDatabase(const String& firstName);

	void createTutorialBuilding(CreatureObject* player);

	void createSkippedTutorialBuilding(CreatureObject* player);

	void updateSwimmingState(CreatureObject* player, float newZ, IntersectionResults* intersections = NULL, CloseObjectsVector* closeObjects = NULL);

	int checkSpeedHackFirstTest(CreatureObject* player, float parsedSpeed, ValidatedPosition& teleportPosition, float errorMultiplier = 1);

	int checkSpeedHackSecondTest(CreatureObject* player, float newX, float newZ, float newY, unsigned int newStamp, SceneObject* newParent = NULL);

	bool existsName(const String& name);

	bool existsPlayerCreatureOID(unsigned long long oid);

	unsigned long long getObjectID(const String& name);

	String getPlayerName(unsigned long long oid);

	Reference<CreatureObject* > getPlayer(const String& name);

	void updatePermissionLevel(CreatureObject* player, int adminLevel = 1);

	void updatePermissionName(CreatureObject* player, int adminLevel);

	void addPlayer(CreatureObject* player);

	void removePlayer(const String& playerName);

	void removePlayer(unsigned long long playerID);

	bool containsPlayer(const String& playerName);

	void sendAdminJediList(CreatureObject* player);

	void sendAdminFRSList(CreatureObject* player);

	void sendAdminList(CreatureObject* player);

	VectorMap<String, int> generateAdminList();

	CraftingStation* getNearbyCraftingStation(CreatureObject* player, int type);

	void finishHologrind(CreatureObject* player);

	String banAccount(PlayerObject* admin, Account* account, unsigned int seconds, const String& reason);

	String unbanAccount(PlayerObject* admin, Account* account, const String& reason);

	String banFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, unsigned int seconds, const String& reason);

	String unbanFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, const String& reason);

	String banCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, unsigned int seconds, const String& reason);

	String unbanCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, const String& reason);

	void clearOwnedStructuresPermissions(CreatureObject* player);

	bool promptTeachableSkills(CreatureObject* teacher, SceneObject* target);

	void decreaseOnlineCharCount(ZoneClientSession* client);

	bool increaseOnlineCharCountIfPossible(ZoneClientSession* client);

	void disconnectAllPlayers();

	void fixHAM(CreatureObject* player);

	void fixBuffSkillMods(CreatureObject* player);

	JSONSerializationType basePlayerLogEntry(CreatureObject* creature, PlayerObject* ghost);

	void writePlayerLogEntry(JSONSerializationType& logEntry);

	void writePlayerLog(CreatureObject* creature, PlayerObject* ghost, const String& msg, int logLevelType);

	void writePlayerLog(PlayerObject* ghost, const String& msg, int logLevelType);

	void writePlayerLog(CreatureObject* creature, const String& msg, int logLevelType);

	int getPlayerQuestID(const String& name);

	String getPlayerQuestParent(int questID);

	int getTotalPlayerQuests();

	QuestInfo* getQuestInfo(int questID);

	/**
	 * Sends a confirmation box to the student asking if they want to learn the skill.
	 * @pre student crosslocked with teacher
	 * @post student crosslocked with teacher
	 */
	bool offerTeaching(CreatureObject* teacher, CreatureObject* student, Skill* skill);

	/**
	 * Accepts a teaching office.
	 * @pre student crosslocked with teacher
	 * @post student crosslocked with teacher
	 */
	bool acceptTeachingOffer(CreatureObject* teacher, CreatureObject* student, Skill* skill);

	/**
	 * Gets a vector skillboxes this teacher can teach this student.
	 * @pre student crosslocked with teacher
	 * @post student crosslocked with teacher
	 */
	SortedVector<String> getTeachableSkills(CreatureObject* teacher, CreatureObject* student);

	OnlineZoneClientMap* getOnlineZoneClientMap();

	void getCleanupCharacterCount();

	void cleanupCharacters();

	bool shouldDeleteCharacter(unsigned long long characterID, int galaxyID);

	bool doBurstRun(CreatureObject* player, float hamModifier, float cooldownModifier);

	/**
	 * Enhances the target character with doc/ent buffs
	 * @pre { player is locked }
	 * @post { player is locked }
	 */
	void enhanceCharacter(CreatureObject* player);

	/**
	 * Creates and adds buff to Player
	 * @pre { player is locked }
	 * @post { player is locked }
	 * @returns true if it was added
	 * @param crc CRC of the buff, player target of buff, amount is the attribute modifier for the buff, duration of the buff, buffType specifies whether medical or performance and attribute sets the creature attribute to modify
	 */
	bool doEnhanceCharacter(unsigned int crc, CreatureObject* player, int amount, int duration, int buffType, byte attribute);

	int getBaseStoredCreaturePets();

	int getBaseStoredFactionPets();

	int getBaseStoredDroids();

	int getBaseStoredVehicles();

	int getBaseStoredShips();

	int getNumVeteranRewardMilestones();

	int getVeteranRewardMilestone(int index);

	JukeboxSong* getJukeboxSong(int index);

	int getNumJukeboxSongs();

	void setOnlineCharactersPerAccount(int count);

	void doPvpDeathRatingUpdate(CreatureObject* player, ThreatMap* threatMap);

	void updatePvPKillCount(CreatureObject* player);

	float getSpeciesXpModifier(const String& species, const String& xpType);

	void unlockFRSForTesting(CreatureObject* player, int councilType);

	Vector<unsigned long long> getOnlinePlayerList();

	void logOnlinePlayers(bool onlyWho);

	bool rescheduleOnlinePlayerLogTask(int logSeconds);

	void updateOnlinePlayers();

	void stopOnlinePlayerLogTask();

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	PlayerManager(DummyConstructorParameter* param);

	virtual ~PlayerManager();

	friend class PlayerManagerHelper;
};

} // namespace player
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::player;

namespace server {
namespace zone {
namespace managers {
namespace player {

class PlayerManagerImplementation : public ObserverImplementation, public Logger {
	ManagedReference<ZoneProcessServer* > processor;

	Logger playerLogger;

	String playerLoggerFilename;

protected:
	Mutex playerLoggerMutex;

	int playerLoggerLines = 0;

	Mutex onlinePlayerLogMutext;

	WeakReference<OnlinePlayerLogTask* > onlinePlayerLogTask;

	int onlinePlayerLogSum;

	bool onlinePlayersLogOnSessionChange;

	Time lastOnlinePlayerLogMsg;

	int performanceBuff;

	int medicalBuff;

	int performanceDuration;

	int medicalDuration;

	int baseStoredCreaturePets;

	int baseStoredFactionPets;

	int baseStoredDroids;

	int baseStoredVehicles;

	int baseStoredShips;

	bool allowSameAccountPvpRatingCredit;

	int onlineCharactersPerAccount;

	XpBonusList xpBonusList;

private:
	SortedVector<int> veteranRewardMilestones;

	int veteranRewardAdditionalMilestones;

	VeteranRewardList veteranRewards;

	ManagedReference<ZoneServer* > server;

	Reference<CharacterNameMap* > nameMap;

	float globalExpMultiplier;

	float groupExpMultiplier;

	ReadWriteLock onlineMapMutex;

protected:
	Vector<Reference<JukeboxSong*> > jukeboxSongs;

	Vector<Reference<QuestInfo*> > questInfo;

private:
	OnlineZoneClientMap onlineZoneClientMap;

	Reference<PermissionLevelList* > permissionLevelList;

	StartingLocationList startingLocationList;

public:
	PlayerManagerImplementation(ZoneServer* zoneServer, ZoneProcessServer* impl, bool trackOnlineUsers);

	PlayerManagerImplementation(DummyConstructorParameter* param);

	void loadNameMap();

private:
	void loadLuaConfig();

	void loadStartingLocations();

	void loadPermissionLevels();

	void loadQuestInfo();

public:
	void finalize();

	void sendStartingLocationsTo(CreatureObject* player);

	StartingLocation* getStartingLocation(const String& city);

	/**
	 * Kicks a user
	 *
	 */
	bool kickUser(const String& name, const String& admin, String& reason, bool doBan = true);

	bool createPlayer(ClientCreateCharacterCallback* callback);

	bool checkPlayerName(ClientCreateCharacterCallback* callback);

	String setFirstName(CreatureObject* creature, const String& newFirstName);

	String setLastName(CreatureObject* creature, const String& newLastName, bool skipVerify = false);

	int notifyObserverEvent(unsigned int eventType, Observable* observable, ManagedObject* arg1, long long arg2);

	/**
	 * @pre { destructor and destructedObject locked }
	 * @post { destructor and destructedObject locked }
	 */
	int notifyDestruction(TangibleObject* destructor, TangibleObject* destructedObject, int condition, bool isCombatAction);

	bool shouldRescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai);

	void rescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai);

	bool canGroupMemberHarvestCorpse(CreatureObject* player, Creature* creature);

	/**
	 * @pre { attacker and player locked }
	 * @post { attacker and player locked }
	 */
	void killPlayer(TangibleObject* attacker, CreatureObject* player, int typeofdeath = 0, bool isCombatAction = false);

	/**
	 * Calculates the length of time that incapacitation should last. Cannot exceed 1 minute.
	 * \return Returns the number of seconds until the player should recover from incapacitation.
	 */
	byte calculateIncapacitationTimer(CreatureObject* player, int condition);

	/**
	 * Check for enough encumbrances
	 */
	bool checkEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void applyEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void removeEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void awardBadge(PlayerObject* ghost, unsigned int badge);

	void awardBadge(PlayerObject* ghost, const Badge* badge);

	void setExperienceMultiplier(float globalMultiplier);

	int awardExperience(CreatureObject* player, const String& xpType, int amount, bool sendSystemMessage = true, float localMultiplier = 1.0f, bool applyModifiers = true);

	SortedVector<ManagedReference<SceneObject* > > getInsurableItems(CreatureObject* player, bool onlyInsurable = true);

	void addInsurableItemsRecursive(SceneObject* obj, SortedVector<ManagedReference<SceneObject* > >* items, bool onlyInsurable);

	void handleAbortTradeMessage(CreatureObject* player);

	void handleAddItemToTradeWindow(CreatureObject* player, unsigned long long itemID);

	void handleGiveMoneyMessage(CreatureObject* player, unsigned int value);

	void handleAcceptTransactionMessage(CreatureObject* player);

	void handleUnAcceptTransactionMessage(CreatureObject* player);

	void handleVerifyTradeMessage(CreatureObject* player);

	bool checkTradeItems(CreatureObject* player, CreatureObject* receiver);

	/**
	 * Finds the closest structure in range with Administration priveleges.
	 * This is primarily used for commands that require a building or installation.
	 * First checks the passed targetID, then checks if the player is inside a building. Finally searches for an installation in range.
	 * @pre: creature locked, zone unlocked

	 * @post: creature locked, zone unlocked
	 * @param targetID The object id of the players target.
	 */
	SceneObject* getInRangeStructureWithAdminRights(CreatureObject* creature, unsigned long long targetID = 0);

	StructureObject* getInRangeOwnedStructure(CreatureObject* creature, float range = 128);

	void sendBattleFatigueMessage(CreatureObject* player, CreatureObject* target);

	void stopWatch(CreatureObject* creature, unsigned long long entid, bool doSendPackets = true, bool forced = false, bool doLock = true, bool outOfRange = false);

	void stopListen(CreatureObject* creature, unsigned long long entid, bool doSendPackets = true, bool forced = false, bool doLock = true, bool outOfRange = false);

	void startWatch(CreatureObject* creature, unsigned long long entid);

	void startListen(CreatureObject* creature, unsigned long long entid);

	void lootAll(CreatureObject* player, CreatureObject* creature);

	/**
	 * Starts the ProposeUnitySession
	 * @param askingPlayer Player iniating the proposal
	 * @param respondingPlayer Player responding to the proposal
	 * @param askingPlayerRing The ring object selected by the player iniating the propsal
	 * @pre askingPlayer locked
	 * @post askingPlayer locked
	 */
	void proposeUnity(CreatureObject* askingPlayer, CreatureObject* respondingPlayer, SceneObject* askingPlayerRing);

	/**
	 * Responder has denied unity
	 * @param respondingPlayer Player responding to the proposal
	 * @pre respondingPlayer locked
	 * @post respondingPlayer locked
	 */
	void denyUnity(CreatureObject* respondingPlayer);

	/**
	 * Responder has accepted unity;  Prompt for ring
	 * @param respondingPlayer Player responding to the proposal
	 * @pre respondingPlayer locked
	 * @post respondingPlayer locked
	 */
	void acceptUnity(CreatureObject* respondingPlayer);

	/**
	 * Responder has selected a ring; Exchange rings with asker and assign as spouse
	 * @param respondingPlayer Player responding to the proposal
	 * @pre respondingPlayer locked
	 * @post respondingPlayer locked
	 */
	void completeUnity(CreatureObject* respondingPlayer, unsigned long long respondingPlayerRing);

protected:
	/**
	 * Cancel the propose unity session
	 * @param respondingPlayer Player responding to the proposal
	 * @param askingPlayer Player iniating the proposal
	 * @pre respondingPlayer and askingPlayer locked
	 * @post respondingPlayer and askingPlayerlocked
	 */
	void cancelProposeUnitySession(CreatureObject* respondingPlayer, CreatureObject* askingPlayer);

public:
	/**
	 * Prompt player to confirm divorce
	 * @param Player requesting divorce
	 * @pre player locked
	 * @post player locked
	 */
	void promptDivorce(CreatureObject* player);

	/**
	 * Nullify unity
	 * @param Player requesting divorce
	 * @pre player locked
	 * @post player locked
	 */
	void grantDivorce(CreatureObject* player);

	/**
	 * Checks whether the player qualifies for any veteran rewards
	 * and prompts for selection of reward if so
	 * @param Player requesting veteran rewards
	 * @pre player locked
	 * @post player locked
	 */
	void claimVeteranRewards(CreatureObject* player);

	/**
	 * Returns the minimum veteran reward milestone the for which the account is eligible
	 * Returns -1 if not eligible
	 * @param playerGhost player requesting veteran rewards
	 * @param account requesting veteran rewards
	 */
	int getEligibleMilestone(PlayerObject* playerGhost, Account* account);

	/**
	 * Returns the next veteran reward milestone the account will be eligible for
	 * Returns -1 if no further rewards
	 * @param playerGhost player requesting veteran rewards
	 * @param account requesting veteran rewards
	 */
	int getFirstIneligibleMilestone(PlayerObject* playerGhost, Account* account);

	/**
	 * Cancels the current reward session
	 * @param player requesting veteran rewards
	 */
	void cancelVeteranRewardSession(CreatureObject* player);

	/**
	 * Asks the player to confirm selection of the given veteran reward
	 * @param player requesting veteran rewards
	 * @param itemIndex index to item in veteranRewards list
	 */
	void confirmVeteranReward(CreatureObject* player, int itemIndex);

	/**
	 * Generates the selected reward for the player. Starts a new reward session
	 * if player is eligible for additional milestones
	 * @param player requesting veteran rewards
	 * @param itemIndex index to item in veteranRewards list
	 */
	void generateVeteranReward(CreatureObject* player);

	/**
	 * Enhances the patients attribute by a specified amount for a specified duration.
	 * @param patient The patient to enhance.
	 * @param attribute The attribute to enhance.
	 * @param buffvalue The amount to enhance the attribute.
	 * @param duration The duration in seconds the enhancement will last.
	 * @return The amount that was enhanced. If a buff existed, this is the amount exceeding the previous buff.
	 */
	int healEnhance(CreatureObject* enhancer, CreatureObject* patient, byte attribute, int buffvalue, float duration, int absorption = 0);

	void disseminateExperience(TangibleObject* destructedObject, ThreatMap* threatMap, SynchronizedVector<ManagedReference<CreatureObject* > >* lairSpawnedCreatures = NULL, Zone* lairZone = NULL);

	int calculatePlayerLevel(CreatureObject* player);

	int calculatePlayerLevel(CreatureObject* player, String& xpType);

	void sendLoginMessage(CreatureObject* player);

	void resendLoginMessageToAll();

	void sendActivateCloneRequest(CreatureObject* player, int typeofdeath = 0);

	bool isValidClosestCloner(CreatureObject* player, SceneObject* cloner);

	void sendPlayerToCloner(CreatureObject* player, unsigned long long clonerID, int typeofdeath = 0);

	void ejectPlayerFromBuilding(CreatureObject* player);

	bool checkExistentNameInDatabase(const String& firstName);

	void createTutorialBuilding(CreatureObject* player);

	void createSkippedTutorialBuilding(CreatureObject* player);

	void updateSwimmingState(CreatureObject* player, float newZ, IntersectionResults* intersections = NULL, CloseObjectsVector* closeObjects = NULL);

	int checkSpeedHackFirstTest(CreatureObject* player, float parsedSpeed, ValidatedPosition& teleportPosition, float errorMultiplier = 1);

	int checkSpeedHackSecondTest(CreatureObject* player, float newX, float newZ, float newY, unsigned int newStamp, SceneObject* newParent = NULL);

	bool existsName(const String& name);

	bool existsPlayerCreatureOID(unsigned long long oid);

	unsigned long long getObjectID(const String& name);

	String getPlayerName(unsigned long long oid);

	Reference<CreatureObject* > getPlayer(const String& name);

	void updatePermissionLevel(CreatureObject* player, int adminLevel = 1);

	void updatePermissionName(CreatureObject* player, int adminLevel);

	void addPlayer(CreatureObject* player);

	void removePlayer(const String& playerName);

	void removePlayer(unsigned long long playerID);

	bool containsPlayer(const String& playerName);

	void sendAdminJediList(CreatureObject* player);

	void sendAdminFRSList(CreatureObject* player);

	void sendAdminList(CreatureObject* player);

	VectorMap<String, int> generateAdminList();

	CraftingStation* getNearbyCraftingStation(CreatureObject* player, int type);

	void finishHologrind(CreatureObject* player);

	String banAccount(PlayerObject* admin, Account* account, unsigned int seconds, const String& reason);

	String unbanAccount(PlayerObject* admin, Account* account, const String& reason);

	String banFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, unsigned int seconds, const String& reason);

	String unbanFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, const String& reason);

	String banCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, unsigned int seconds, const String& reason);

	String unbanCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, const String& reason);

	void clearOwnedStructuresPermissions(CreatureObject* player);

	bool promptTeachableSkills(CreatureObject* teacher, SceneObject* target);

	void decreaseOnlineCharCount(ZoneClientSession* client);

	bool increaseOnlineCharCountIfPossible(ZoneClientSession* client);

	void disconnectAllPlayers();

	void fixHAM(CreatureObject* player);

	void fixBuffSkillMods(CreatureObject* player);

	JSONSerializationType basePlayerLogEntry(CreatureObject* creature, PlayerObject* ghost);

	void writePlayerLogEntry(JSONSerializationType& logEntry);

	void writePlayerLog(CreatureObject* creature, PlayerObject* ghost, const String& msg, int logLevelType);

	void writePlayerLog(PlayerObject* ghost, const String& msg, int logLevelType);

	void writePlayerLog(CreatureObject* creature, const String& msg, int logLevelType);

	int getPlayerQuestID(const String& name);

	String getPlayerQuestParent(int questID);

	int getTotalPlayerQuests();

	QuestInfo* getQuestInfo(int questID);

	/**
	 * Sends a confirmation box to the student asking if they want to learn the skill.
	 * @pre student crosslocked with teacher
	 * @post student crosslocked with teacher
	 */
	bool offerTeaching(CreatureObject* teacher, CreatureObject* student, Skill* skill);

	/**
	 * Accepts a teaching office.
	 * @pre student crosslocked with teacher
	 * @post student crosslocked with teacher
	 */
	bool acceptTeachingOffer(CreatureObject* teacher, CreatureObject* student, Skill* skill);

	/**
	 * Gets a vector skillboxes this teacher can teach this student.
	 * @pre student crosslocked with teacher
	 * @post student crosslocked with teacher
	 */
	SortedVector<String> getTeachableSkills(CreatureObject* teacher, CreatureObject* student);

	OnlineZoneClientMap* getOnlineZoneClientMap();

	void getCleanupCharacterCount();

	void cleanupCharacters();

	bool shouldDeleteCharacter(unsigned long long characterID, int galaxyID);

	bool doBurstRun(CreatureObject* player, float hamModifier, float cooldownModifier);

	/**
	 * Enhances the target character with doc/ent buffs
	 * @pre { player is locked }
	 * @post { player is locked }
	 */
	void enhanceCharacter(CreatureObject* player);

	/**
	 * Creates and adds buff to Player
	 * @pre { player is locked }
	 * @post { player is locked }
	 * @returns true if it was added
	 * @param crc CRC of the buff, player target of buff, amount is the attribute modifier for the buff, duration of the buff, buffType specifies whether medical or performance and attribute sets the creature attribute to modify
	 */
	bool doEnhanceCharacter(unsigned int crc, CreatureObject* player, int amount, int duration, int buffType, byte attribute);

	int getBaseStoredCreaturePets();

	int getBaseStoredFactionPets();

	int getBaseStoredDroids();

	int getBaseStoredVehicles();

	int getBaseStoredShips();

	int getNumVeteranRewardMilestones();

	int getVeteranRewardMilestone(int index);

	JukeboxSong* getJukeboxSong(int index);

	int getNumJukeboxSongs();

	void setOnlineCharactersPerAccount(int count);

	void doPvpDeathRatingUpdate(CreatureObject* player, ThreatMap* threatMap);

	void updatePvPKillCount(CreatureObject* player);

private:
	void loadXpBonusList();

public:
	float getSpeciesXpModifier(const String& species, const String& xpType);

	void unlockFRSForTesting(CreatureObject* player, int councilType);

	Vector<unsigned long long> getOnlinePlayerList();

	void logOnlinePlayers(bool onlyWho);

	bool rescheduleOnlinePlayerLogTask(int logSeconds);

	void updateOnlinePlayers();

	void stopOnlinePlayerLogTask();

	WeakReference<PlayerManager*> _this;

	operator const PlayerManager*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
protected:
	virtual ~PlayerManagerImplementation();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class PlayerManager;
};

class PlayerManagerAdapter : public ObserverAdapter {
public:
	PlayerManagerAdapter(PlayerManager* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void loadNameMap();

	void finalize();

	bool kickUser(const String& name, const String& admin, String& reason, bool doBan);

	String setFirstName(CreatureObject* creature, const String& newFirstName);

	String setLastName(CreatureObject* creature, const String& newLastName, bool skipVerify);

	int notifyObserverEvent(unsigned int eventType, Observable* observable, ManagedObject* arg1, long long arg2);

	int notifyDestruction(TangibleObject* destructor, TangibleObject* destructedObject, int condition, bool isCombatAction);

	bool shouldRescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai);

	void rescheduleCorpseDestruction(CreatureObject* player, CreatureObject* ai);

	bool canGroupMemberHarvestCorpse(CreatureObject* player, Creature* creature);

	void killPlayer(TangibleObject* attacker, CreatureObject* player, int typeofdeath, bool isCombatAction);

	byte calculateIncapacitationTimer(CreatureObject* player, int condition);

	bool checkEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void applyEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void removeEncumbrancies(CreatureObject* player, ArmorObject* armor);

	void awardBadge(PlayerObject* ghost, unsigned int badge);

	void setExperienceMultiplier(float globalMultiplier);

	int awardExperience(CreatureObject* player, const String& xpType, int amount, bool sendSystemMessage, float localMultiplier, bool applyModifiers);

	void handleAbortTradeMessage(CreatureObject* player);

	void handleAddItemToTradeWindow(CreatureObject* player, unsigned long long itemID);

	void handleGiveMoneyMessage(CreatureObject* player, unsigned int value);

	void handleAcceptTransactionMessage(CreatureObject* player);

	void handleUnAcceptTransactionMessage(CreatureObject* player);

	void handleVerifyTradeMessage(CreatureObject* player);

	bool checkTradeItems(CreatureObject* player, CreatureObject* receiver);

	SceneObject* getInRangeStructureWithAdminRights(CreatureObject* creature, unsigned long long targetID);

	StructureObject* getInRangeOwnedStructure(CreatureObject* creature, float range);

	void sendBattleFatigueMessage(CreatureObject* player, CreatureObject* target);

	void stopWatch(CreatureObject* creature, unsigned long long entid, bool doSendPackets, bool forced, bool doLock, bool outOfRange);

	void stopListen(CreatureObject* creature, unsigned long long entid, bool doSendPackets, bool forced, bool doLock, bool outOfRange);

	void startWatch(CreatureObject* creature, unsigned long long entid);

	void startListen(CreatureObject* creature, unsigned long long entid);

	void lootAll(CreatureObject* player, CreatureObject* creature);

	void proposeUnity(CreatureObject* askingPlayer, CreatureObject* respondingPlayer, SceneObject* askingPlayerRing);

	void denyUnity(CreatureObject* respondingPlayer);

	void acceptUnity(CreatureObject* respondingPlayer);

	void completeUnity(CreatureObject* respondingPlayer, unsigned long long respondingPlayerRing);

	void promptDivorce(CreatureObject* player);

	void grantDivorce(CreatureObject* player);

	void claimVeteranRewards(CreatureObject* player);

	int getEligibleMilestone(PlayerObject* playerGhost, Account* account);

	int getFirstIneligibleMilestone(PlayerObject* playerGhost, Account* account);

	void cancelVeteranRewardSession(CreatureObject* player);

	void confirmVeteranReward(CreatureObject* player, int itemIndex);

	void generateVeteranReward(CreatureObject* player);

	int healEnhance(CreatureObject* enhancer, CreatureObject* patient, byte attribute, int buffvalue, float duration, int absorption);

	int calculatePlayerLevel(CreatureObject* player);

	int calculatePlayerLevel(CreatureObject* player, String& xpType);

	void sendLoginMessage(CreatureObject* player);

	void resendLoginMessageToAll();

	void sendActivateCloneRequest(CreatureObject* player, int typeofdeath);

	bool isValidClosestCloner(CreatureObject* player, SceneObject* cloner);

	void sendPlayerToCloner(CreatureObject* player, unsigned long long clonerID, int typeofdeath);

	void ejectPlayerFromBuilding(CreatureObject* player);

	bool checkExistentNameInDatabase(const String& firstName);

	void createTutorialBuilding(CreatureObject* player);

	void createSkippedTutorialBuilding(CreatureObject* player);

	int checkSpeedHackSecondTest(CreatureObject* player, float newX, float newZ, float newY, unsigned int newStamp, SceneObject* newParent);

	bool existsName(const String& name);

	bool existsPlayerCreatureOID(unsigned long long oid);

	unsigned long long getObjectID(const String& name);

	String getPlayerName(unsigned long long oid);

	Reference<CreatureObject* > getPlayer(const String& name);

	void updatePermissionLevel(CreatureObject* player, int adminLevel);

	void updatePermissionName(CreatureObject* player, int adminLevel);

	void addPlayer(CreatureObject* player);

	void removePlayer(const String& playerName);

	void removePlayer(unsigned long long playerID);

	bool containsPlayer(const String& playerName);

	void sendAdminJediList(CreatureObject* player);

	void sendAdminFRSList(CreatureObject* player);

	void sendAdminList(CreatureObject* player);

	CraftingStation* getNearbyCraftingStation(CreatureObject* player, int type);

	void finishHologrind(CreatureObject* player);

	String banAccount(PlayerObject* admin, Account* account, unsigned int seconds, const String& reason);

	String unbanAccount(PlayerObject* admin, Account* account, const String& reason);

	String banFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, unsigned int seconds, const String& reason);

	String unbanFromGalaxy(PlayerObject* admin, Account* account, unsigned const int galaxy, const String& reason);

	String banCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, unsigned int seconds, const String& reason);

	String unbanCharacter(PlayerObject* admin, Account* account, const String& name, unsigned int galaxyID, const String& reason);

	void clearOwnedStructuresPermissions(CreatureObject* player);

	bool promptTeachableSkills(CreatureObject* teacher, SceneObject* target);

	void decreaseOnlineCharCount(ZoneClientSession* client);

	bool increaseOnlineCharCountIfPossible(ZoneClientSession* client);

	void disconnectAllPlayers();

	void fixHAM(CreatureObject* player);

	void fixBuffSkillMods(CreatureObject* player);

	int getPlayerQuestID(const String& name);

	String getPlayerQuestParent(int questID);

	int getTotalPlayerQuests();

	void getCleanupCharacterCount();

	void cleanupCharacters();

	bool shouldDeleteCharacter(unsigned long long characterID, int galaxyID);

	bool doBurstRun(CreatureObject* player, float hamModifier, float cooldownModifier);

	void enhanceCharacter(CreatureObject* player);

	bool doEnhanceCharacter(unsigned int crc, CreatureObject* player, int amount, int duration, int buffType, byte attribute);

	int getBaseStoredCreaturePets();

	int getBaseStoredFactionPets();

	int getBaseStoredDroids();

	int getBaseStoredVehicles();

	int getBaseStoredShips();

	int getNumVeteranRewardMilestones();

	int getVeteranRewardMilestone(int index);

	int getNumJukeboxSongs();

	void setOnlineCharactersPerAccount(int count);

	void updatePvPKillCount(CreatureObject* player);

	float getSpeciesXpModifier(const String& species, const String& xpType);

	void unlockFRSForTesting(CreatureObject* player, int councilType);

	void updateOnlinePlayers();

	void stopOnlinePlayerLogTask();

};

class PlayerManagerHelper : public DistributedObjectClassHelper, public Singleton<PlayerManagerHelper> {
	static PlayerManagerHelper* staticInitializer;

public:
	PlayerManagerHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<PlayerManagerHelper>;
};

} // namespace player
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::player;

namespace server {
namespace zone {
namespace managers {
namespace player {

class PlayerManagerPOD : public ObserverPOD {
public:
	Optional<int> performanceBuff;

	Optional<int> medicalBuff;

	Optional<int> performanceDuration;

	Optional<int> medicalDuration;

	Optional<int> baseStoredCreaturePets;

	Optional<int> baseStoredFactionPets;

	Optional<int> baseStoredDroids;

	Optional<int> baseStoredVehicles;

	Optional<int> baseStoredShips;

	Optional<bool> allowSameAccountPvpRatingCredit;

	Optional<int> onlineCharactersPerAccount;

	Optional<XpBonusList> xpBonusList;

	Optional<SortedVector<int>> veteranRewardMilestones;

	Optional<int> veteranRewardAdditionalMilestones;

	Optional<VeteranRewardList> veteranRewards;

	Optional<ManagedReference<ZoneServerPOD* >> server;

	Optional<float> globalExpMultiplier;

	Optional<float> groupExpMultiplier;

	String _className;
	PlayerManagerPOD();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~PlayerManagerPOD();

};

} // namespace player
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::player;

#endif /*PLAYERMANAGERPOD_H_*/
