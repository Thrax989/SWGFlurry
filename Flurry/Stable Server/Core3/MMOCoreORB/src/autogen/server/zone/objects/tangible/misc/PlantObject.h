/*
 *	autogen/server/zone/objects/tangible/misc/PlantObject.h generated by engine3 IDL compiler 0.70
 */

#ifndef PLANTOBJECT_H_
#define PLANTOBJECT_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace zone {
namespace packets {
namespace object {

class ObjectMenuResponse;

} // namespace object
} // namespace packets
} // namespace zone
} // namespace server

using namespace server::zone::packets::object;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject;

class CreatureObjectPOD;

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace packets {
namespace scene {

class AttributeListMessage;

} // namespace scene
} // namespace packets
} // namespace zone
} // namespace server

using namespace server::zone::packets::scene;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace tasks {

class GrowablePlantPulseTask;

} // namespace tasks
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::tasks;

#include "system/lang/ref/Reference.h"

#include "system/lang/Time.h"

#include "server/zone/objects/tangible/TangibleObject.h"

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace misc {

class PlantObject : public TangibleObject {
public:
	static const int PULSERATE = 21600;

	PlantObject();

	void initializeTransientMembers();

	/**
	 * Fills the attribute list message options that are sent to player creature
	 * @pre { }
	 * @post { }
	 * @param msg attribute list message with the attributes
	 * @param object player creature to which the message is sent
	 */
	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player);

	void initializePlant(int size = 1);

	void sendResourceSUI(CreatureObject* player, int type = 1);

	int getCriticalAttribute(int index);

	void changeSize(int size);

	void updateLastPulse();

	int getWaterLevel() const;

	int getIdealWaterLevel() const;

	int getIdealNutrientLevel() const;

	int getNutrientLevel() const;

	int getNutrientQuality() const;

	int getWaterQuality() const;

	int getPlantHealth() const;

	int getGrowth() const;

	int getSize() const;

	int getFruit() const;

	int getCriticalAttributeOne() const;

	int getCriticalAttributeTwo() const;

	void setNutrientLevel(int level);

	void setNutrientQuality(int qual);

	void setWaterLevel(int level);

	void setWaterQuality(int qual);

	void setPlantHealth(int hp);

	void setFruit(int count);

	bool isPlantObject();

	Time* getLastPulse();

	void setGrowthRate(int rate);

	void setGrowth(int gr);

	void startPulse();

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	PlantObject(DummyConstructorParameter* param);

	virtual ~PlantObject();

	friend class PlantObjectHelper;
};

} // namespace misc
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::misc;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace misc {

class PlantObjectImplementation : public TangibleObjectImplementation {
public:
	static const int PULSERATE = 21600;

protected:
	int waterLevel;

	int nutrientLevel;

	int idealWaterLevel;

	int idealNutrientLevel;

	int waterQuality;

	int nutrientQuality;

	int health;

	int fruitCount;

	int growth;

	int growthRate;

	int plantSize;

	int criticalAttribOne;

	int criticalAttribTwo;

	Time lastPulse;

	Reference<GrowablePlantPulseTask*> pulseTask;

public:
	PlantObjectImplementation();

	PlantObjectImplementation(DummyConstructorParameter* param);

	void initializeTransientMembers();

	/**
	 * Fills the attribute list message options that are sent to player creature
	 * @pre { }
	 * @post { }
	 * @param msg attribute list message with the attributes
	 * @param object player creature to which the message is sent
	 */
	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player);

	void initializePlant(int size = 1);

	void sendResourceSUI(CreatureObject* player, int type = 1);

	int getCriticalAttribute(int index);

	void changeSize(int size);

	void updateLastPulse();

	int getWaterLevel() const;

	int getIdealWaterLevel() const;

	int getIdealNutrientLevel() const;

	int getNutrientLevel() const;

	int getNutrientQuality() const;

	int getWaterQuality() const;

	int getPlantHealth() const;

	int getGrowth() const;

	int getSize() const;

	int getFruit() const;

	int getCriticalAttributeOne() const;

	int getCriticalAttributeTwo() const;

	void setNutrientLevel(int level);

	void setNutrientQuality(int qual);

	void setWaterLevel(int level);

	void setWaterQuality(int qual);

	void setPlantHealth(int hp);

	void setFruit(int count);

	bool isPlantObject();

	Time* getLastPulse();

	void setGrowthRate(int rate);

	void setGrowth(int gr);

	void startPulse();

	WeakReference<PlantObject*> _this;

	operator const PlantObject*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	virtual void writeJSON(nlohmann::json& j);
protected:
	virtual ~PlantObjectImplementation();

	void finalize();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class PlantObject;
};

class PlantObjectAdapter : public TangibleObjectAdapter {
public:
	PlantObjectAdapter(PlantObject* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void initializeTransientMembers();

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void initializePlant(int size);

	void sendResourceSUI(CreatureObject* player, int type);

	int getCriticalAttribute(int index);

	void changeSize(int size);

	void updateLastPulse();

	int getWaterLevel() const;

	int getIdealWaterLevel() const;

	int getIdealNutrientLevel() const;

	int getNutrientLevel() const;

	int getNutrientQuality() const;

	int getWaterQuality() const;

	int getPlantHealth() const;

	int getGrowth() const;

	int getSize() const;

	int getFruit() const;

	int getCriticalAttributeOne() const;

	int getCriticalAttributeTwo() const;

	void setNutrientLevel(int level);

	void setNutrientQuality(int qual);

	void setWaterLevel(int level);

	void setWaterQuality(int qual);

	void setPlantHealth(int hp);

	void setFruit(int count);

	bool isPlantObject();

	void setGrowthRate(int rate);

	void setGrowth(int gr);

	void startPulse();

};

class PlantObjectHelper : public DistributedObjectClassHelper, public Singleton<PlantObjectHelper> {
	static PlantObjectHelper* staticInitializer;

public:
	PlantObjectHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<PlantObjectHelper>;
};

} // namespace misc
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::misc;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace misc {

class PlantObjectPOD : public TangibleObjectPOD {
public:
	Optional<int> waterLevel;

	Optional<int> nutrientLevel;

	Optional<int> idealWaterLevel;

	Optional<int> idealNutrientLevel;

	Optional<int> waterQuality;

	Optional<int> nutrientQuality;

	Optional<int> health;

	Optional<int> fruitCount;

	Optional<int> growth;

	Optional<int> growthRate;

	Optional<int> plantSize;

	Optional<int> criticalAttribOne;

	Optional<int> criticalAttribTwo;

	Optional<Time> lastPulse;

	String _className;
	PlantObjectPOD();
	virtual void writeJSON(nlohmann::json& j);
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~PlantObjectPOD();

};

} // namespace misc
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::misc;

#endif /*PLANTOBJECTPOD_H_*/
