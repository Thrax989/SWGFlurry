/*
 *	autogen/server/zone/objects/creature/CreatureObject.h generated by engine3 IDL compiler 0.70
 */

#ifndef CREATUREOBJECT_H_
#define CREATUREOBJECT_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace chat {

class StringIdChatParameter;

} // namespace chat
} // namespace server

using namespace server::chat;

namespace server {
namespace zone {
namespace objects {
namespace group {

class GroupObject;

class GroupObjectPOD;

} // namespace group
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::group;

namespace server {
namespace zone {
namespace objects {
namespace guild {

class GuildObject;

class GuildObjectPOD;

} // namespace guild
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::guild;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace weapon {

class WeaponObject;

class WeaponObjectPOD;

} // namespace weapon
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::weapon;

namespace server {
namespace zone {
namespace objects {
namespace player {

class PlayerObject;

class PlayerObjectPOD;

} // namespace player
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::player;

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObject;

class SceneObjectPOD;

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

namespace server {
namespace zone {
namespace objects {
namespace area {

class CampSiteActiveArea;

class CampSiteActiveAreaPOD;

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace events {

class DizzyFallDownEvent;

} // namespace events
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::events;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace buffs {

class Buff;

class BuffPOD;

} // namespace buffs
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::buffs;

namespace server {
namespace zone {

class ZoneClientSession;

class ZoneClientSessionPOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace credits {

class CreditObject;

class CreditObjectPOD;

} // namespace credits
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::credits;

namespace server {
namespace zone {
namespace managers {
namespace auction {

class AuctionSearchTask;

} // namespace auction
} // namespace managers
} // namespace zone
} // namespace server

using namespace server::zone::managers::auction;

#include "gmock/gmock.h"

#include "server/zone/objects/intangible/ControlDevice.h"

#include "templates/SharedObjectTemplate.h"

#include "server/zone/objects/creature/variables/CooldownTimerMap.h"

#include "server/zone/objects/creature/buffs/BuffList.h"

#include "server/zone/objects/creature/damageovertime/DamageOverTimeList.h"

#include "server/zone/objects/scene/variables/DeltaVector.h"

#include "server/zone/objects/creature/variables/CommandQueueActionVector.h"

#include "server/zone/objects/creature/variables/SkillList.h"

#include "server/zone/objects/creature/variables/SkillModList.h"

#include "templates/params/creature/CreaturePosture.h"

#include "templates/params/creature/CreatureState.h"

#include "server/zone/objects/creature/SpeedMultiplierModChanges.h"

#include "server/zone/objects/creature/variables/Skill.h"

#include "server/zone/objects/creature/variables/WearablesDeltaVector.h"

#include "engine/util/u3d/Vector3.h"

#include "system/util/SortedVector.h"

#include "engine/log/Logger.h"

#include "server/zone/CloseObjectsVector.h"

#include "server/zone/QuadTreeEntry.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "system/util/VectorMap.h"

#include "system/lang/Time.h"

#include "system/lang/Long.h"

#include "engine/service/proto/BasePacket.h"

#include "system/thread/Mutex.h"

#include "system/thread/ReadWriteLock.h"

#include "system/util/SynchronizedVectorMap.h"

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject : public TangibleObject {
public:
	static const int HUMAN = 0;

	static const int RODIAN = 1;

	static const int TRANDOSHAN = 2;

	static const int MONCAL = 3;

	static const int WOOKIE = 4;

	static const int BOTHAN = 5;

	static const int TWILEK = 6;

	static const int ZABRAK = 7;

	static const int ITHORIAN = 0x21;

	static const int SULLUSTAN = 0x31;

	static const int HUTT = 0x1f;

	static const int NAUTOLAN = 0;

	static const int TOGRUTA = 0;

	static const int CHISS = 0;

	static const int DEVARONIAN = 0x11;

	static const int GRAN = 0x1c;

	static const int ISHI_TIB = 0x20;

	static const int NIGHTSISTER = 0;

	static const int NIKTO = 0x2a;

	static const int QUARREN = 0x2e;

	static const int SMC = 0;

	static const int WEEQUAY = 0x37;

	static const int AQUALISH = 9;

	static const int BITH = 0x0e;

	static const int GOTAL = 0x1b;

	static const int TALZ = 0x32;

	static const int ABYSSIN = 8;

	static const int ARCONA = 0x0a;

	static const int CEREAN = 0;

	static const int DUROS = 0x14;

	static const int GUNGAN = 0x1d;

	static const int IKTOTCHI = 0;

	static const int JENET = 0;

	static const int KEL_DOR = 0;

	static const int KUBAZ = 0x27;

	static const int SANYASSAN = 0x28;

	static const int MALE = 0;

	static const int FEMALE = 1;

	static const int CREOCOVTYPE = 2;

	unsigned static const long long DEAD_TOO_LONG;

	/**
	 * CreatureObject constructor, used to initialized the object
	 * @pre { templateData is a valid SharedCreatureObjectTemplate LuaObject that contains the necessary values to initialize CreatureObject }
	 * @post { CreatureObject is initialized }
	 * @param templateData templateData points to the SharedCreatureObjectTemplate LuaObject that is used to initialize CreatureObject members
	 */
	CreatureObject();

	void initializeMembers();

	void createChildObjects();

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	void setCountdownTimer(unsigned int newCount, bool notifyClient = true);

	/**
	 * Sends a CommandQueueRemove ObjectControllerMessage to the owner client of this object
	 * @pre { }
	 * @post { client received the CommandQueueRemove message }
	 * @param actioncntr action id that will be cleared from clients queue
	 * @param timer how many seconds will the action take to execute
	 * @param tab1 message 1
	 * @param tab2 message 2
	 */
	void clearQueueAction(unsigned int actioncntr, float timer = 0, unsigned int tab1 = 0, unsigned int tab2 = 0);

	void clearQueueActions(bool combatOnly = true);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines
	 */
	void sendBaselinesTo(SceneObject* player);

	/**
	 * Sends the necessary messages to owner client
	 * @pre { this object is locked }
	 * @post { this object is locked, owner received its own scene object }
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendToOwner(bool doClose = true);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message string message to send
	 */
	void sendSystemMessage(const String& message);

	/**
	 * Sends a PlayMusicMessage
	 */
	void playMusicMessage(const String& file);

	/**
	 * Sends a tutorial request
	 */
	void sendNewbieTutorialRequest(const String& request);

	/**
	 * Sends NewbieTutorialEnableHud
	 */
	void sendNewbieTutorialEnableHudElement(const String& ui, bool enable = true, float blinkCount = 0.0f);

	void sendOpenHolocronToPageMessage();

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message unicode message to send
	 */
	void sendSystemMessage(UnicodeString& message);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message StringIdChatParameter message to send
	 */
	void sendSystemMessage(StringIdChatParameter& stringid);

	/**
	 * Sends the contained slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the slotted objects }
	 * @param player SceneObject that will receive the objects
	 */
	void sendSlottedObjectsTo(SceneObject* player);

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	void setCombatState();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	void clearCombatState(bool clearDefenders = true);

	void addMountedCombatSlow();

	void removeMountedCombatSlow(bool showEndMessage = true);

	/**
	 * Sets a new posture
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new posture set }
	 * @param newPosture posture to set
	 * @param immediate if set true the client will immediately play the posture animation, should not be used in combat
	 *
	 */
	void setPosture(int newPosture, bool immediate = true, bool notifyClient = true);

	void updatePostures(bool immediate = true);

	/**
	 * checks locomotion and sets a new one if appropriate
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new locomotion set, if appropriate }
	 */
	float calculateSpeed();

	void updateLocomotion();

	void setHeight(float heigh, bool notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient = true);

	/**
	 * Updates the speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the turn scale mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTurnScale(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the run speed
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 *
	 */
	void setRunSpeed(float newSpeed, bool notifyClient = true);

	void setCurrentSpeed(float newSpeed);

	/**
	 * Updates a specific type of the HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the HAM type updated to the new value }
	 * @param type specifies which HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setHAM(int type, int value, bool notifyClient = true);

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient = true, bool isCombatAction = false);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient = true, bool isCombatAction = false);

	bool hasDamage(int attribute);

	/**
	 * Heals damage
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient = true, bool notifyObservers = true);

	/**
	 * Heals wounds
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient = true, bool notifyObservers = true);

	/**
	 * Updates a specific type of the Base HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Base HAM type updated to the new value }
	 * @param type specifies which Base HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setBaseHAM(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of wound
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Wounds type updated to the new value }
	 * @param type specifies which Wounds type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setWounds(int type, int value, bool notifyClient = true);

	/**
	 * adds wounds
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns wounds added
	 */
	int addWounds(int type, int value, bool notifyClient = true, bool doShockWounds = true);

	/**
	 * Updates a specific type of the Max HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Max HAM type updated to the new value }
	 * @param type specifies which Max HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setMaxHAM(int type, int value, bool notifyClient = true);

	void addMaxHAM(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of the Encumbrance
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Encumbrance type updated to the new value }
	 * @param type specifies which Encumbrance type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setEncumbrance(int type, int value, bool notifyClient = true);

	void addEncumbrance(int type, int value, bool notifyClient = true);

	/**
	 * Updates the weapon to the specified object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param weao the new weapon
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setWeapon(WeaponObject* weao, bool notifyClient = false);

	/**
	 * Is called when this object has been inserted with an object
	 * @param object object that has been inserted
	 */
	int notifyObjectInserted(SceneObject* object);

	/**
	 * Is called when an object was removed
	 * @param object object that has been inserted
	 */
	int notifyObjectRemoved(SceneObject* object);

	/**
	 * Updates the instrument id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param instrumentid the new instrument id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setInstrumentID(int instrumentid, bool notifyClient = true);

	/**
	 * Updates listen id
	 */
	void setListenToID(unsigned long long id, bool notifyClient = true);

	/**
	 * Updates the preformance counter
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the counter updated }
	 * @param counter new performance counter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPerformanceCounter(int counter, bool notifyClient = true);

	/**
	 * Updates the preformance animation string
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the animation updated }
	 * @param animation new animation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPerformanceAnimation(const String& animation, bool notifyClient = true);

	/**
	 * Updates shock wounds
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param shock new shock wounds
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setShockWounds(int newShock, bool notifyClient = true);

	void addShockWounds(int shockToAdd, bool notiyClient = true, bool sendSpam = true);

	/**
	 * Updates the target id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param objectID the new target id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTargetID(unsigned long long targetID, bool notifyClient = true);

	/**
	 * Updates the bank credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified bank credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setBankCredits(int credits, bool notifyClient = true);

	/**
	 * Adds the buff to the creature, activating it and sending packets if it is a player.
	 * Buffs should never be added to the list without sending of packets.
	 * @param buff The Buff object to add the creature.
	 */
	void addBuff(Buff* buff);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff crc to remove from the buff list.
	 */
	bool removeBuff(unsigned int buffcrc);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff object to remove from the list.
	 */
	void removeBuff(Buff* buff);

	bool removeStateBuff(unsigned long long state);

	/**
	 * Removes all buffs from the creature, deactivating any currently active buffs.
	 * @param updateclient Should packets be sent to the player?
	 */
	void clearBuffs(bool updateclient, bool removeAll);

	/**
	 * Renews the buff and all secondary buffs associated with it.
	 * @param buffCRC The buff to renew from the list
	 * @param duration The duration to renew the buff at
	 * @param sendToClient Send buff information to the client - Necessary to update timers
	 */
	void renewBuff(unsigned int buffCRC, int duration, bool sendToClient = false);

	void updateVehiclePosition(bool sendPackets);

	void addWearableObject(TangibleObject* object, bool notifyClient = true);

	void removeWearableObject(TangibleObject* object, bool notifyClient = true);

	const WearablesDeltaVector* getWearablesDeltaVector() const;

	void sendBuffsTo(CreatureObject* creature);

	BuffList* getBuffList();

	Buff* getBuff(unsigned int buffcrc);

	long long getSkillModFromBuffs(const String& skillMod);

	int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0);

	bool healDot(unsigned long long dotType, int reduction, bool sendMsg = true);

	void clearDots();

	DamageOverTimeList* getDamageOverTimeList();

	bool hasBuff(unsigned int buffcrc);

	void notifySelfPositionUpdate();

	void notifyPostureChange(int newPosture);

	void setLevel(int level, bool randomHam = true);

	void updateToDatabaseAllObjects(bool startTask);

	bool isResuscitable();

	void addBankCredits(int credits, bool notifyClient = true);

	void addCashCredits(int credits, bool notifyClient = true);

	CreditObject* getCreditObject();

	void subtractBankCredits(int credits);

	void subtractCashCredits(int credits);

	bool verifyCashCredits(int credits);

	bool verifyBankCredits(int credits);

	bool isDancing();

	bool isPlayingMusic();

	void stopEntertaining();

	bool isEntertaining();

	/**
	 * Update the cash credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified cash credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setCashCredits(int credits, bool notifyClient = true);

	/**
	 * Sets the terrain negotiation variable, and updates it.
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified terrain negotiation }
	 * @param terrain new terrain negotiation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTerrainNegotiation(float value, bool notifyClient = true);

	/**
	 * Updates the client with the players current terrain negotiation.
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified terrain negotiation }
	 */
	void updateTerrainNegotiation();

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkill(Skill* skill, bool notifyClient = true);

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox name to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkill(const String& skill, bool notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkill(Skill* skill, bool notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkill(const String& skill, bool notifyClient = true);

	/**
	 * Adds new value to the specified skillmod (add a negative number to subtract)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to change
	 * @param value value to add/subtract
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient = true);

	/**
	 * Removes skill mod from the list (same as setting to 0)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient = true);

	void removeAllSkillModsOfType(const int modType, bool notifyClient = true);

	/**
	 * Sets a new group inviter id
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param id object id of the inviter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void updateGroupInviterID(unsigned long long id, bool notifyClient = true);

	/**
	 * Sets the group of this object
	 * @pre { this object is locked }
	 * @post {this object is locked }
	 * @param group GroupObject to update
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void updateGroup(GroupObject* group, bool notifyClient = true);

	/**
	 * Enqueues a command action
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCRC queue command crc
	 * @param actionCount command count
	 * @param targetID target
	 * @param arguments arguments
	 * @param priority command priority
	 */
	void enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority = -1, int compareCount = -1);

	void sendCommand(unsigned int crc, const UnicodeString& args, unsigned long long targetID = 0, int priority = 2);

	void sendCommand(const String& action, const UnicodeString& args, unsigned long long targetID = 0, int priority = 2);

	/**
	 * Sets characters mood
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param moodID mood to set
	 */
	void setMood(byte moodID, bool notifyClient = true);

	/**
	 * Sets a new mood animation
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param mood mood animation string
	 */
	void setMoodString(const String& animation, bool notifyClient = true);

	/**
	 * Removes a command from queue
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCount the action count to remove
	 */
	void deleteQueueAction(unsigned int actionCount);

	/**
	 * Sets a new state to the statebitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask has the new state }
	 * @param state state to add
	 */
	bool setState(unsigned long long state, bool notifyClient = true);

	/**
	 * Sets an alternate appearance
	 * @pre { this object is locked }
	 * @post { this object is locked, alternateAppearance is set and clients updated
	 * @param serverAppearanceTemplate appearance template
	 * @notifyClient updates all in range clients and self
	 */
	void setAlternateAppearance(const String& appearanceTeamplate, bool notifyClient = true);

	/**
	 * Cleares a state from the state bitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask doesnt have the specified state }
	 * @param state state to clear
	 */
	bool clearState(unsigned long long state, bool notifyClient = true);

	void setControlDevice(ControlDevice* device);

	/**
	 * Updates creatureLinkID with specified object
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void setCreatureLink(CreatureObject* object, bool notifyClient = true);

	/**
	 * Executes an object controller command
	 */
	void executeObjectControllerAction(unsigned int actionCRC);

	void executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args);

	/**
	 * Evaluates if this object can be attacked by the passed creature object
	 * @pre { }
	 * @post { }
	 * @return returns true if the creature object can attack this
	 */
	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(CreatureObject* object, bool bypassDeadCheck);

	bool isAttackableBy(TangibleObject* attacker);

	bool isAttackableBy(TangibleObject* object, bool bypassDeadCheck);

	bool isHealableBy(CreatureObject* object);

	/**
	 * Evaluates if the bounty hunter has a mission with the target.
	 * @param target the target.
	 * @return true if bounty hunter has a mission with the target.
	 */
	bool hasBountyMissionFor(CreatureObject* target);

	/**
	 * sends the conversation list
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 * @return whether the conversation was started or not
	 */
	bool sendConversationStartTo(SceneObject* player);

	/**
	 * sends the conversation list
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	void selectConversationOption(int option, SceneObject* obj);

	/**
	 * Sends a message to client
	 * @pre { }
	 * @post { message is sent to client }
	 * @param msg BasePacket to send
	 */
	void sendMessage(BasePacket* msg);

	/**
	 * Sends CombatSpam to players for state/posture changes
	 * @pre { }
	 * @post { CombatSpam is sent to clients }
	 * @param stringName The string name in cbt_spam.stf to send.
	 * @param color The color of the combat spam text. 0 = white, 1 = auto green/red, 10 = red, 11 = yellow
	 * @param broadcast Specifies whether to send the packet to all nearby players or just this player.
	 */
	void sendStateCombatSpam(const String& fileName, const String& stringName, byte color, int damage = 0, bool broadcast = true);

	/**
	 * Sends custom CombatSpam strings to players
	 * @pre { }
	 * @post { CombatSpam is sent to clients }
	 * @param customString The string to send to combat spam window.
	 * @param color The color of the combat spam text. 0 = white, 10 = red, 11 = yellow
	 */
	void sendCustomCombatSpam(const UnicodeString& customString, byte color);

	/**
	 * Sends a ExecuteConsoleCommand to the client
	 * @param command example "/attack"
	 */
	void sendExecuteConsoleCommand(const String& command);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	bool isAggressiveTo(CreatureObject* object);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	/**
	 * Is called when this object is killed
	 * @pre { this, killer locked }
	 * @post { this, killer locked }
	 * @param killer The killer.
	 */
	int notifyObjectKillObservers(TangibleObject* killer);

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	void notifyInsert(QuadTreeEntry* obj);

	void notifyDissapear(QuadTreeEntry* obj);

	void notifyPositionUpdate(QuadTreeEntry* entry);

	/**
	 * Destroys this object from database
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	void destroyObjectFromDatabase(bool destroyContainedObjects = false);

	void setFactionRank(int rank, bool notifyClient = true);

	String getFirstName();

	String setFirstName(const String& newFirstName);

	String getLastName();

	String setLastName(const String& newLastName, bool skipVerify);

	String setLastName(const String& newLastName);

	bool isOnline();

	bool canTreatInjuries();

	bool canTreatStates();

	bool canTreatWounds();

	bool canTreatConditions();

	Reference<PlayerObject* > getPlayerObject();

	bool isListening() const;

	bool isWatching() const;

	void setClient(ZoneClientSession* cli);

	void dismount();

	float calculateBFRatio();

	void removeFeignedDeath();

	bool canFeignDeath();

	void feignDeath();

	void setFeignedDeathState();

	void setDizziedState(int durationSeconds = 5);

	void setRalliedState(int durationSeconds = 5);

	void setAimingState(int durationSeconds = 5);

	void setCoverState(int durationSeconds = 40);

	void setBerserkedState(unsigned int duration);

	void setStunnedState(int durationSeconds = 5);

	void setBlindedState(int durationSeconds = 5);

	void setIntimidatedState(int durationSeconds = 15);

	void setSnaredState(int durationSeconds = 20);

	void setRootedState(int durationSeconds = 20);

	bool setNextAttackDelay(unsigned int mod, int del);

	void setMeditateState();

	void activateHAMRegeneration(int latency);

	void activatePassiveWoundRegeneration();

	void activateStateRecovery();

	void updateTimeOfDeath();

	bool hasAttackDelay();

	void removeAttackDelay();

	bool hasIncapTimer();

	CooldownTimerMap* getCooldownTimerMap();

	bool hasSpice();

	void updateLastSuccessfulCombatAction();

	void updatePostureChangeDelay(unsigned long long delay);

	bool checkPostureChangeDelay();

	void updatePostureDownRecovery();

	bool checkPostureDownRecovery();

	void updatePostureUpRecovery();

	bool checkPostureUpRecovery();

	void updateKnockdownRecovery();

	bool checkKnockdownRecovery();

	void updateGroupMFDPositions();

	void queueDizzyFallEvent();

	bool hasDizzyEvent();

	void clearDizzyEvent();

	/**
	 * Returns the given ScreenPlayState.
	 * Takes the screenPlayStatesMutex.
	 * @param screenPlay ScreenPlay to retrieve
         */
	unsigned long long getScreenPlayState(const String& screenPlay);

	/**
	 * Sets the given ScreenPlayState.
	 * Takes the screenPlayStatesMutex.
	 * @param screenPlay ScreenPlay to modify
	 * @param state the State to set
         */
	void setScreenPlayState(const String& screenPlay, unsigned long long state);

	void updateCooldownTimer(const String& coooldownTimer, unsigned long long miliSecondsToAdd = 0);

	bool checkCooldownRecovery(const String& cooldown);

	Time* getCooldownTime(const String& cooldown);

	void addCooldown(const String& name, unsigned long long miliseconds);

	void doAnimation(const String& animation);

	void doCombatAnimation(TangibleObject* defender, unsigned int animationCRC, byte hit, byte trails, unsigned long long weaponID = 0);

	void doCombatAnimation(unsigned int animationCRC);

	void activateQueueAction();

	void activateImmediateAction();

	UnicodeString getCreatureName();

	bool isGrouped() const;

	int getBankCredits() const;

	int getCashCredits() const;

	int getBaseHAM(int idx) const;

	int getWounds(int idx) const;

	const DeltaVector<int>* getWounds() const;

	int getHAM(int idx) const;

	const DeltaVector<int>* getHAM() const;

	int getMaxHAM(int idx) const;

	const DeltaVector<int>* getMaxHAM() const;

	int getEncumbrance(int idx) const;

	const DeltaVector<int>* getEncumbrances() const;

	byte getPosture() const;

	byte getLocomotion() const;

	byte getFactionRank() const;

	ManagedWeakReference<CreatureObject* > getLinkedCreature() const;

	unsigned long long getCreatureLinkID() const;

	float getShockWounds() const;

	unsigned long long getWatchToID() const;

	unsigned long long getStateBitmask() const;

	bool hasState(unsigned long long state) const;

	bool hasStates() const;

	unsigned long long getListenID() const;

	float getAccelerationMultiplierBase() const;

	float getAccelerationMultiplierMod() const;

	float getSpeedMultiplierBase() const;

	float getSpeedMultiplierMod() const;

	float getCurrentSpeed() const;

	SpeedMultiplierModChanges* getSpeedMultiplierModChanges();

	CommandQueueActionVector* getCommandQueue();

	int getCommandQueueSize() const;

	void setLastActionCounter(unsigned int ctr);

	unsigned int incrementLastActionCounter();

	unsigned int getLastActionCounter();

	float getRunSpeed() const;

	float getWalkSpeed() const;

	float getTurnScale() const;

	float getTerrainNegotiation() const;

	float getRunAcceleration() const;

	float getWalkAcceleration() const;

	String getPerformanceAnimation() const;

	String getMoodString() const;

	unsigned long long getWeaponID() const;

	Reference<WeaponObject* > getWeapon();

	ManagedWeakReference<GuildObject* > getGuildObject() const;

	int getGuildID() const;

	bool isInGuild() const;

	void setGuildObject(GuildObject* guildobj);

	unsigned long long getGroupID() const;

	unsigned long long getGroupInviterID() const;

	Reference<GroupObject* > getGroup() const;

	unsigned long long getGroupInviteCounter() const;

	unsigned long long getTargetID() const;

	byte getMoodID() const;

	float getSlopeModPercent() const;

	int getPerformanceCounter() const;

	int getInstrumentID() const;

	byte getFrozen() const;

	float getHeight() const;

	bool isDroidSpecies();

	bool isWalkerSpecies();

	bool isProbotSpecies();

	bool hasEffectImmunity(byte effectType);

	bool hasDotImmunity(unsigned int dotType);

	int getSpecies() const;

	String getSpeciesName() const;

	int getGender() const;

	const DeltaVector<int>* getBaseHAM() const;

	const SkillList* getSkillList() const;

	int getSkillMod(const String& skillmod) const;

	int getSkillModOfType(const String& skillmod, unsigned const int modType);

	bool hasSkill(const String& skill) const;

	SkillModList* getSkillModList();

	const SkillModList* getSkillModList() const;

	void setWatchToID(unsigned long long id);

	bool isCreatureObject();

	CreatureObject* asCreatureObject();

	bool isNextActionPast();

	bool isSwimming() const;

	Reference<ZoneClientSession* > getClient();

	ManagedWeakReference<ControlDevice* > getControlDevice() const;

	float getSwimHeight() const;

	bool isIncapacitated() const;

	bool isDead() const;

	bool isKnockedDown() const;

	bool isKneeling() const;

	bool isProne() const;

	bool isStanding() const;

	bool isSitting() const;

	bool isSkillAnimating() const;

	bool isRallied() const;

	bool isInCombat() const;

	bool isDizzied() const;

	bool isBerserked() const;

	bool isStunned() const;

	bool isBlinded() const;

	bool isIntimidated() const;

	bool isSnared() const;

	bool isImmobilized() const;

	bool isRooted() const;

	bool isFrozen() const;

	bool isDiseased() const;

	bool isPoisoned() const;

	bool isBleeding() const;

	bool isOnFire() const;

	bool isFeigningDeath() const;

	bool isRidingMount() const;

	bool hasRidingCreature() const;

	bool isPeaced() const;

	bool isMeditating() const;

	bool isAiming() const;

	bool isInCover() const;

	bool isRunning() const;

	bool isNonPlayerCreatureObject();

	bool isDroidObject();

	bool isPlayerCreature();

	int getReceiverFlags();

	bool isInformantCreature();

	CampSiteActiveArea* getCurrentCamp();

	byte getCurrentWeather() const;

	void setCurrentWeather(byte value);

	byte getCurrentWind() const;

	void setCurrentWind(byte value);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	String getAlternateAppearance() const;

	ReadWriteLock* getSkillModMutex();

	float calculateCostAdjustment(byte stat, float baseCost);

	void updateSpeedAndAccelerationMods();

	void setFaction(unsigned int crc);

	/**
	 * Destroys a PlayerCreature from the database. If this object is not a PlayerCreature then the method will return without doing anything.
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	void destroyPlayerCreatureFromDatabase(bool destroyContainedObjects = false);

	float getTemplateRadius();

	void reloadTemplate();

	void removeOutOfRangeObjects();

	void synchronizeCloseObjects();

	void addPersonalEnemyFlag(CreatureObject* enemy, unsigned long long duration);

	unsigned long long getPersonalEnemyFlagTime(unsigned long long enemyID) const;

	void removePersonalEnemyFlag(CreatureObject* enemy);

	void removePersonalEnemyFlag(unsigned long long enemyID);

	bool hasPersonalEnemyFlag(CreatureObject* enemy) const;

	void schedulePersonalEnemyFlagTasks();

	void setHue(int hueIndex);

	int getHueValue() const;

	WeakReference<AuctionSearchTask* > getAuctionSearchTask() const;

	void setAuctionSearchTask(AuctionSearchTask* task);

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	CreatureObject(DummyConstructorParameter* param);

	virtual ~CreatureObject();

	CreatureObject* __asCreatureObject();

	friend class CreatureObjectHelper;
};

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObjectImplementation : public TangibleObjectImplementation {
protected:
	ManagedWeakReference<ZoneClientSession* > owner;

	ManagedReference<CreditObject* > creditObject;

	int bankCredits;

	int cashCredits;

	int hueValue;

	DeltaVector<int> baseHAM;

	byte posture;

	byte locomotion;

	byte factionRank;

	ManagedWeakReference<CreatureObject* > linkedCreature;

	ManagedWeakReference<ControlDevice* > controlDevice;

	float shockWounds;

	DeltaVector<int> wounds;

	unsigned long long stateBitmask;

	DeltaVector<int> encumbrances;

	WearablesDeltaVector wearablesVector;

	WeakReference<AuctionSearchTask* > auctionSearch;

	float accelerationMultiplierBase;

	float accelerationMultiplierMod;

	float speedMultiplierBase;

	SpeedMultiplierModChanges speedMultiplierModChanges;

	float speedMultiplierMod;

	float turnScale;

	float runSpeed;

	float walkSpeed;

	float currentSpeed;

	float terrainNegotiation;

	float runAcceleration;

	float walkAcceleration;

	float height;

	float swimHeight;

	float slopeModPercent;

	float slopeModAngle;

	unsigned long long listenToID;

	unsigned long long watchToID;

	String performanceAnimation;

	String moodString;

	ManagedReference<WeaponObject* > weapon;

	ManagedReference<GroupObject* > group;

	unsigned long long groupInviterID;

	unsigned long long groupInviteCounter;

	ManagedWeakReference<GuildObject* > guild;

	unsigned long long targetID;

	byte moodID;

	int performanceCounter;

	int instrumentID;

	DeltaVector<int> hamList;

	DeltaVector<int> maxHamList;

	byte frozen;

	String templateString;

	SkillList skillList;

	SkillModList skillModList;

	ReadWriteLock skillModMutex;

	Reference<CommandQueueActionVector* > commandQueue;

	Reference<CommandQueueActionVector* > immediateQueue;

	unsigned int lastActionCounter;

	Time nextAction;

	Reference<CooldownTimerMap* > cooldownTimerMap;

	BuffList creatureBuffs;

	DamageOverTimeList damageOverTimeList;

	Time lastSuccessfulCombatAction;

	Reference<DizzyFallDownEvent* > dizzyFallDownEvent;

	Time timeOfDeath;

private:
	Mutex screenPlayStatesMutex;

	VectorMap<String, unsigned long long> screenPlayStates;

protected:
	SynchronizedVectorMap<unsigned long long, unsigned long long> personalEnemyFlags;

	byte healthWoundHeal;

	byte actionWoundHeal;

	byte mindWoundHeal;

	byte currentWeather;

	byte currentWind;

	Time lastCombatActionTime;

	Vector3 lastCombatPosition;

	String alternateAppearance;

public:
	static const int HUMAN = 0;

	static const int RODIAN = 1;

	static const int TRANDOSHAN = 2;

	static const int MONCAL = 3;

	static const int WOOKIE = 4;

	static const int BOTHAN = 5;

	static const int TWILEK = 6;

	static const int ZABRAK = 7;

	static const int ITHORIAN = 0x21;

	static const int SULLUSTAN = 0x31;

	static const int HUTT = 0x1f;

	static const int NAUTOLAN = 0;

	static const int TOGRUTA = 0;

	static const int CHISS = 0;

	static const int DEVARONIAN = 0x11;

	static const int GRAN = 0x1c;

	static const int ISHI_TIB = 0x20;

	static const int NIGHTSISTER = 0;

	static const int NIKTO = 0x2a;

	static const int QUARREN = 0x2e;

	static const int SMC = 0;

	static const int WEEQUAY = 0x37;

	static const int AQUALISH = 9;

	static const int BITH = 0x0e;

	static const int GOTAL = 0x1b;

	static const int TALZ = 0x32;

	static const int ABYSSIN = 8;

	static const int ARCONA = 0x0a;

	static const int CEREAN = 0;

	static const int DUROS = 0x14;

	static const int GUNGAN = 0x1d;

	static const int IKTOTCHI = 0;

	static const int JENET = 0;

	static const int KEL_DOR = 0;

	static const int KUBAZ = 0x27;

	static const int SANYASSAN = 0x28;

	static const int MALE = 0;

	static const int FEMALE = 1;

	static const int CREOCOVTYPE = 2;

	static float DEFAULTRUNSPEED;

	unsigned static const long long DEAD_TOO_LONG;

	CreatureObjectImplementation();

	CreatureObjectImplementation(DummyConstructorParameter* param);

	void initializeMembers();

	void finalize();

	void createChildObjects();

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	virtual void setCountdownTimer(unsigned int newCount, bool notifyClient = true);

	/**
	 * Sends a CommandQueueRemove ObjectControllerMessage to the owner client of this object
	 * @pre { }
	 * @post { client received the CommandQueueRemove message }
	 * @param actioncntr action id that will be cleared from clients queue
	 * @param timer how many seconds will the action take to execute
	 * @param tab1 message 1
	 * @param tab2 message 2
	 */
	void clearQueueAction(unsigned int actioncntr, float timer = 0, unsigned int tab1 = 0, unsigned int tab2 = 0);

	void clearQueueActions(bool combatOnly = true);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines
	 */
	void sendBaselinesTo(SceneObject* player);

	/**
	 * Sends the necessary messages to owner client
	 * @pre { this object is locked }
	 * @post { this object is locked, owner received its own scene object }
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendToOwner(bool doClose = true);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message string message to send
	 */
	void sendSystemMessage(const String& message);

	/**
	 * Sends a PlayMusicMessage
	 */
	void playMusicMessage(const String& file);

	/**
	 * Sends a tutorial request
	 */
	void sendNewbieTutorialRequest(const String& request);

	/**
	 * Sends NewbieTutorialEnableHud
	 */
	void sendNewbieTutorialEnableHudElement(const String& ui, bool enable = true, float blinkCount = 0.0f);

	void sendOpenHolocronToPageMessage();

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message unicode message to send
	 */
	void sendSystemMessage(UnicodeString& message);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message StringIdChatParameter message to send
	 */
	void sendSystemMessage(StringIdChatParameter& stringid);

	/**
	 * Sends the contained slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the slotted objects }
	 * @param player SceneObject that will receive the objects
	 */
	void sendSlottedObjectsTo(SceneObject* player);

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	virtual void setCombatState();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	void clearCombatState(bool clearDefenders = true);

	void addMountedCombatSlow();

	void removeMountedCombatSlow(bool showEndMessage = true);

	/**
	 * Sets a new posture
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new posture set }
	 * @param newPosture posture to set
	 * @param immediate if set true the client will immediately play the posture animation, should not be used in combat
	 *
	 */
	virtual void setPosture(int newPosture, bool immediate = true, bool notifyClient = true);

	virtual void updatePostures(bool immediate = true);

	/**
	 * checks locomotion and sets a new one if appropriate
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new locomotion set, if appropriate }
	 */
	float calculateSpeed();

	virtual void updateLocomotion();

	void setHeight(float heigh, bool notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient = true);

	/**
	 * Updates the speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	virtual void setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the turn scale mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	virtual void setTurnScale(float newMultiplierMod, bool notifyClient = true);

	/**
	 * Updates the run speed
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 *
	 */
	void setRunSpeed(float newSpeed, bool notifyClient = true);

	void setCurrentSpeed(float newSpeed);

	/**
	 * Updates a specific type of the HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the HAM type updated to the new value }
	 * @param type specifies which HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setHAM(int type, int value, bool notifyClient = true);

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient = true, bool isCombatAction = false);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient = true, bool isCombatAction = false);

	bool hasDamage(int attribute);

	/**
	 * Heals damage
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient = true, bool notifyObservers = true);

	/**
	 * Heals wounds
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	virtual int healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient = true, bool notifyObservers = true);

	/**
	 * Updates a specific type of the Base HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Base HAM type updated to the new value }
	 * @param type specifies which Base HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setBaseHAM(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of wound
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Wounds type updated to the new value }
	 * @param type specifies which Wounds type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	virtual void setWounds(int type, int value, bool notifyClient = true);

	/**
	 * adds wounds
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns wounds added
	 */
	virtual int addWounds(int type, int value, bool notifyClient = true, bool doShockWounds = true);

	/**
	 * Updates a specific type of the Max HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Max HAM type updated to the new value }
	 * @param type specifies which Max HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	virtual void setMaxHAM(int type, int value, bool notifyClient = true);

	void addMaxHAM(int type, int value, bool notifyClient = true);

	/**
	 * Updates a specific type of the Encumbrance
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Encumbrance type updated to the new value }
	 * @param type specifies which Encumbrance type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setEncumbrance(int type, int value, bool notifyClient = true);

	void addEncumbrance(int type, int value, bool notifyClient = true);

	/**
	 * Updates the weapon to the specified object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param weao the new weapon
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setWeapon(WeaponObject* weao, bool notifyClient = false);

	/**
	 * Is called when this object has been inserted with an object
	 * @param object object that has been inserted
	 */
	int notifyObjectInserted(SceneObject* object);

	/**
	 * Is called when an object was removed
	 * @param object object that has been inserted
	 */
	int notifyObjectRemoved(SceneObject* object);

	/**
	 * Updates the instrument id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param instrumentid the new instrument id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setInstrumentID(int instrumentid, bool notifyClient = true);

	/**
	 * Updates listen id
	 */
	void setListenToID(unsigned long long id, bool notifyClient = true);

	/**
	 * Updates the preformance counter
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the counter updated }
	 * @param counter new performance counter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPerformanceCounter(int counter, bool notifyClient = true);

	/**
	 * Updates the preformance animation string
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the animation updated }
	 * @param animation new animation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setPerformanceAnimation(const String& animation, bool notifyClient = true);

	/**
	 * Updates shock wounds
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param shock new shock wounds
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setShockWounds(int newShock, bool notifyClient = true);

	void addShockWounds(int shockToAdd, bool notiyClient = true, bool sendSpam = true);

	/**
	 * Updates the target id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param objectID the new target id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTargetID(unsigned long long targetID, bool notifyClient = true);

	/**
	 * Updates the bank credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified bank credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setBankCredits(int credits, bool notifyClient = true);

	/**
	 * Adds the buff to the creature, activating it and sending packets if it is a player.
	 * Buffs should never be added to the list without sending of packets.
	 * @param buff The Buff object to add the creature.
	 */
	void addBuff(Buff* buff);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff crc to remove from the buff list.
	 */
	bool removeBuff(unsigned int buffcrc);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff object to remove from the list.
	 */
	void removeBuff(Buff* buff);

	bool removeStateBuff(unsigned long long state);

	/**
	 * Removes all buffs from the creature, deactivating any currently active buffs.
	 * @param updateclient Should packets be sent to the player?
	 */
	void clearBuffs(bool updateclient, bool removeAll);

	/**
	 * Renews the buff and all secondary buffs associated with it.
	 * @param buffCRC The buff to renew from the list
	 * @param duration The duration to renew the buff at
	 * @param sendToClient Send buff information to the client - Necessary to update timers
	 */
	void renewBuff(unsigned int buffCRC, int duration, bool sendToClient = false);

	void updateVehiclePosition(bool sendPackets);

	void addWearableObject(TangibleObject* object, bool notifyClient = true);

	void removeWearableObject(TangibleObject* object, bool notifyClient = true);

	const WearablesDeltaVector* getWearablesDeltaVector() const;

	void sendBuffsTo(CreatureObject* creature);

	BuffList* getBuffList();

	Buff* getBuff(unsigned int buffcrc);

	long long getSkillModFromBuffs(const String& skillMod);

	virtual int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0);

	bool healDot(unsigned long long dotType, int reduction, bool sendMsg = true);

	void clearDots();

	DamageOverTimeList* getDamageOverTimeList();

	bool hasBuff(unsigned int buffcrc);

	void notifySelfPositionUpdate();

	void notifyPostureChange(int newPosture);

	void setLevel(int level, bool randomHam = true);

	void updateToDatabaseAllObjects(bool startTask);

	bool isResuscitable();

	void addBankCredits(int credits, bool notifyClient = true);

	void addCashCredits(int credits, bool notifyClient = true);

	CreditObject* getCreditObject();

	void subtractBankCredits(int credits);

	void subtractCashCredits(int credits);

	bool verifyCashCredits(int credits);

	bool verifyBankCredits(int credits);

	bool isDancing();

	bool isPlayingMusic();

	void stopEntertaining();

	bool isEntertaining();

	/**
	 * Update the cash credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified cash credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setCashCredits(int credits, bool notifyClient = true);

	/**
	 * Sets the terrain negotiation variable, and updates it.
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified terrain negotiation }
	 * @param terrain new terrain negotiation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void setTerrainNegotiation(float value, bool notifyClient = true);

	/**
	 * Updates the client with the players current terrain negotiation.
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified terrain negotiation }
	 */
	void updateTerrainNegotiation();

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkill(Skill* skill, bool notifyClient = true);

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox name to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkill(const String& skill, bool notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkill(Skill* skill, bool notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkill(const String& skill, bool notifyClient = true);

	/**
	 * Adds new value to the specified skillmod (add a negative number to subtract)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to change
	 * @param value value to add/subtract
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient = true);

	/**
	 * Removes skill mod from the list (same as setting to 0)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient = true);

	void removeAllSkillModsOfType(const int modType, bool notifyClient = true);

	/**
	 * Sets a new group inviter id
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param id object id of the inviter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void updateGroupInviterID(unsigned long long id, bool notifyClient = true);

	/**
	 * Sets the group of this object
	 * @pre { this object is locked }
	 * @post {this object is locked }
	 * @param group GroupObject to update
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	void updateGroup(GroupObject* group, bool notifyClient = true);

	/**
	 * Enqueues a command action
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCRC queue command crc
	 * @param actionCount command count
	 * @param targetID target
	 * @param arguments arguments
	 * @param priority command priority
	 */
	void enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority = -1, int compareCount = -1);

	void sendCommand(unsigned int crc, const UnicodeString& args, unsigned long long targetID = 0, int priority = 2);

	void sendCommand(const String& action, const UnicodeString& args, unsigned long long targetID = 0, int priority = 2);

	/**
	 * Sets characters mood
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param moodID mood to set
	 */
	void setMood(byte moodID, bool notifyClient = true);

	/**
	 * Sets a new mood animation
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param mood mood animation string
	 */
	void setMoodString(const String& animation, bool notifyClient = true);

	/**
	 * Removes a command from queue
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCount the action count to remove
	 */
	void deleteQueueAction(unsigned int actionCount);

	/**
	 * Sets a new state to the statebitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask has the new state }
	 * @param state state to add
	 */
	bool setState(unsigned long long state, bool notifyClient = true);

	/**
	 * Sets an alternate appearance
	 * @pre { this object is locked }
	 * @post { this object is locked, alternateAppearance is set and clients updated
	 * @param serverAppearanceTemplate appearance template
	 * @notifyClient updates all in range clients and self
	 */
	void setAlternateAppearance(const String& appearanceTeamplate, bool notifyClient = true);

	/**
	 * Cleares a state from the state bitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask doesnt have the specified state }
	 * @param state state to clear
	 */
	bool clearState(unsigned long long state, bool notifyClient = true);

	void setControlDevice(ControlDevice* device);

	/**
	 * Updates creatureLinkID with specified object
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void setCreatureLink(CreatureObject* object, bool notifyClient = true);

	/**
	 * Executes an object controller command
	 */
	void executeObjectControllerAction(unsigned int actionCRC);

	void executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args);

	/**
	 * Evaluates if this object can be attacked by the passed creature object
	 * @pre { }
	 * @post { }
	 * @return returns true if the creature object can attack this
	 */
	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(CreatureObject* object, bool bypassDeadCheck);

	virtual bool isAttackableBy(TangibleObject* attacker);

	bool isAttackableBy(TangibleObject* object, bool bypassDeadCheck);

	bool isHealableBy(CreatureObject* object);

	/**
	 * Evaluates if the bounty hunter has a mission with the target.
	 * @param target the target.
	 * @return true if bounty hunter has a mission with the target.
	 */
	bool hasBountyMissionFor(CreatureObject* target);

	/**
	 * sends the conversation list
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 * @return whether the conversation was started or not
	 */
	virtual bool sendConversationStartTo(SceneObject* player);

	/**
	 * sends the conversation list
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	virtual void selectConversationOption(int option, SceneObject* obj);

	/**
	 * Sends a message to client
	 * @pre { }
	 * @post { message is sent to client }
	 * @param msg BasePacket to send
	 */
	void sendMessage(BasePacket* msg);

	/**
	 * Sends CombatSpam to players for state/posture changes
	 * @pre { }
	 * @post { CombatSpam is sent to clients }
	 * @param stringName The string name in cbt_spam.stf to send.
	 * @param color The color of the combat spam text. 0 = white, 1 = auto green/red, 10 = red, 11 = yellow
	 * @param broadcast Specifies whether to send the packet to all nearby players or just this player.
	 */
	void sendStateCombatSpam(const String& fileName, const String& stringName, byte color, int damage = 0, bool broadcast = true);

	/**
	 * Sends custom CombatSpam strings to players
	 * @pre { }
	 * @post { CombatSpam is sent to clients }
	 * @param customString The string to send to combat spam window.
	 * @param color The color of the combat spam text. 0 = white, 10 = red, 11 = yellow
	 */
	void sendCustomCombatSpam(const UnicodeString& customString, byte color);

	/**
	 * Sends a ExecuteConsoleCommand to the client
	 * @param command example "/attack"
	 */
	void sendExecuteConsoleCommand(const String& command);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	bool isAggressiveTo(CreatureObject* object);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	/**
	 * Is called when this object is killed
	 * @pre { this, killer locked }
	 * @post { this, killer locked }
	 * @param killer The killer.
	 */
	int notifyObjectKillObservers(TangibleObject* killer);

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	void notifyInsert(QuadTreeEntry* obj);

	void notifyDissapear(QuadTreeEntry* obj);

	void notifyPositionUpdate(QuadTreeEntry* entry);

	/**
	 * Destroys this object from database
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	void destroyObjectFromDatabase(bool destroyContainedObjects = false);

	void setFactionRank(int rank, bool notifyClient = true);

	String getFirstName();

	String setFirstName(const String& newFirstName);

	String getLastName();

	String setLastName(const String& newLastName, bool skipVerify);

	String setLastName(const String& newLastName);

	bool isOnline();

	bool canTreatInjuries();

	bool canTreatStates();

	bool canTreatWounds();

	bool canTreatConditions();

	Reference<PlayerObject* > getPlayerObject();

	bool isListening() const;

	bool isWatching() const;

	void setClient(ZoneClientSession* cli);

	void dismount();

	float calculateBFRatio();

	void removeFeignedDeath();

	bool canFeignDeath();

	void feignDeath();

	void setFeignedDeathState();

	void setDizziedState(int durationSeconds = 5);

	void setRalliedState(int durationSeconds = 5);

	void setAimingState(int durationSeconds = 5);

	void setCoverState(int durationSeconds = 40);

	void setBerserkedState(unsigned int duration);

	void setStunnedState(int durationSeconds = 5);

	void setBlindedState(int durationSeconds = 5);

	void setIntimidatedState(int durationSeconds = 15);

	void setSnaredState(int durationSeconds = 20);

	void setRootedState(int durationSeconds = 20);

	bool setNextAttackDelay(unsigned int mod, int del);

	void setMeditateState();

	virtual void activateHAMRegeneration(int latency);

	virtual void activatePassiveWoundRegeneration();

	virtual void activateStateRecovery();

	void updateTimeOfDeath();

	bool hasAttackDelay();

	void removeAttackDelay();

	bool hasIncapTimer();

	CooldownTimerMap* getCooldownTimerMap();

	bool hasSpice();

	void updateLastSuccessfulCombatAction();

	void updatePostureChangeDelay(unsigned long long delay);

	bool checkPostureChangeDelay();

	void updatePostureDownRecovery();

	bool checkPostureDownRecovery();

	void updatePostureUpRecovery();

	bool checkPostureUpRecovery();

	void updateKnockdownRecovery();

	bool checkKnockdownRecovery();

	void updateGroupMFDPositions();

	virtual void queueDizzyFallEvent();

	bool hasDizzyEvent();

	void clearDizzyEvent();

	/**
	 * Returns the given ScreenPlayState.
	 * Takes the screenPlayStatesMutex.
	 * @param screenPlay ScreenPlay to retrieve
         */
	unsigned long long getScreenPlayState(const String& screenPlay);

	/**
	 * Sets the given ScreenPlayState.
	 * Takes the screenPlayStatesMutex.
	 * @param screenPlay ScreenPlay to modify
	 * @param state the State to set
         */
	void setScreenPlayState(const String& screenPlay, unsigned long long state);

	void updateCooldownTimer(const String& coooldownTimer, unsigned long long miliSecondsToAdd = 0);

	bool checkCooldownRecovery(const String& cooldown);

	Time* getCooldownTime(const String& cooldown);

	void addCooldown(const String& name, unsigned long long miliseconds);

	void doAnimation(const String& animation);

	void doCombatAnimation(TangibleObject* defender, unsigned int animationCRC, byte hit, byte trails, unsigned long long weaponID = 0);

	void doCombatAnimation(unsigned int animationCRC);

	void activateQueueAction();

	void activateImmediateAction();

	UnicodeString getCreatureName();

	bool isGrouped() const;

	int getBankCredits() const;

	int getCashCredits() const;

	int getBaseHAM(int idx) const;

	int getWounds(int idx) const;

	const DeltaVector<int>* getWounds() const;

	int getHAM(int idx) const;

	const DeltaVector<int>* getHAM() const;

	int getMaxHAM(int idx) const;

	const DeltaVector<int>* getMaxHAM() const;

	int getEncumbrance(int idx) const;

	const DeltaVector<int>* getEncumbrances() const;

	byte getPosture() const;

	byte getLocomotion() const;

	byte getFactionRank() const;

	ManagedWeakReference<CreatureObject* > getLinkedCreature() const;

	unsigned long long getCreatureLinkID() const;

	float getShockWounds() const;

	unsigned long long getWatchToID() const;

	unsigned long long getStateBitmask() const;

	bool hasState(unsigned long long state) const;

	bool hasStates() const;

	unsigned long long getListenID() const;

	float getAccelerationMultiplierBase() const;

	float getAccelerationMultiplierMod() const;

	float getSpeedMultiplierBase() const;

	float getSpeedMultiplierMod() const;

	float getCurrentSpeed() const;

	SpeedMultiplierModChanges* getSpeedMultiplierModChanges();

	CommandQueueActionVector* getCommandQueue();

	int getCommandQueueSize() const;

	void setLastActionCounter(unsigned int ctr);

	unsigned int incrementLastActionCounter();

	unsigned int getLastActionCounter();

	float getRunSpeed() const;

	float getWalkSpeed() const;

	float getTurnScale() const;

	float getTerrainNegotiation() const;

	float getRunAcceleration() const;

	float getWalkAcceleration() const;

	String getPerformanceAnimation() const;

	String getMoodString() const;

	unsigned long long getWeaponID() const;

	Reference<WeaponObject* > getWeapon();

	ManagedWeakReference<GuildObject* > getGuildObject() const;

	int getGuildID() const;

	bool isInGuild() const;

	void setGuildObject(GuildObject* guildobj);

	unsigned long long getGroupID() const;

	unsigned long long getGroupInviterID() const;

	Reference<GroupObject* > getGroup() const;

	unsigned long long getGroupInviteCounter() const;

	unsigned long long getTargetID() const;

	byte getMoodID() const;

	float getSlopeModPercent() const;

	int getPerformanceCounter() const;

	int getInstrumentID() const;

	byte getFrozen() const;

	float getHeight() const;

	bool isDroidSpecies();

	bool isWalkerSpecies();

	bool isProbotSpecies();

	bool hasEffectImmunity(byte effectType);

	bool hasDotImmunity(unsigned int dotType);

	virtual int getSpecies() const;

	String getSpeciesName() const;

	int getGender() const;

	const DeltaVector<int>* getBaseHAM() const;

	const SkillList* getSkillList() const;

	int getSkillMod(const String& skillmod) const;

	int getSkillModOfType(const String& skillmod, unsigned const int modType);

	bool hasSkill(const String& skill) const;

	SkillModList* getSkillModList();

	const SkillModList* getSkillModList() const;

	void setWatchToID(unsigned long long id);

	bool isCreatureObject();

	CreatureObject* asCreatureObject();

	bool isNextActionPast();

	bool isSwimming() const;

	Reference<ZoneClientSession* > getClient();

	ManagedWeakReference<ControlDevice* > getControlDevice() const;

	float getSwimHeight() const;

	bool isIncapacitated() const;

	bool isDead() const;

	bool isKnockedDown() const;

	bool isKneeling() const;

	bool isProne() const;

	bool isStanding() const;

	bool isSitting() const;

	bool isSkillAnimating() const;

	bool isRallied() const;

	bool isInCombat() const;

	bool isDizzied() const;

	bool isBerserked() const;

	bool isStunned() const;

	bool isBlinded() const;

	bool isIntimidated() const;

	bool isSnared() const;

	bool isImmobilized() const;

	bool isRooted() const;

	bool isFrozen() const;

	bool isDiseased() const;

	bool isPoisoned() const;

	bool isBleeding() const;

	bool isOnFire() const;

	bool isFeigningDeath() const;

	bool isRidingMount() const;

	bool hasRidingCreature() const;

	bool isPeaced() const;

	bool isMeditating() const;

	bool isAiming() const;

	bool isInCover() const;

	bool isRunning() const;

	virtual bool isNonPlayerCreatureObject();

	virtual bool isDroidObject();

	bool isPlayerCreature();

	virtual int getReceiverFlags();

	virtual bool isInformantCreature();

	CampSiteActiveArea* getCurrentCamp();

	byte getCurrentWeather() const;

	void setCurrentWeather(byte value);

	byte getCurrentWind() const;

	void setCurrentWind(byte value);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	String getAlternateAppearance() const;

	ReadWriteLock* getSkillModMutex();

	float calculateCostAdjustment(byte stat, float baseCost);

	void updateSpeedAndAccelerationMods();

	void setFaction(unsigned int crc);

	/**
	 * Destroys a PlayerCreature from the database. If this object is not a PlayerCreature then the method will return without doing anything.
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	virtual void destroyPlayerCreatureFromDatabase(bool destroyContainedObjects = false);

	float getTemplateRadius();

	virtual void reloadTemplate();

	void removeOutOfRangeObjects();

	void synchronizeCloseObjects();

	void addPersonalEnemyFlag(CreatureObject* enemy, unsigned long long duration);

	unsigned long long getPersonalEnemyFlagTime(unsigned long long enemyID) const;

	void removePersonalEnemyFlag(CreatureObject* enemy);

	void removePersonalEnemyFlag(unsigned long long enemyID);

	bool hasPersonalEnemyFlag(CreatureObject* enemy) const;

	void schedulePersonalEnemyFlagTasks();

	void setHue(int hueIndex);

	int getHueValue() const;

	WeakReference<AuctionSearchTask* > getAuctionSearchTask() const;

	void setAuctionSearchTask(AuctionSearchTask* task);

	WeakReference<CreatureObject*> _this;

	operator const CreatureObject*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	virtual void writeJSON(nlohmann::json& j);
protected:
	virtual ~CreatureObjectImplementation();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class CreatureObject;
};

class CreatureObjectAdapter : public TangibleObjectAdapter {
public:
	CreatureObjectAdapter(CreatureObject* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void initializeMembers();

	void finalize();

	void createChildObjects();

	void initializeTransientMembers();

	void setCountdownTimer(unsigned int newCount, bool notifyClient);

	void clearQueueAction(unsigned int actioncntr, float timer, unsigned int tab1, unsigned int tab2);

	void clearQueueActions(bool combatOnly);

	void sendBaselinesTo(SceneObject* player);

	void sendToOwner(bool doClose);

	void sendSystemMessage(const String& message);

	void playMusicMessage(const String& file);

	void sendNewbieTutorialRequest(const String& request);

	void sendNewbieTutorialEnableHudElement(const String& ui, bool enable, float blinkCount);

	void sendOpenHolocronToPageMessage();

	void sendSystemMessage(UnicodeString& message);

	void sendSlottedObjectsTo(SceneObject* player);

	void setCombatState();

	void clearCombatState(bool clearDefenders);

	void addMountedCombatSlow();

	void removeMountedCombatSlow(bool showEndMessage);

	void setPosture(int newPosture, bool immediate, bool notifyClient);

	void updatePostures(bool immediate);

	float calculateSpeed();

	void updateLocomotion();

	void setHeight(float heigh, bool notifyClient);

	void setAccelerationMultiplierBase(float newMultiplierBase, bool notifyClient);

	void setAccelerationMultiplierMod(float newMultiplierMod, bool notifyClient);

	void setSpeedMultiplierBase(float newMultiplierBase, bool notifyClient);

	void setSpeedMultiplierMod(float newMultiplierMod, bool notifyClient);

	void setTurnScale(float newMultiplierMod, bool notifyClient);

	void setRunSpeed(float newSpeed, bool notifyClient);

	void setCurrentSpeed(float newSpeed);

	void setHAM(int type, int value, bool notifyClient);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction);

	bool hasDamage(int attribute);

	int healDamage(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers);

	int healWound(TangibleObject* healer, int damageType, int damage, bool notifyClient, bool notifyObservers);

	void setBaseHAM(int type, int value, bool notifyClient);

	void setWounds(int type, int value, bool notifyClient);

	int addWounds(int type, int value, bool notifyClient, bool doShockWounds);

	void setMaxHAM(int type, int value, bool notifyClient);

	void addMaxHAM(int type, int value, bool notifyClient);

	void setEncumbrance(int type, int value, bool notifyClient);

	void addEncumbrance(int type, int value, bool notifyClient);

	void setWeapon(WeaponObject* weao, bool notifyClient);

	int notifyObjectInserted(SceneObject* object);

	int notifyObjectRemoved(SceneObject* object);

	void setInstrumentID(int instrumentid, bool notifyClient);

	void setListenToID(unsigned long long id, bool notifyClient);

	void setPerformanceCounter(int counter, bool notifyClient);

	void setPerformanceAnimation(const String& animation, bool notifyClient);

	void setShockWounds(int newShock, bool notifyClient);

	void addShockWounds(int shockToAdd, bool notiyClient, bool sendSpam);

	void setTargetID(unsigned long long targetID, bool notifyClient);

	void setBankCredits(int credits, bool notifyClient);

	void addBuff(Buff* buff);

	bool removeBuff(unsigned int buffcrc);

	void removeBuff(Buff* buff);

	bool removeStateBuff(unsigned long long state);

	void clearBuffs(bool updateclient, bool removeAll);

	void renewBuff(unsigned int buffCRC, int duration, bool sendToClient);

	void updateVehiclePosition(bool sendPackets);

	void addWearableObject(TangibleObject* object, bool notifyClient);

	void removeWearableObject(TangibleObject* object, bool notifyClient);

	void sendBuffsTo(CreatureObject* creature);

	Buff* getBuff(unsigned int buffcrc);

	long long getSkillModFromBuffs(const String& skillMod);

	int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength);

	bool healDot(unsigned long long dotType, int reduction, bool sendMsg);

	void clearDots();

	bool hasBuff(unsigned int buffcrc);

	void notifySelfPositionUpdate();

	void notifyPostureChange(int newPosture);

	void setLevel(int level, bool randomHam);

	void updateToDatabaseAllObjects(bool startTask);

	bool isResuscitable();

	void addBankCredits(int credits, bool notifyClient);

	void addCashCredits(int credits, bool notifyClient);

	CreditObject* getCreditObject();

	void subtractBankCredits(int credits);

	void subtractCashCredits(int credits);

	bool verifyCashCredits(int credits);

	bool verifyBankCredits(int credits);

	bool isDancing();

	bool isPlayingMusic();

	void stopEntertaining();

	bool isEntertaining();

	void setCashCredits(int credits, bool notifyClient);

	void setTerrainNegotiation(float value, bool notifyClient);

	void updateTerrainNegotiation();

	void addSkill(const String& skill, bool notifyClient);

	void removeSkill(const String& skill, bool notifyClient);

	void addSkillMod(const int modType, const String& skillMod, int value, bool notifyClient);

	void removeSkillMod(const int modType, const String& skillMod, int value, bool notifyClient);

	void removeAllSkillModsOfType(const int modType, bool notifyClient);

	void updateGroupInviterID(unsigned long long id, bool notifyClient);

	void updateGroup(GroupObject* group, bool notifyClient);

	void enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long long targetID, const UnicodeString& arguments, int priority, int compareCount);

	void sendCommand(unsigned int crc, const UnicodeString& args, unsigned long long targetID, int priority);

	void sendCommand(const String& action, const UnicodeString& args, unsigned long long targetID, int priority);

	void setMood(byte moodID, bool notifyClient);

	void setMoodString(const String& animation, bool notifyClient);

	void deleteQueueAction(unsigned int actionCount);

	bool setState(unsigned long long state, bool notifyClient);

	void setAlternateAppearance(const String& appearanceTeamplate, bool notifyClient);

	bool clearState(unsigned long long state, bool notifyClient);

	void setControlDevice(ControlDevice* device);

	void setCreatureLink(CreatureObject* object, bool notifyClient);

	void executeObjectControllerAction(unsigned int actionCRC);

	void executeObjectControllerAction(unsigned int actionCRC, unsigned long long targetID, const UnicodeString& args);

	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(CreatureObject* object, bool bypassDeadCheck);

	bool isAttackableBy(TangibleObject* attacker);

	bool isAttackableBy(TangibleObject* object, bool bypassDeadCheck);

	bool isHealableBy(CreatureObject* object);

	bool hasBountyMissionFor(CreatureObject* target);

	bool sendConversationStartTo(SceneObject* player);

	void selectConversationOption(int option, SceneObject* obj);

	void sendStateCombatSpam(const String& fileName, const String& stringName, byte color, int damage, bool broadcast);

	void sendCustomCombatSpam(const UnicodeString& customString, byte color);

	void sendExecuteConsoleCommand(const String& command);

	bool isAggressiveTo(CreatureObject* object);

	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	int notifyObjectKillObservers(TangibleObject* killer);

	void notifyLoadFromDatabase();

	void destroyObjectFromDatabase(bool destroyContainedObjects);

	void setFactionRank(int rank, bool notifyClient);

	String getFirstName();

	String setFirstName(const String& newFirstName);

	String getLastName();

	String setLastName(const String& newLastName, bool skipVerify);

	String setLastName(const String& newLastName);

	bool isOnline();

	bool canTreatInjuries();

	bool canTreatStates();

	bool canTreatWounds();

	bool canTreatConditions();

	Reference<PlayerObject* > getPlayerObject();

	bool isListening() const;

	bool isWatching() const;

	void setClient(ZoneClientSession* cli);

	void dismount();

	float calculateBFRatio();

	void removeFeignedDeath();

	bool canFeignDeath();

	void feignDeath();

	void setFeignedDeathState();

	void setDizziedState(int durationSeconds);

	void setRalliedState(int durationSeconds);

	void setAimingState(int durationSeconds);

	void setCoverState(int durationSeconds);

	void setBerserkedState(unsigned int duration);

	void setStunnedState(int durationSeconds);

	void setBlindedState(int durationSeconds);

	void setIntimidatedState(int durationSeconds);

	void setSnaredState(int durationSeconds);

	void setRootedState(int durationSeconds);

	bool setNextAttackDelay(unsigned int mod, int del);

	void setMeditateState();

	void activateHAMRegeneration(int latency);

	void activatePassiveWoundRegeneration();

	void activateStateRecovery();

	void updateTimeOfDeath();

	bool hasAttackDelay();

	void removeAttackDelay();

	bool hasIncapTimer();

	bool hasSpice();

	void updateLastSuccessfulCombatAction();

	void updatePostureChangeDelay(unsigned long long delay);

	bool checkPostureChangeDelay();

	void updatePostureDownRecovery();

	bool checkPostureDownRecovery();

	void updatePostureUpRecovery();

	bool checkPostureUpRecovery();

	void updateKnockdownRecovery();

	bool checkKnockdownRecovery();

	void updateGroupMFDPositions();

	void queueDizzyFallEvent();

	bool hasDizzyEvent();

	void clearDizzyEvent();

	unsigned long long getScreenPlayState(const String& screenPlay);

	void setScreenPlayState(const String& screenPlay, unsigned long long state);

	void updateCooldownTimer(const String& coooldownTimer, unsigned long long miliSecondsToAdd);

	bool checkCooldownRecovery(const String& cooldown);

	void addCooldown(const String& name, unsigned long long miliseconds);

	void doAnimation(const String& animation);

	void doCombatAnimation(TangibleObject* defender, unsigned int animationCRC, byte hit, byte trails, unsigned long long weaponID);

	void doCombatAnimation(unsigned int animationCRC);

	void activateQueueAction();

	void activateImmediateAction();

	UnicodeString getCreatureName();

	bool isGrouped() const;

	int getBankCredits() const;

	int getCashCredits() const;

	int getBaseHAM(int idx) const;

	int getWounds(int idx) const;

	int getHAM(int idx) const;

	int getMaxHAM(int idx) const;

	int getEncumbrance(int idx) const;

	byte getPosture() const;

	byte getLocomotion() const;

	byte getFactionRank() const;

	ManagedWeakReference<CreatureObject* > getLinkedCreature() const;

	unsigned long long getCreatureLinkID() const;

	float getShockWounds() const;

	unsigned long long getWatchToID() const;

	unsigned long long getStateBitmask() const;

	bool hasState(unsigned long long state) const;

	bool hasStates() const;

	unsigned long long getListenID() const;

	float getAccelerationMultiplierBase() const;

	float getAccelerationMultiplierMod() const;

	float getSpeedMultiplierBase() const;

	float getSpeedMultiplierMod() const;

	float getCurrentSpeed() const;

	int getCommandQueueSize() const;

	void setLastActionCounter(unsigned int ctr);

	unsigned int incrementLastActionCounter();

	unsigned int getLastActionCounter();

	float getRunSpeed() const;

	float getWalkSpeed() const;

	float getTurnScale() const;

	float getTerrainNegotiation() const;

	float getRunAcceleration() const;

	float getWalkAcceleration() const;

	String getPerformanceAnimation() const;

	String getMoodString() const;

	unsigned long long getWeaponID() const;

	Reference<WeaponObject* > getWeapon();

	ManagedWeakReference<GuildObject* > getGuildObject() const;

	int getGuildID() const;

	bool isInGuild() const;

	void setGuildObject(GuildObject* guildobj);

	unsigned long long getGroupID() const;

	unsigned long long getGroupInviterID() const;

	Reference<GroupObject* > getGroup() const;

	unsigned long long getGroupInviteCounter() const;

	unsigned long long getTargetID() const;

	byte getMoodID() const;

	float getSlopeModPercent() const;

	int getPerformanceCounter() const;

	int getInstrumentID() const;

	byte getFrozen() const;

	float getHeight() const;

	bool isDroidSpecies();

	bool isWalkerSpecies();

	bool isProbotSpecies();

	bool hasEffectImmunity(byte effectType);

	bool hasDotImmunity(unsigned int dotType);

	int getSpecies() const;

	String getSpeciesName() const;

	int getGender() const;

	int getSkillMod(const String& skillmod) const;

	int getSkillModOfType(const String& skillmod, unsigned const int modType);

	bool hasSkill(const String& skill) const;

	void setWatchToID(unsigned long long id);

	bool isCreatureObject();

	bool isNextActionPast();

	bool isSwimming() const;

	Reference<ZoneClientSession* > getClient();

	ManagedWeakReference<ControlDevice* > getControlDevice() const;

	float getSwimHeight() const;

	bool isIncapacitated() const;

	bool isDead() const;

	bool isKnockedDown() const;

	bool isKneeling() const;

	bool isProne() const;

	bool isStanding() const;

	bool isSitting() const;

	bool isSkillAnimating() const;

	bool isRallied() const;

	bool isInCombat() const;

	bool isDizzied() const;

	bool isBerserked() const;

	bool isStunned() const;

	bool isBlinded() const;

	bool isIntimidated() const;

	bool isSnared() const;

	bool isImmobilized() const;

	bool isRooted() const;

	bool isFrozen() const;

	bool isDiseased() const;

	bool isPoisoned() const;

	bool isBleeding() const;

	bool isOnFire() const;

	bool isFeigningDeath() const;

	bool isRidingMount() const;

	bool hasRidingCreature() const;

	bool isPeaced() const;

	bool isMeditating() const;

	bool isAiming() const;

	bool isInCover() const;

	bool isRunning() const;

	bool isNonPlayerCreatureObject();

	bool isDroidObject();

	bool isPlayerCreature();

	int getReceiverFlags();

	bool isInformantCreature();

	CampSiteActiveArea* getCurrentCamp();

	byte getCurrentWeather() const;

	void setCurrentWeather(byte value);

	byte getCurrentWind() const;

	void setCurrentWind(byte value);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	String getAlternateAppearance() const;

	float calculateCostAdjustment(byte stat, float baseCost);

	void updateSpeedAndAccelerationMods();

	void setFaction(unsigned int crc);

	void destroyPlayerCreatureFromDatabase(bool destroyContainedObjects);

	float getTemplateRadius();

	void reloadTemplate();

	void removeOutOfRangeObjects();

	void synchronizeCloseObjects();

	void addPersonalEnemyFlag(CreatureObject* enemy, unsigned long long duration);

	unsigned long long getPersonalEnemyFlagTime(unsigned long long enemyID) const;

	void removePersonalEnemyFlag(CreatureObject* enemy);

	void removePersonalEnemyFlag(unsigned long long enemyID);

	bool hasPersonalEnemyFlag(CreatureObject* enemy) const;

	void schedulePersonalEnemyFlagTasks();

	void setHue(int hueIndex);

	int getHueValue() const;

};

class CreatureObjectHelper : public DistributedObjectClassHelper, public Singleton<CreatureObjectHelper> {
	static CreatureObjectHelper* staticInitializer;

public:
	CreatureObjectHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<CreatureObjectHelper>;
};

class MockCreatureObject : public CreatureObject {
public:

	MOCK_METHOD0(getWorldPositionX,float());
	MOCK_METHOD0(getWorldPositionY,float());
	MOCK_METHOD0(getWorldPositionZ,float());
	MOCK_METHOD0(getWorldPosition,Vector3());

};

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObjectPOD : public TangibleObjectPOD {
public:
	Optional<ManagedReference<CreditObjectPOD* >> creditObject;

	Optional<int> bankCredits;

	Optional<int> cashCredits;

	Optional<int> hueValue;

	Optional<DeltaVector<int>> baseHAM;

	Optional<byte> posture;

	Optional<byte> locomotion;

	Optional<byte> factionRank;

	Optional<ManagedWeakReference<CreatureObjectPOD* >> linkedCreature;

	Optional<ManagedWeakReference<ControlDevicePOD* >> controlDevice;

	Optional<float> shockWounds;

	Optional<DeltaVector<int>> wounds;

	Optional<unsigned long long> stateBitmask;

	Optional<DeltaVector<int>> encumbrances;

	Optional<WearablesDeltaVector> wearablesVector;

	Optional<float> accelerationMultiplierBase;

	Optional<float> accelerationMultiplierMod;

	Optional<float> speedMultiplierBase;

	Optional<SpeedMultiplierModChanges> speedMultiplierModChanges;

	Optional<float> speedMultiplierMod;

	Optional<float> turnScale;

	Optional<float> runSpeed;

	Optional<float> walkSpeed;

	Optional<float> currentSpeed;

	Optional<float> terrainNegotiation;

	Optional<float> runAcceleration;

	Optional<float> walkAcceleration;

	Optional<float> height;

	Optional<float> swimHeight;

	Optional<float> slopeModPercent;

	Optional<float> slopeModAngle;

	Optional<unsigned long long> listenToID;

	Optional<unsigned long long> watchToID;

	Optional<String> performanceAnimation;

	Optional<String> moodString;

	Optional<ManagedReference<WeaponObjectPOD* >> weapon;

	Optional<ManagedReference<GroupObjectPOD* >> group;

	Optional<unsigned long long> groupInviterID;

	Optional<unsigned long long> groupInviteCounter;

	Optional<ManagedWeakReference<GuildObjectPOD* >> guild;

	Optional<unsigned long long> targetID;

	Optional<byte> moodID;

	Optional<int> performanceCounter;

	Optional<int> instrumentID;

	Optional<DeltaVector<int>> hamList;

	Optional<DeltaVector<int>> maxHamList;

	Optional<byte> frozen;

	Optional<String> templateString;

	Optional<SkillList> skillList;

	Optional<SkillModList> skillModList;

	Optional<Time> nextAction;

	Optional<BuffList> creatureBuffs;

	Optional<DamageOverTimeList> damageOverTimeList;

	Optional<Time> lastSuccessfulCombatAction;

	Optional<Time> timeOfDeath;

	Optional<VectorMap<String, unsigned long long>> screenPlayStates;

	Optional<SynchronizedVectorMap<unsigned long long, unsigned long long>> personalEnemyFlags;

	String _className;
	CreatureObjectPOD();
	virtual void writeJSON(nlohmann::json& j);
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~CreatureObjectPOD();

};

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

#endif /*CREATUREOBJECTPOD_H_*/
