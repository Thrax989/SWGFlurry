/*
 *	autogen/server/zone/objects/cell/CellObject.h generated by engine3 IDL compiler 0.70
 */

#ifndef CELLOBJECT_H_
#define CELLOBJECT_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace zone {
namespace objects {
namespace creature {

class CreatureObject;

class CreatureObjectPOD;

} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature;

namespace server {
namespace zone {
namespace objects {
namespace building {

class BuildingObject;

class BuildingObjectPOD;

} // namespace building
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::building;

#include "engine/lua/Luna.h"

#include "server/zone/objects/scene/variables/ContainerPermissions.h"

#include "templates/SharedObjectTemplate.h"

#include "system/thread/atomic/AtomicInteger.h"

#include "engine/log/Logger.h"

#include "server/zone/objects/scene/SceneObject.h"

namespace server {
namespace zone {
namespace objects {
namespace cell {

class CellObject : public SceneObject {
public:
	CellObject();

	void loadTemplateData(SharedObjectTemplate* templateData);

	void setAllowEntryPermissionGroup(const String& group);

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	void onContainerLoaded();

	bool hasForceLoadObject() const;

	void onBuildingInsertedToZone(BuildingObject* building);

	/**
	 * Sends the contained non slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the container objects }
	 * @param player SceneObject that will receive the objects
	 */
	void sendContainerObjectsTo(SceneObject* player, bool forceLoad);

	void sendPermissionsTo(CreatureObject* object, bool allowEntry);

	/**
	 * Evaluates if this object has the necessary free slots to be able to add the specified SceneObject
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be checked
	 * @param error error string that the player will receive on error
	 * @return returns 0 on success, or error code
	 */
	int canAddObject(SceneObject* object, int containmentType, String& errorDescription);

	/**
	 * Tries to add/link object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be added to the current object
	 * @param containmentType arrangement type that will be used to add the object
	 * @param notifyClient if true in range objects will be updated with the change
	 * @return returns true if the object has been successfully added
	 */
	bool transferObject(SceneObject* object, int containmentType, bool notifyClient = false, bool allowOverflow = false, bool notifyRoot = true);

	/**
	 * Tries to remove/unlink object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be removed from the current object
	 * @param destination SceneObject that will be the new destination of the object.
	 * @param notifyClient not used currently
	 * @return returns true if the object has been successfully removed
	 */
	bool removeObject(SceneObject* object, SceneObject* destination, bool notifyClient = false);

	void initializeTransientMembers();

	void sendBaselinesTo(SceneObject* player);

	int getCurrentNumberOfPlayerItems();

	/**
	 * This method loops through all items in the cell and attempts to destroy them from the database.
	 */
	void destroyAllPlayerItems();

	int getCellNumber() const;

	void setCellNumber(int number);

	bool isCellObject();

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	CellObject(DummyConstructorParameter* param);

	virtual ~CellObject();

	friend class CellObjectHelper;
};

} // namespace cell
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::cell;

namespace server {
namespace zone {
namespace objects {
namespace cell {

class CellObjectImplementation : public SceneObjectImplementation {
protected:
	int cellNumber;

	AtomicInteger forceLoadObjectCount;

public:
	CellObjectImplementation();

	CellObjectImplementation(DummyConstructorParameter* param);

	void loadTemplateData(SharedObjectTemplate* templateData);

	void setAllowEntryPermissionGroup(const String& group);

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	void onContainerLoaded();

	bool hasForceLoadObject() const;

	void onBuildingInsertedToZone(BuildingObject* building);

	/**
	 * Sends the contained non slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the container objects }
	 * @param player SceneObject that will receive the objects
	 */
	void sendContainerObjectsTo(SceneObject* player, bool forceLoad);

	void sendPermissionsTo(CreatureObject* object, bool allowEntry);

	/**
	 * Evaluates if this object has the necessary free slots to be able to add the specified SceneObject
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be checked
	 * @param error error string that the player will receive on error
	 * @return returns 0 on success, or error code
	 */
	int canAddObject(SceneObject* object, int containmentType, String& errorDescription);

	/**
	 * Tries to add/link object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be added to the current object
	 * @param containmentType arrangement type that will be used to add the object
	 * @param notifyClient if true in range objects will be updated with the change
	 * @return returns true if the object has been successfully added
	 */
	bool transferObject(SceneObject* object, int containmentType, bool notifyClient = false, bool allowOverflow = false, bool notifyRoot = true);

	/**
	 * Tries to remove/unlink object
	 * @pre { this object is locked, object is locked }
	 * @post {this object is locked, object is locked }
	 * @param object SceneObject that will be removed from the current object
	 * @param destination SceneObject that will be the new destination of the object.
	 * @param notifyClient not used currently
	 * @return returns true if the object has been successfully removed
	 */
	bool removeObject(SceneObject* object, SceneObject* destination, bool notifyClient = false);

	void initializeTransientMembers();

	void sendBaselinesTo(SceneObject* player);

	int getCurrentNumberOfPlayerItems();

	/**
	 * This method loops through all items in the cell and attempts to destroy them from the database.
	 */
	void destroyAllPlayerItems();

	int getCellNumber() const;

	void setCellNumber(int number);

	bool isCellObject();

	WeakReference<CellObject*> _this;

	operator const CellObject*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	virtual void writeJSON(nlohmann::json& j);
protected:
	virtual ~CellObjectImplementation();

	void finalize();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class CellObject;
};

class CellObjectAdapter : public SceneObjectAdapter {
public:
	CellObjectAdapter(CellObject* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void setAllowEntryPermissionGroup(const String& group);

	void notifyLoadFromDatabase();

	void onContainerLoaded();

	bool hasForceLoadObject() const;

	void onBuildingInsertedToZone(BuildingObject* building);

	void sendContainerObjectsTo(SceneObject* player, bool forceLoad);

	void sendPermissionsTo(CreatureObject* object, bool allowEntry);

	int canAddObject(SceneObject* object, int containmentType, String& errorDescription);

	bool transferObject(SceneObject* object, int containmentType, bool notifyClient, bool allowOverflow, bool notifyRoot);

	bool removeObject(SceneObject* object, SceneObject* destination, bool notifyClient);

	void initializeTransientMembers();

	void sendBaselinesTo(SceneObject* player);

	int getCurrentNumberOfPlayerItems();

	void destroyAllPlayerItems();

	int getCellNumber() const;

	void setCellNumber(int number);

	bool isCellObject();

};

class CellObjectHelper : public DistributedObjectClassHelper, public Singleton<CellObjectHelper> {
	static CellObjectHelper* staticInitializer;

public:
	CellObjectHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<CellObjectHelper>;
};

class LuaCellObject {
public:
	static const char className[];
	static Luna<LuaCellObject>::RegType Register[];

	LuaCellObject(lua_State *L);
	virtual ~LuaCellObject();

	int _setObject(lua_State *L);
	int _getObject(lua_State *L);
	int loadTemplateData(lua_State *L);
	int setAllowEntryPermissionGroup(lua_State *L);
	int notifyLoadFromDatabase(lua_State *L);
	int onContainerLoaded(lua_State *L);
	int hasForceLoadObject(lua_State *L);
	int onBuildingInsertedToZone(lua_State *L);
	int sendContainerObjectsTo(lua_State *L);
	int sendPermissionsTo(lua_State *L);
	int canAddObject(lua_State *L);
	int transferObject(lua_State *L);
	int removeObject(lua_State *L);
	int initializeTransientMembers(lua_State *L);
	int sendBaselinesTo(lua_State *L);
	int getCurrentNumberOfPlayerItems(lua_State *L);
	int destroyAllPlayerItems(lua_State *L);
	int getCellNumber(lua_State *L);
	int setCellNumber(lua_State *L);
	int isCellObject(lua_State *L);

	Reference<CellObject*> realObject;
};

} // namespace cell
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::cell;

namespace server {
namespace zone {
namespace objects {
namespace cell {

class CellObjectPOD : public SceneObjectPOD {
public:
	Optional<int> cellNumber;

	Optional<AtomicInteger> forceLoadObjectCount;

	String _className;
	CellObjectPOD();
	virtual void writeJSON(nlohmann::json& j);
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~CellObjectPOD();

};

} // namespace cell
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::cell;

#endif /*CELLOBJECTPOD_H_*/
