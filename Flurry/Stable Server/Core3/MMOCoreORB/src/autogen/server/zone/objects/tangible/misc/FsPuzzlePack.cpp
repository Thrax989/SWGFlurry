/*
 *	autogen/server/zone/objects/tangible/misc/FsPuzzlePack.cpp generated by engine3 IDL compiler 0.70
 */

#include "FsPuzzlePack.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/objects/creature/CreatureObject.h"

/*
 *	FsPuzzlePackStub
 */

enum {RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_GETCURESYMPTOMONE__,RPC_GETCURESYMPTOMTWO__,RPC_GETGIVESYMPTOMONE__,RPC_ISFSPUZZLEPACK__};

FsPuzzlePack::FsPuzzlePack() : TangibleObject(DummyConstructorParameter::instance()) {
	FsPuzzlePackImplementation* _implementation = new FsPuzzlePackImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("FsPuzzlePack");
}

FsPuzzlePack::FsPuzzlePack(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("FsPuzzlePack");
}

FsPuzzlePack::~FsPuzzlePack() {
}



void FsPuzzlePack::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	FsPuzzlePackImplementation* _implementation = static_cast<FsPuzzlePackImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updateCraftingValues(values, firstUpdate);
	}
}

void FsPuzzlePack::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	FsPuzzlePackImplementation* _implementation = static_cast<FsPuzzlePackImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

int FsPuzzlePack::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	FsPuzzlePackImplementation* _implementation = static_cast<FsPuzzlePackImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

int FsPuzzlePack::getCureSymptomOne() {
	FsPuzzlePackImplementation* _implementation = static_cast<FsPuzzlePackImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURESYMPTOMONE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCureSymptomOne();
	}
}

int FsPuzzlePack::getCureSymptomTwo() {
	FsPuzzlePackImplementation* _implementation = static_cast<FsPuzzlePackImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURESYMPTOMTWO__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCureSymptomTwo();
	}
}

int FsPuzzlePack::getGiveSymptomOne() {
	FsPuzzlePackImplementation* _implementation = static_cast<FsPuzzlePackImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETGIVESYMPTOMONE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getGiveSymptomOne();
	}
}

bool FsPuzzlePack::isFsPuzzlePack() {
	FsPuzzlePackImplementation* _implementation = static_cast<FsPuzzlePackImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFSPUZZLEPACK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFsPuzzlePack();
	}
}

DistributedObjectServant* FsPuzzlePack::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* FsPuzzlePack::_getImplementationForRead() const {
	return _impl;
}

void FsPuzzlePack::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	FsPuzzlePackImplementation
 */

FsPuzzlePackImplementation::FsPuzzlePackImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


FsPuzzlePackImplementation::~FsPuzzlePackImplementation() {
}


void FsPuzzlePackImplementation::finalize() {
}

void FsPuzzlePackImplementation::_initializeImplementation() {
	_setClassHelper(FsPuzzlePackHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void FsPuzzlePackImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<FsPuzzlePack*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* FsPuzzlePackImplementation::_getStub() {
	return _this.get();
}

FsPuzzlePackImplementation::operator const FsPuzzlePack*() {
	return _this.get();
}

void FsPuzzlePackImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void FsPuzzlePackImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void FsPuzzlePackImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void FsPuzzlePackImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void FsPuzzlePackImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void FsPuzzlePackImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void FsPuzzlePackImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void FsPuzzlePackImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("FsPuzzlePack");

}

void FsPuzzlePackImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(FsPuzzlePackImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool FsPuzzlePackImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xf009cd30: //FsPuzzlePack.cureSymptomOne
		TypeInfo<int >::parseFromBinaryStream(&cureSymptomOne, stream);
		return true;

	case 0x86a55bba: //FsPuzzlePack.cureSymptomTwo
		TypeInfo<int >::parseFromBinaryStream(&cureSymptomTwo, stream);
		return true;

	case 0xb6b03921: //FsPuzzlePack.giveSymptomOne
		TypeInfo<int >::parseFromBinaryStream(&giveSymptomOne, stream);
		return true;

	}

	return false;
}

void FsPuzzlePackImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = FsPuzzlePackImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int FsPuzzlePackImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xf009cd30; //FsPuzzlePack.cureSymptomOne
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&cureSymptomOne, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x86a55bba; //FsPuzzlePack.cureSymptomTwo
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&cureSymptomTwo, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb6b03921; //FsPuzzlePack.giveSymptomOne
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&giveSymptomOne, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void FsPuzzlePackImplementation::writeJSON(nlohmann::json& j) {
	TangibleObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["cureSymptomOne"] = cureSymptomOne;

	thisObject["cureSymptomTwo"] = cureSymptomTwo;

	thisObject["giveSymptomOne"] = giveSymptomOne;

	j["FsPuzzlePack"] = thisObject;
}

FsPuzzlePackImplementation::FsPuzzlePackImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		setLoggingName("FsPuzzlePack");
	setLoggingName("FsPuzzlePack");
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		cureSymptomOne = -1;
	cureSymptomOne = -1;
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		cureSymptomTwo = -1;
	cureSymptomTwo = -1;
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		giveSymptomOne = -1;
	giveSymptomOne = -1;
}

void FsPuzzlePackImplementation::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		cureSymptomOne = (int)values.getCurrentValue("curesymptomone");
	cureSymptomOne = (int) values->getCurrentValue("curesymptomone");
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		cureSymptomTwo = (int)values.getCurrentValue("curesymptomtwo");
	cureSymptomTwo = (int) values->getCurrentValue("curesymptomtwo");
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		giveSymptomOne = (int)values.getCurrentValue("givesymptomone");
	giveSymptomOne = (int) values->getCurrentValue("givesymptomone");
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		if 
	if (cureSymptomOne == cureSymptomTwo)	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  			cureSymptomTwo = -1;
	cureSymptomTwo = -1;
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  	}
	if (giveSymptomOne == cureSymptomOne || giveSymptomOne == cureSymptomTwo)	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  			giveSymptomOne = -1;
	giveSymptomOne = -1;
}

void FsPuzzlePackImplementation::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		super.fillAttributeList(msg, object);
	TangibleObjectImplementation::fillAttributeList(msg, object);
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		msg.insertAttribute("fs_medic_pack_cure_one", "@quest/force_sensitive/fs_medic:symptom" + String.valueOf(cureSymptomOne));
	msg->insertAttribute("fs_medic_pack_cure_one", "@quest/force_sensitive/fs_medic:symptom" + String::valueOf(cureSymptomOne));
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		if 
	if (cureSymptomTwo >= 0)	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  			msg.insertAttribute("fs_medic_pack_cure_two", "@quest/force_sensitive/fs_medic:symptom" + String.valueOf(cureSymptomTwo));
	msg->insertAttribute("fs_medic_pack_cure_two", "@quest/force_sensitive/fs_medic:symptom" + String::valueOf(cureSymptomTwo));
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  	}
	if (giveSymptomOne >= 0)	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  			msg.insertAttribute("fs_medic_pack_symptom_one", "@quest/force_sensitive/fs_medic:symptom" + String.valueOf(giveSymptomOne));
	msg->insertAttribute("fs_medic_pack_symptom_one", "@quest/force_sensitive/fs_medic:symptom" + String::valueOf(giveSymptomOne));
}

int FsPuzzlePackImplementation::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		return 
	if (!isASubChildOf(player))	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  			return 0;
	return 0;
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		return 1;
	return 1;
}

int FsPuzzlePackImplementation::getCureSymptomOne() {
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		return cureSymptomOne;
	return cureSymptomOne;
}

int FsPuzzlePackImplementation::getCureSymptomTwo() {
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		return cureSymptomTwo;
	return cureSymptomTwo;
}

int FsPuzzlePackImplementation::getGiveSymptomOne() {
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		return giveSymptomOne;
	return giveSymptomOne;
}

bool FsPuzzlePackImplementation::isFsPuzzlePack() {
	// server/zone/objects/tangible/misc/FsPuzzlePack.idl():  		return true;
	return true;
}

/*
 *	FsPuzzlePackAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


FsPuzzlePackAdapter::FsPuzzlePackAdapter(FsPuzzlePack* obj) : TangibleObjectAdapter(obj) {
}

void FsPuzzlePackAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte selectedID = inv->getByteParameter();
			
			int _m_res = handleObjectMenuSelect(player, selectedID);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCURESYMPTOMONE__:
		{
			
			int _m_res = getCureSymptomOne();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCURESYMPTOMTWO__:
		{
			
			int _m_res = getCureSymptomTwo();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETGIVESYMPTOMONE__:
		{
			
			int _m_res = getGiveSymptomOne();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISFSPUZZLEPACK__:
		{
			
			bool _m_res = isFsPuzzlePack();
			resp->insertBoolean(_m_res);
		}
		break;
	default:
		TangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

int FsPuzzlePackAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<FsPuzzlePack*>(stub))->handleObjectMenuSelect(player, selectedID);
}

int FsPuzzlePackAdapter::getCureSymptomOne() {
	return (static_cast<FsPuzzlePack*>(stub))->getCureSymptomOne();
}

int FsPuzzlePackAdapter::getCureSymptomTwo() {
	return (static_cast<FsPuzzlePack*>(stub))->getCureSymptomTwo();
}

int FsPuzzlePackAdapter::getGiveSymptomOne() {
	return (static_cast<FsPuzzlePack*>(stub))->getGiveSymptomOne();
}

bool FsPuzzlePackAdapter::isFsPuzzlePack() {
	return (static_cast<FsPuzzlePack*>(stub))->isFsPuzzlePack();
}

/*
 *	FsPuzzlePackHelper
 */

FsPuzzlePackHelper* FsPuzzlePackHelper::staticInitializer = FsPuzzlePackHelper::instance();

FsPuzzlePackHelper::FsPuzzlePackHelper() {
	className = "FsPuzzlePack";

	Core::getObjectBroker()->registerClass(className, this);
}

void FsPuzzlePackHelper::finalizeHelper() {
	FsPuzzlePackHelper::finalize();
}

DistributedObject* FsPuzzlePackHelper::instantiateObject() {
	return new FsPuzzlePack(DummyConstructorParameter::instance());
}

DistributedObjectServant* FsPuzzlePackHelper::instantiateServant() {
	return new FsPuzzlePackImplementation();
}

DistributedObjectPOD* FsPuzzlePackHelper::instantiatePOD() {
	return new FsPuzzlePackPOD();
}

DistributedObjectAdapter* FsPuzzlePackHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new FsPuzzlePackAdapter(static_cast<FsPuzzlePack*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

const char LuaFsPuzzlePack::className[] = "LuaFsPuzzlePack";

Luna<LuaFsPuzzlePack>::RegType LuaFsPuzzlePack::Register[] = {
	{ "_setObject", &LuaFsPuzzlePack::_setObject },
	{ "_getObject", &LuaFsPuzzlePack::_getObject },
	{ "updateCraftingValues", &LuaFsPuzzlePack::updateCraftingValues },
	{ "fillAttributeList", &LuaFsPuzzlePack::fillAttributeList },
	{ "handleObjectMenuSelect", &LuaFsPuzzlePack::handleObjectMenuSelect },
	{ "getCureSymptomOne", &LuaFsPuzzlePack::getCureSymptomOne },
	{ "getCureSymptomTwo", &LuaFsPuzzlePack::getCureSymptomTwo },
	{ "getGiveSymptomOne", &LuaFsPuzzlePack::getGiveSymptomOne },
	{ "isFsPuzzlePack", &LuaFsPuzzlePack::isFsPuzzlePack },
	{ 0, 0 }
};

LuaFsPuzzlePack::LuaFsPuzzlePack(lua_State *L) {
	realObject = static_cast<FsPuzzlePack*>(lua_touserdata(L, 1));
}

LuaFsPuzzlePack::~LuaFsPuzzlePack() {
}

int LuaFsPuzzlePack::_setObject(lua_State* L) {
	realObject = static_cast<FsPuzzlePack*>(lua_touserdata(L, -1));

	return 0;
}

int LuaFsPuzzlePack::_getObject(lua_State* L) {
	lua_pushlightuserdata(L, realObject.get());

	return 1;
}

int LuaFsPuzzlePack::updateCraftingValues(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isboolean(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				CraftingValues* values = static_cast<CraftingValues*>(lua_touserdata(L, -2));
				bool firstUpdate = lua_toboolean(L, -1);

				realObject->updateCraftingValues(values, firstUpdate);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'FsPuzzlePack:updateCraftingValues(userdata, boolean)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'FsPuzzlePack:updateCraftingValues(userdata, boolean)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'FsPuzzlePack:updateCraftingValues(userdata, boolean)'");
	}
	return 0;
}

int LuaFsPuzzlePack::fillAttributeList(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isuserdata(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				AttributeListMessage* msg = static_cast<AttributeListMessage*>(lua_touserdata(L, -2));
				CreatureObject* object = static_cast<CreatureObject*>(lua_touserdata(L, -1));

				realObject->fillAttributeList(msg, object);

				return 0;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'FsPuzzlePack:fillAttributeList(userdata, userdata)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'FsPuzzlePack:fillAttributeList(userdata, userdata)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'FsPuzzlePack:fillAttributeList(userdata, userdata)'");
	}
	return 0;
}

int LuaFsPuzzlePack::handleObjectMenuSelect(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (lua_isnumber(L, -1)) {
		if (lua_isuserdata(L, -2)) {
			if (parameterCount == 2) {
				CreatureObject* player = static_cast<CreatureObject*>(lua_touserdata(L, -2));
				byte selectedID = lua_tointeger(L, -1);

				int result = realObject->handleObjectMenuSelect(player, selectedID);

				lua_pushinteger(L, result);
				return 1;
			} else {
				throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'FsPuzzlePack:handleObjectMenuSelect(userdata, integer)'");
			}
		} else {
			throw LuaCallbackException(L, "invalid argument at 1 for lua method 'FsPuzzlePack:handleObjectMenuSelect(userdata, integer)'");
		}
	} else {
		throw LuaCallbackException(L, "invalid argument at 0 for lua method 'FsPuzzlePack:handleObjectMenuSelect(userdata, integer)'");
	}
	return 0;
}

int LuaFsPuzzlePack::getCureSymptomOne(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getCureSymptomOne();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'FsPuzzlePack:getCureSymptomOne()'");
	}
	return 0;
}

int LuaFsPuzzlePack::getCureSymptomTwo(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getCureSymptomTwo();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'FsPuzzlePack:getCureSymptomTwo()'");
	}
	return 0;
}

int LuaFsPuzzlePack::getGiveSymptomOne(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		int result = realObject->getGiveSymptomOne();

		lua_pushinteger(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'FsPuzzlePack:getGiveSymptomOne()'");
	}
	return 0;
}

int LuaFsPuzzlePack::isFsPuzzlePack(lua_State *L) {
	int parameterCount = lua_gettop(L) - 1;
	
	if (parameterCount == 0) {
		bool result = realObject->isFsPuzzlePack();

		lua_pushboolean(L, result);
		return 1;
	} else {
		throw LuaCallbackException(L, "invalid argument count " + String::valueOf(parameterCount) + " for lua method 'FsPuzzlePack:isFsPuzzlePack()'");
	}
	return 0;
}

/*
 *	FsPuzzlePackPOD
 */

FsPuzzlePackPOD::~FsPuzzlePackPOD() {
	finalize();
}

FsPuzzlePackPOD::FsPuzzlePackPOD(void) {
	_className = "FsPuzzlePack";
}


void FsPuzzlePackPOD::writeJSON(nlohmann::json& j) {
	TangibleObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (cureSymptomOne)
		thisObject["cureSymptomOne"] = cureSymptomOne.value();

	if (cureSymptomTwo)
		thisObject["cureSymptomTwo"] = cureSymptomTwo.value();

	if (giveSymptomOne)
		thisObject["giveSymptomOne"] = giveSymptomOne.value();

	j["FsPuzzlePack"] = thisObject;
}


void FsPuzzlePackPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = FsPuzzlePackPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int FsPuzzlePackPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (cureSymptomOne) {
	_nameHashCode = 0xf009cd30; //FsPuzzlePack.cureSymptomOne
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&cureSymptomOne.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (cureSymptomTwo) {
	_nameHashCode = 0x86a55bba; //FsPuzzlePack.cureSymptomTwo
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&cureSymptomTwo.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (giveSymptomOne) {
	_nameHashCode = 0xb6b03921; //FsPuzzlePack.giveSymptomOne
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&giveSymptomOne.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool FsPuzzlePackPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xf009cd30: //FsPuzzlePack.cureSymptomOne
		{
			int _mncureSymptomOne;
			TypeInfo<int >::parseFromBinaryStream(&_mncureSymptomOne, stream);
			cureSymptomOne = std::move(_mncureSymptomOne);
		}
		return true;

	case 0x86a55bba: //FsPuzzlePack.cureSymptomTwo
		{
			int _mncureSymptomTwo;
			TypeInfo<int >::parseFromBinaryStream(&_mncureSymptomTwo, stream);
			cureSymptomTwo = std::move(_mncureSymptomTwo);
		}
		return true;

	case 0xb6b03921: //FsPuzzlePack.giveSymptomOne
		{
			int _mngiveSymptomOne;
			TypeInfo<int >::parseFromBinaryStream(&_mngiveSymptomOne, stream);
			giveSymptomOne = std::move(_mngiveSymptomOne);
		}
		return true;

	}

	return false;
}

void FsPuzzlePackPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(FsPuzzlePackPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void FsPuzzlePackPOD::writeObjectCompact(ObjectOutputStream* stream) {
	TangibleObjectPOD::writeObjectCompact(stream);

	TypeInfo<int >::toBinaryStream(&cureSymptomOne.value(), stream);

	TypeInfo<int >::toBinaryStream(&cureSymptomTwo.value(), stream);

	TypeInfo<int >::toBinaryStream(&giveSymptomOne.value(), stream);


}

