/*
 *	autogen/server/zone/objects/area/CampSiteActiveArea.cpp generated by engine3 IDL compiler 0.70
 */

#include "CampSiteActiveArea.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/staticobject/StaticObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/structure/StructureObject.h"

#include "server/zone/objects/tangible/terminal/Terminal.h"

#include "server/zone/objects/area/CampSiteObserver.h"

#include "server/zone/objects/area/events/CampDespawnTask.h"

#include "server/zone/objects/area/events/CampAbandonTask.h"

/*
 *	CampSiteActiveAreaStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 1029739918,RPC_NOTIFYENTER__SCENEOBJECT_,RPC_NOTIFYEXIT__SCENEOBJECT_,RPC_SETTERMINAL__TERMINAL_,RPC_SETOWNER__CREATUREOBJECT_,RPC_SETCAMP__STRUCTUREOBJECT_,RPC_GETCAMP__,RPC_GETMEDICALRATING__,RPC_GETHEALTHWOUNDREGENRATE__,RPC_GETACTIONWOUNDREGENRATE__,RPC_GETMINDWOUNDREGENRATE__,RPC_GETAGGROMOD__,RPC_ISCAMPAREA__,RPC_GETVISITORCOUNT__,RPC_GETUPTIME__,RPC_ISABANDONED__,RPC_NOTIFYHEALEVENT__LONG_,RPC_NOTIFYCOMBATEVENT__,RPC_ABANDONCAMP__,RPC_SETABANDONED__BOOL_,RPC_DESPAWNCAMP__,RPC_ASSUMEOWNERSHIP__CREATUREOBJECT_,RPC_GETOWNER__};

CampSiteActiveArea::CampSiteActiveArea() : ActiveArea(DummyConstructorParameter::instance()) {
	CampSiteActiveAreaImplementation* _implementation = new CampSiteActiveAreaImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("CampSiteActiveArea");
}

CampSiteActiveArea::CampSiteActiveArea(DummyConstructorParameter* param) : ActiveArea(param) {
	_setClassName("CampSiteActiveArea");
}

CampSiteActiveArea::~CampSiteActiveArea() {
}



void CampSiteActiveArea::initializeTransientMembers() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void CampSiteActiveArea::init(CampStructureTemplate* campData) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->init(campData);
	}
}

void CampSiteActiveArea::notifyEnter(SceneObject* player) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYENTER__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyEnter(player);
	}
}

void CampSiteActiveArea::notifyExit(SceneObject* player) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYEXIT__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyExit(player);
	}
}

void CampSiteActiveArea::setTerminal(Terminal* term) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTERMINAL__TERMINAL_);
		method.addObjectParameter(term);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setTerminal(term);
	}
}

void CampSiteActiveArea::setOwner(CreatureObject* player) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOWNER__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setOwner(player);
	}
}

void CampSiteActiveArea::setCamp(StructureObject* c) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCAMP__STRUCTUREOBJECT_);
		method.addObjectParameter(c);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCamp(c);
	}
}

StructureObject* CampSiteActiveArea::getCamp() const {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCAMP__);

		return static_cast<StructureObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getCamp();
	}
}

int CampSiteActiveArea::getMedicalRating() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMEDICALRATING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMedicalRating();
	}
}

int CampSiteActiveArea::getHealthWoundRegenRate() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEALTHWOUNDREGENRATE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHealthWoundRegenRate();
	}
}

int CampSiteActiveArea::getActionWoundRegenRate() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIONWOUNDREGENRATE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getActionWoundRegenRate();
	}
}

int CampSiteActiveArea::getMindWoundRegenRate() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDWOUNDREGENRATE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMindWoundRegenRate();
	}
}

float CampSiteActiveArea::getAggroMod() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAGGROMOD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAggroMod();
	}
}

bool CampSiteActiveArea::isCampArea() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMPAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCampArea();
	}
}

int CampSiteActiveArea::getVisitorCount() const {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVISITORCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getVisitorCount();
	}
}

unsigned int CampSiteActiveArea::getUptime() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETUPTIME__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getUptime();
	}
}

bool CampSiteActiveArea::isAbandoned() const {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISABANDONED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAbandoned();
	}
}

int CampSiteActiveArea::notifyHealEvent(long long quantity) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYHEALEVENT__LONG_);
		method.addSignedLongParameter(quantity);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyHealEvent(quantity);
	}
}

int CampSiteActiveArea::notifyCombatEvent() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYCOMBATEVENT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyCombatEvent();
	}
}

void CampSiteActiveArea::abandonCamp() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ABANDONCAMP__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->abandonCamp();
	}
}

void CampSiteActiveArea::setAbandoned(bool isAbandoned) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETABANDONED__BOOL_);
		method.addBooleanParameter(isAbandoned);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAbandoned(isAbandoned);
	}
}

bool CampSiteActiveArea::despawnCamp() {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESPAWNCAMP__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->despawnCamp();
	}
}

void CampSiteActiveArea::assumeOwnership(CreatureObject* player) {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ASSUMEOWNERSHIP__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->assumeOwnership(player);
	}
}

CreatureObject* CampSiteActiveArea::getOwner() const {
	CampSiteActiveAreaImplementation* _implementation = static_cast<CampSiteActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOWNER__);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getOwner();
	}
}

DistributedObjectServant* CampSiteActiveArea::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* CampSiteActiveArea::_getImplementationForRead() const {
	return _impl;
}

void CampSiteActiveArea::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	CampSiteActiveAreaImplementation
 */

CampSiteActiveAreaImplementation::CampSiteActiveAreaImplementation(DummyConstructorParameter* param) : ActiveAreaImplementation(param) {
	_initializeImplementation();
}


CampSiteActiveAreaImplementation::~CampSiteActiveAreaImplementation() {
}


void CampSiteActiveAreaImplementation::finalize() {
}

void CampSiteActiveAreaImplementation::_initializeImplementation() {
	_setClassHelper(CampSiteActiveAreaHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void CampSiteActiveAreaImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<CampSiteActiveArea*>(stub);
	ActiveAreaImplementation::_setStub(stub);
}

DistributedObjectStub* CampSiteActiveAreaImplementation::_getStub() {
	return _this.get();
}

CampSiteActiveAreaImplementation::operator const CampSiteActiveArea*() {
	return _this.get();
}

void CampSiteActiveAreaImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void CampSiteActiveAreaImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void CampSiteActiveAreaImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void CampSiteActiveAreaImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void CampSiteActiveAreaImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void CampSiteActiveAreaImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void CampSiteActiveAreaImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void CampSiteActiveAreaImplementation::_serializationHelperMethod() {
	ActiveAreaImplementation::_serializationHelperMethod();

	_setClassName("CampSiteActiveArea");

}

void CampSiteActiveAreaImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(CampSiteActiveAreaImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool CampSiteActiveAreaImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ActiveAreaImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x4aeb189c: //CampSiteActiveArea.camp
		TypeInfo<ManagedReference<StructureObject* > >::parseFromBinaryStream(&camp, stream);
		return true;

	case 0x6f2f4a9c: //CampSiteActiveArea.terminal
		TypeInfo<ManagedReference<Terminal* > >::parseFromBinaryStream(&terminal, stream);
		return true;

	case 0x422d5a82: //CampSiteActiveArea.campObserver
		TypeInfo<ManagedReference<CampSiteObserver* > >::parseFromBinaryStream(&campObserver, stream);
		return true;

	case 0x13c34b78: //CampSiteActiveArea.campOwner
		TypeInfo<ManagedReference<CreatureObject* > >::parseFromBinaryStream(&campOwner, stream);
		return true;

	case 0x8a53b98c: //CampSiteActiveArea.campStructureData
		TypeInfo<TemplateReference<CampStructureTemplate*> >::parseFromBinaryStream(&campStructureData, stream);
		return true;

	}

	return false;
}

void CampSiteActiveAreaImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = CampSiteActiveAreaImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int CampSiteActiveAreaImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ActiveAreaImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x4aeb189c; //CampSiteActiveArea.camp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<StructureObject* > >::toBinaryStream(&camp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6f2f4a9c; //CampSiteActiveArea.terminal
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<Terminal* > >::toBinaryStream(&terminal, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x422d5a82; //CampSiteActiveArea.campObserver
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<CampSiteObserver* > >::toBinaryStream(&campObserver, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x13c34b78; //CampSiteActiveArea.campOwner
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<CreatureObject* > >::toBinaryStream(&campOwner, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8a53b98c; //CampSiteActiveArea.campStructureData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<TemplateReference<CampStructureTemplate*> >::toBinaryStream(&campStructureData, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void CampSiteActiveAreaImplementation::writeJSON(nlohmann::json& j) {
	ActiveAreaImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["camp"] = camp;

	thisObject["terminal"] = terminal;

	thisObject["campObserver"] = campObserver;

	thisObject["campOwner"] = campOwner;

	thisObject["campStructureData"] = campStructureData;

	j["CampSiteActiveArea"] = thisObject;
}

CampSiteActiveAreaImplementation::CampSiteActiveAreaImplementation() {
	_initializeImplementation();
	// server/zone/objects/area/CampSiteActiveArea.idl():  		Logger.setLoggingName("CampsiteActiveArea");
	Logger::setLoggingName("CampsiteActiveArea");
	// server/zone/objects/area/CampSiteActiveArea.idl():  		timeCreated = System.getTime();
	timeCreated = System::getTime();
	// server/zone/objects/area/CampSiteActiveArea.idl():  		abandoned = false;
	abandoned = false;
	// server/zone/objects/area/CampSiteActiveArea.idl():  		currentXp = 0;
	currentXp = 0;
	// server/zone/objects/area/CampSiteActiveArea.idl():  		campOwner = null;
	campOwner = NULL;
	// server/zone/objects/area/CampSiteActiveArea.idl():  		camp = null;
	camp = NULL;
	// server/zone/objects/area/CampSiteActiveArea.idl():  		terminal = null;
	terminal = NULL;
	// server/zone/objects/area/CampSiteActiveArea.idl():  		abandonTask = null;
	abandonTask = NULL;
	// server/zone/objects/area/CampSiteActiveArea.idl():  		despawnTask = null;
	despawnTask = NULL;
	// server/zone/objects/area/CampSiteActiveArea.idl():  		campFire = null;
	campFire = NULL;
}

void CampSiteActiveAreaImplementation::setTerminal(Terminal* term) {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		terminal = term;
	terminal = term;
}

void CampSiteActiveAreaImplementation::setCamp(StructureObject* c) {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		camp = c;
	camp = c;
}

StructureObject* CampSiteActiveAreaImplementation::getCamp() const{
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return camp;
	return camp;
}

int CampSiteActiveAreaImplementation::getMedicalRating() {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return campStructureData.get().getMedicalRating();
	return (&campStructureData)->get()->getMedicalRating();
}

int CampSiteActiveAreaImplementation::getHealthWoundRegenRate() {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return campStructureData.get().getHealthWoundRegenRate();
	return (&campStructureData)->get()->getHealthWoundRegenRate();
}

int CampSiteActiveAreaImplementation::getActionWoundRegenRate() {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return campStructureData.get().getActionWoundRegenRate();
	return (&campStructureData)->get()->getActionWoundRegenRate();
}

int CampSiteActiveAreaImplementation::getMindWoundRegenRate() {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return campStructureData.get().getMindWoundRegenRate();
	return (&campStructureData)->get()->getMindWoundRegenRate();
}

float CampSiteActiveAreaImplementation::getAggroMod() {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return campStructureData.get().getAggroMod();
	return (&campStructureData)->get()->getAggroMod();
}

bool CampSiteActiveAreaImplementation::isCampArea() {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return true;
	return true;
}

int CampSiteActiveAreaImplementation::getVisitorCount() const{
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return visitors.size();
	return (&visitors)->size();
}

unsigned int CampSiteActiveAreaImplementation::getUptime() {
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return System.getTime() - timeCreated;
	return System::getTime() - timeCreated;
}

bool CampSiteActiveAreaImplementation::isAbandoned() const{
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return abandoned;
	return abandoned;
}

CreatureObject* CampSiteActiveAreaImplementation::getOwner() const{
	// server/zone/objects/area/CampSiteActiveArea.idl():  		return campOwner;
	return campOwner;
}

/*
 *	CampSiteActiveAreaAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


CampSiteActiveAreaAdapter::CampSiteActiveAreaAdapter(CampSiteActiveArea* obj) : ActiveAreaAdapter(obj) {
}

void CampSiteActiveAreaAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_NOTIFYENTER__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyEnter(player);
			
		}
		break;
	case RPC_NOTIFYEXIT__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyExit(player);
			
		}
		break;
	case RPC_SETTERMINAL__TERMINAL_:
		{
			Terminal* term = static_cast<Terminal*>(inv->getObjectParameter());
			
			setTerminal(term);
			
		}
		break;
	case RPC_SETOWNER__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			setOwner(player);
			
		}
		break;
	case RPC_SETCAMP__STRUCTUREOBJECT_:
		{
			StructureObject* c = static_cast<StructureObject*>(inv->getObjectParameter());
			
			setCamp(c);
			
		}
		break;
	case RPC_GETCAMP__:
		{
			
			DistributedObject* _m_res = getCamp();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETMEDICALRATING__:
		{
			
			int _m_res = getMedicalRating();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETHEALTHWOUNDREGENRATE__:
		{
			
			int _m_res = getHealthWoundRegenRate();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETACTIONWOUNDREGENRATE__:
		{
			
			int _m_res = getActionWoundRegenRate();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMINDWOUNDREGENRATE__:
		{
			
			int _m_res = getMindWoundRegenRate();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETAGGROMOD__:
		{
			
			float _m_res = getAggroMod();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ISCAMPAREA__:
		{
			
			bool _m_res = isCampArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETVISITORCOUNT__:
		{
			
			int _m_res = getVisitorCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETUPTIME__:
		{
			
			unsigned int _m_res = getUptime();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_ISABANDONED__:
		{
			
			bool _m_res = isAbandoned();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_NOTIFYHEALEVENT__LONG_:
		{
			long long quantity = inv->getSignedLongParameter();
			
			int _m_res = notifyHealEvent(quantity);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYCOMBATEVENT__:
		{
			
			int _m_res = notifyCombatEvent();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ABANDONCAMP__:
		{
			
			abandonCamp();
			
		}
		break;
	case RPC_SETABANDONED__BOOL_:
		{
			bool isAbandoned = inv->getBooleanParameter();
			
			setAbandoned(isAbandoned);
			
		}
		break;
	case RPC_DESPAWNCAMP__:
		{
			
			bool _m_res = despawnCamp();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ASSUMEOWNERSHIP__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			assumeOwnership(player);
			
		}
		break;
	case RPC_GETOWNER__:
		{
			
			DistributedObject* _m_res = getOwner();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	default:
		ActiveAreaAdapter::invokeMethod(methid, inv);
	}
}

void CampSiteActiveAreaAdapter::initializeTransientMembers() {
	(static_cast<CampSiteActiveArea*>(stub))->initializeTransientMembers();
}

void CampSiteActiveAreaAdapter::notifyEnter(SceneObject* player) {
	(static_cast<CampSiteActiveArea*>(stub))->notifyEnter(player);
}

void CampSiteActiveAreaAdapter::notifyExit(SceneObject* player) {
	(static_cast<CampSiteActiveArea*>(stub))->notifyExit(player);
}

void CampSiteActiveAreaAdapter::setTerminal(Terminal* term) {
	(static_cast<CampSiteActiveArea*>(stub))->setTerminal(term);
}

void CampSiteActiveAreaAdapter::setOwner(CreatureObject* player) {
	(static_cast<CampSiteActiveArea*>(stub))->setOwner(player);
}

void CampSiteActiveAreaAdapter::setCamp(StructureObject* c) {
	(static_cast<CampSiteActiveArea*>(stub))->setCamp(c);
}

StructureObject* CampSiteActiveAreaAdapter::getCamp() const {
	return (static_cast<CampSiteActiveArea*>(stub))->getCamp();
}

int CampSiteActiveAreaAdapter::getMedicalRating() {
	return (static_cast<CampSiteActiveArea*>(stub))->getMedicalRating();
}

int CampSiteActiveAreaAdapter::getHealthWoundRegenRate() {
	return (static_cast<CampSiteActiveArea*>(stub))->getHealthWoundRegenRate();
}

int CampSiteActiveAreaAdapter::getActionWoundRegenRate() {
	return (static_cast<CampSiteActiveArea*>(stub))->getActionWoundRegenRate();
}

int CampSiteActiveAreaAdapter::getMindWoundRegenRate() {
	return (static_cast<CampSiteActiveArea*>(stub))->getMindWoundRegenRate();
}

float CampSiteActiveAreaAdapter::getAggroMod() {
	return (static_cast<CampSiteActiveArea*>(stub))->getAggroMod();
}

bool CampSiteActiveAreaAdapter::isCampArea() {
	return (static_cast<CampSiteActiveArea*>(stub))->isCampArea();
}

int CampSiteActiveAreaAdapter::getVisitorCount() const {
	return (static_cast<CampSiteActiveArea*>(stub))->getVisitorCount();
}

unsigned int CampSiteActiveAreaAdapter::getUptime() {
	return (static_cast<CampSiteActiveArea*>(stub))->getUptime();
}

bool CampSiteActiveAreaAdapter::isAbandoned() const {
	return (static_cast<CampSiteActiveArea*>(stub))->isAbandoned();
}

int CampSiteActiveAreaAdapter::notifyHealEvent(long long quantity) {
	return (static_cast<CampSiteActiveArea*>(stub))->notifyHealEvent(quantity);
}

int CampSiteActiveAreaAdapter::notifyCombatEvent() {
	return (static_cast<CampSiteActiveArea*>(stub))->notifyCombatEvent();
}

void CampSiteActiveAreaAdapter::abandonCamp() {
	(static_cast<CampSiteActiveArea*>(stub))->abandonCamp();
}

void CampSiteActiveAreaAdapter::setAbandoned(bool isAbandoned) {
	(static_cast<CampSiteActiveArea*>(stub))->setAbandoned(isAbandoned);
}

bool CampSiteActiveAreaAdapter::despawnCamp() {
	return (static_cast<CampSiteActiveArea*>(stub))->despawnCamp();
}

void CampSiteActiveAreaAdapter::assumeOwnership(CreatureObject* player) {
	(static_cast<CampSiteActiveArea*>(stub))->assumeOwnership(player);
}

CreatureObject* CampSiteActiveAreaAdapter::getOwner() const {
	return (static_cast<CampSiteActiveArea*>(stub))->getOwner();
}

/*
 *	CampSiteActiveAreaHelper
 */

CampSiteActiveAreaHelper* CampSiteActiveAreaHelper::staticInitializer = CampSiteActiveAreaHelper::instance();

CampSiteActiveAreaHelper::CampSiteActiveAreaHelper() {
	className = "CampSiteActiveArea";

	Core::getObjectBroker()->registerClass(className, this);
}

void CampSiteActiveAreaHelper::finalizeHelper() {
	CampSiteActiveAreaHelper::finalize();
}

DistributedObject* CampSiteActiveAreaHelper::instantiateObject() {
	return new CampSiteActiveArea(DummyConstructorParameter::instance());
}

DistributedObjectServant* CampSiteActiveAreaHelper::instantiateServant() {
	return new CampSiteActiveAreaImplementation();
}

DistributedObjectPOD* CampSiteActiveAreaHelper::instantiatePOD() {
	return new CampSiteActiveAreaPOD();
}

DistributedObjectAdapter* CampSiteActiveAreaHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new CampSiteActiveAreaAdapter(static_cast<CampSiteActiveArea*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	CampSiteActiveAreaPOD
 */

CampSiteActiveAreaPOD::~CampSiteActiveAreaPOD() {
	finalize();
}

CampSiteActiveAreaPOD::CampSiteActiveAreaPOD(void) {
	_className = "CampSiteActiveArea";
}


void CampSiteActiveAreaPOD::writeJSON(nlohmann::json& j) {
	ActiveAreaPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (camp)
		thisObject["camp"] = camp.value();

	if (terminal)
		thisObject["terminal"] = terminal.value();

	if (campObserver)
		thisObject["campObserver"] = campObserver.value();

	if (campOwner)
		thisObject["campOwner"] = campOwner.value();

	if (campStructureData)
		thisObject["campStructureData"] = campStructureData.value();

	j["CampSiteActiveArea"] = thisObject;
}


void CampSiteActiveAreaPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = CampSiteActiveAreaPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int CampSiteActiveAreaPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ActiveAreaPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (camp) {
	_nameHashCode = 0x4aeb189c; //CampSiteActiveArea.camp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<StructureObjectPOD* > >::toBinaryStream(&camp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (terminal) {
	_nameHashCode = 0x6f2f4a9c; //CampSiteActiveArea.terminal
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<TerminalPOD* > >::toBinaryStream(&terminal.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (campObserver) {
	_nameHashCode = 0x422d5a82; //CampSiteActiveArea.campObserver
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<CampSiteObserverPOD* > >::toBinaryStream(&campObserver.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (campOwner) {
	_nameHashCode = 0x13c34b78; //CampSiteActiveArea.campOwner
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<CreatureObjectPOD* > >::toBinaryStream(&campOwner.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (campStructureData) {
	_nameHashCode = 0x8a53b98c; //CampSiteActiveArea.campStructureData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<TemplateReference<CampStructureTemplate*> >::toBinaryStream(&campStructureData.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool CampSiteActiveAreaPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ActiveAreaPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x4aeb189c: //CampSiteActiveArea.camp
		{
			ManagedReference<StructureObjectPOD* > _mncamp;
			TypeInfo<ManagedReference<StructureObjectPOD* > >::parseFromBinaryStream(&_mncamp, stream);
			camp = std::move(_mncamp);
		}
		return true;

	case 0x6f2f4a9c: //CampSiteActiveArea.terminal
		{
			ManagedReference<TerminalPOD* > _mnterminal;
			TypeInfo<ManagedReference<TerminalPOD* > >::parseFromBinaryStream(&_mnterminal, stream);
			terminal = std::move(_mnterminal);
		}
		return true;

	case 0x422d5a82: //CampSiteActiveArea.campObserver
		{
			ManagedReference<CampSiteObserverPOD* > _mncampObserver;
			TypeInfo<ManagedReference<CampSiteObserverPOD* > >::parseFromBinaryStream(&_mncampObserver, stream);
			campObserver = std::move(_mncampObserver);
		}
		return true;

	case 0x13c34b78: //CampSiteActiveArea.campOwner
		{
			ManagedReference<CreatureObjectPOD* > _mncampOwner;
			TypeInfo<ManagedReference<CreatureObjectPOD* > >::parseFromBinaryStream(&_mncampOwner, stream);
			campOwner = std::move(_mncampOwner);
		}
		return true;

	case 0x8a53b98c: //CampSiteActiveArea.campStructureData
		{
			TemplateReference<CampStructureTemplate*> _mncampStructureData;
			TypeInfo<TemplateReference<CampStructureTemplate*> >::parseFromBinaryStream(&_mncampStructureData, stream);
			campStructureData = std::move(_mncampStructureData);
		}
		return true;

	}

	return false;
}

void CampSiteActiveAreaPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(CampSiteActiveAreaPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void CampSiteActiveAreaPOD::writeObjectCompact(ObjectOutputStream* stream) {
	ActiveAreaPOD::writeObjectCompact(stream);

	TypeInfo<ManagedReference<StructureObjectPOD* > >::toBinaryStream(&camp.value(), stream);

	TypeInfo<ManagedReference<TerminalPOD* > >::toBinaryStream(&terminal.value(), stream);

	TypeInfo<ManagedReference<CampSiteObserverPOD* > >::toBinaryStream(&campObserver.value(), stream);

	TypeInfo<ManagedReference<CreatureObjectPOD* > >::toBinaryStream(&campOwner.value(), stream);

	TypeInfo<TemplateReference<CampStructureTemplate*> >::toBinaryStream(&campStructureData.value(), stream);


}

