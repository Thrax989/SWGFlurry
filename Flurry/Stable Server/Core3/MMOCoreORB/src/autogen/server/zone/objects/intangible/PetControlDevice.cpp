/*
 *	autogen/server/zone/objects/intangible/PetControlDevice.cpp generated by engine3 IDL compiler 0.70
 */

#include "PetControlDevice.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/creature/ai/AiAgent.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/objects/intangible/PetControlObserver.h"

/*
 *	PetControlDeviceStub
 */

enum {RPC_STOREOBJECT__CREATUREOBJECT_BOOL_ = 1584499549,RPC_CALLOBJECT__CREATUREOBJECT_,RPC_SPAWNOBJECT__CREATUREOBJECT_,RPC_CANCELSPAWNOBJECT__CREATUREOBJECT_,RPC_GROWPET__CREATUREOBJECT_BOOL_BOOL_,RPC_ARRESTGROWTH__,RPC_TRAINASMOUNT__CREATUREOBJECT_,RPC_ISTRAINEDASMOUNT__,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_DESTROYOBJECTFROMDATABASE__BOOL_,RPC_DESTROYOBJECTFROMWORLD__BOOL_,RPC_CANBEDESTROYED__CREATUREOBJECT_,RPC_CANBETRADEDTO__CREATUREOBJECT_CREATUREOBJECT_INT_,RPC_GETTRAININGCOMMAND__,RPC_HASTRAINEDCOMMAND__INT_,RPC_HASTRAINEDCOMMANDSTRING__STRING_,RPC_HASUSEDNAMINGCOMMAND__INT_,RPC_GETTRAINEDCOMMAND__INT_,RPC_ADDTRAINEDCOMMAND__INT_STRING_,RPC_SETLASTCOMMAND__INT_,RPC_GETLASTCOMMAND__,RPC_GETFUTURENAME__,RPC_SETFUTURENAME__STRING_,RPC_GETNAMINGPROGRESS__,RPC_INCREMENTNAMINGPROGRESS__INT_,RPC_RESETNAMINGPROGRESS__,RPC_RESETNAMINGCOMMANDS__,RPC_ISPETCONTROLDEVICE__,RPC_GETVITALITY__,RPC_GETMAXVITALITY__,RPC_SETVITALITY__INT_,RPC_SETMAXVITALITY__INT_,RPC_GETPETTYPE__,RPC_SETPETTYPE__INT_,RPC_SETGROWTHSTAGE__INT_,RPC_CLEARPATROLPOINTS__,RPC_TOGGLEUSERANGED__,RPC_SETVITALITYHEALTHPENALTY__FLOAT_,RPC_SETVITALITYACTIONPENALTY__FLOAT_,RPC_SETVITALITYMINDPENALTY__FLOAT_,RPC_GETUSERANGED__,RPC_ISFRIEND__LONG_,RPC_TOGGLEFRIEND__LONG_};

PetControlDevice::PetControlDevice() : ControlDevice(DummyConstructorParameter::instance()) {
	PetControlDeviceImplementation* _implementation = new PetControlDeviceImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("PetControlDevice");
}

PetControlDevice::PetControlDevice(DummyConstructorParameter* param) : ControlDevice(param) {
	_setClassName("PetControlDevice");
}

PetControlDevice::~PetControlDevice() {
}



void PetControlDevice::storeObject(CreatureObject* player, bool force) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOREOBJECT__CREATUREOBJECT_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(force);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		_implementation->storeObject(player, force);
	}
}

void PetControlDevice::callObject(CreatureObject* player) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALLOBJECT__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		_implementation->callObject(player);
	}
}

void PetControlDevice::spawnObject(CreatureObject* player) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SPAWNOBJECT__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		_implementation->spawnObject(player);
	}
}

void PetControlDevice::cancelSpawnObject(CreatureObject* player) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCELSPAWNOBJECT__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert((player == NULL) || player->isLockedByCurrentThread());
		_implementation->cancelSpawnObject(player);
	}
}

bool PetControlDevice::growPet(CreatureObject* player, bool force, bool adult) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GROWPET__CREATUREOBJECT_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(force);
		method.addBooleanParameter(adult);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->growPet(player, force, adult);
	}
}

void PetControlDevice::arrestGrowth() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ARRESTGROWTH__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->arrestGrowth();
	}
}

void PetControlDevice::trainAsMount(CreatureObject* player) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_TRAINASMOUNT__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->trainAsMount(player);
	}
}

bool PetControlDevice::isTrainedAsMount() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTRAINEDASMOUNT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTrainedAsMount();
	}
}

int PetControlDevice::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

void PetControlDevice::destroyObjectFromDatabase(bool destroyContainedObjects) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyObjectFromDatabase(destroyContainedObjects);
	}
}

void PetControlDevice::destroyObjectFromWorld(bool sendSelfDestroy) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMWORLD__BOOL_);
		method.addBooleanParameter(sendSelfDestroy);

		method.executeWithVoidReturn();
	} else {
		_implementation->destroyObjectFromWorld(sendSelfDestroy);
	}
}

int PetControlDevice::canBeDestroyed(CreatureObject* player) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANBEDESTROYED__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->canBeDestroyed(player);
	}
}

bool PetControlDevice::canBeTradedTo(CreatureObject* player, CreatureObject* receiver, int numberInTrade) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANBETRADEDTO__CREATUREOBJECT_CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addObjectParameter(receiver);
		method.addSignedIntParameter(numberInTrade);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canBeTradedTo(player, receiver, numberInTrade);
	}
}

void PetControlDevice::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

void PetControlDevice::setDefaultCommands() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDefaultCommands();
	}
}

void PetControlDevice::setTrainingCommand(unsigned int commandID) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setTrainingCommand(commandID);
	}
}

unsigned int PetControlDevice::getTrainingCommand() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTRAININGCOMMAND__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getTrainingCommand();
	}
}

bool PetControlDevice::hasTrainedCommand(unsigned int command) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASTRAINEDCOMMAND__INT_);
		method.addUnsignedIntParameter(command);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasTrainedCommand(command);
	}
}

bool PetControlDevice::hasTrainedCommandString(const String& message) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASTRAINEDCOMMANDSTRING__STRING_);
		method.addAsciiParameter(message);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasTrainedCommandString(message);
	}
}

bool PetControlDevice::hasUsedNamingCommand(unsigned int command) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASUSEDNAMINGCOMMAND__INT_);
		method.addUnsignedIntParameter(command);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasUsedNamingCommand(command);
	}
}

String PetControlDevice::getTrainedCommand(unsigned int command) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTRAINEDCOMMAND__INT_);
		method.addUnsignedIntParameter(command);

		String _return_getTrainedCommand;
		method.executeWithAsciiReturn(_return_getTrainedCommand);
		return _return_getTrainedCommand;
	} else {
		return _implementation->getTrainedCommand(command);
	}
}

void PetControlDevice::addTrainedCommand(unsigned int command, const String& message) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTRAINEDCOMMAND__INT_STRING_);
		method.addUnsignedIntParameter(command);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addTrainedCommand(command, message);
	}
}

void PetControlDevice::setLastCommand(unsigned int c) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTCOMMAND__INT_);
		method.addUnsignedIntParameter(c);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLastCommand(c);
	}
}

unsigned int PetControlDevice::getLastCommand() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTCOMMAND__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getLastCommand();
	}
}

void PetControlDevice::setLastCommandTarget(SceneObject* target) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLastCommandTarget(target);
	}
}

ManagedWeakReference<SceneObject* > PetControlDevice::getLastCommandTarget() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastCommandTarget();
	}
}

String PetControlDevice::getFutureName() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFUTURENAME__);

		String _return_getFutureName;
		method.executeWithAsciiReturn(_return_getFutureName);
		return _return_getFutureName;
	} else {
		return _implementation->getFutureName();
	}
}

void PetControlDevice::setFutureName(String& name) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFUTURENAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setFutureName(name);
	}
}

unsigned int PetControlDevice::getNamingProgress() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNAMINGPROGRESS__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getNamingProgress();
	}
}

void PetControlDevice::incrementNamingProgress(unsigned int command) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREMENTNAMINGPROGRESS__INT_);
		method.addUnsignedIntParameter(command);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->incrementNamingProgress(command);
	}
}

void PetControlDevice::resetNamingProgress() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETNAMINGPROGRESS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->resetNamingProgress();
	}
}

void PetControlDevice::resetNamingCommands() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETNAMINGCOMMANDS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->resetNamingCommands();
	}
}

bool PetControlDevice::isPetControlDevice() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPETCONTROLDEVICE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPetControlDevice();
	}
}

int PetControlDevice::getVitality() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVITALITY__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getVitality();
	}
}

int PetControlDevice::getMaxVitality() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXVITALITY__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMaxVitality();
	}
}

void PetControlDevice::setVitality(int vit) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETVITALITY__INT_);
		method.addSignedIntParameter(vit);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setVitality(vit);
	}
}

void PetControlDevice::setMaxVitality(int vit) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXVITALITY__INT_);
		method.addSignedIntParameter(vit);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMaxVitality(vit);
	}
}

int PetControlDevice::getPetType() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPETTYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPetType();
	}
}

void PetControlDevice::setPetType(int type) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPETTYPE__INT_);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPetType(type);
	}
}

void PetControlDevice::setGrowthStage(int stage) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETGROWTHSTAGE__INT_);
		method.addSignedIntParameter(stage);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setGrowthStage(stage);
	}
}

void PetControlDevice::clearPatrolPoints() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARPATROLPOINTS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearPatrolPoints();
	}
}

void PetControlDevice::addPatrolPoint(PatrolPoint& point) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addPatrolPoint(point);
	}
}

int PetControlDevice::getPatrolPointSize() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPatrolPointSize();
	}
}

PatrolPoint PetControlDevice::getPatrolPoint(int idx) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPatrolPoint(idx);
	}
}

bool PetControlDevice::isValidPet(AiAgent* pet) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->isValidPet(pet);
	}
}

void PetControlDevice::toggleUseRanged() {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_TOGGLEUSERANGED__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->toggleUseRanged();
	}
}

void PetControlDevice::setVitalityHealthPenalty(float value) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETVITALITYHEALTHPENALTY__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setVitalityHealthPenalty(value);
	}
}

void PetControlDevice::setVitalityActionPenalty(float value) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETVITALITYACTIONPENALTY__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setVitalityActionPenalty(value);
	}
}

void PetControlDevice::setVitalityMindPenalty(float value) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETVITALITYMINDPENALTY__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setVitalityMindPenalty(value);
	}
}

bool PetControlDevice::getUseRanged() const {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETUSERANGED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getUseRanged();
	}
}

bool PetControlDevice::isFriend(unsigned long long playerID) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFRIEND__LONG_);
		method.addUnsignedLongParameter(playerID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFriend(playerID);
	}
}

void PetControlDevice::toggleFriend(unsigned long long playerID) {
	PetControlDeviceImplementation* _implementation = static_cast<PetControlDeviceImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_TOGGLEFRIEND__LONG_);
		method.addUnsignedLongParameter(playerID);

		method.executeWithVoidReturn();
	} else {
		_implementation->toggleFriend(playerID);
	}
}

DistributedObjectServant* PetControlDevice::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* PetControlDevice::_getImplementationForRead() const {
	return _impl;
}

void PetControlDevice::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	PetControlDeviceImplementation
 */

PetControlDeviceImplementation::PetControlDeviceImplementation(DummyConstructorParameter* param) : ControlDeviceImplementation(param) {
	_initializeImplementation();
}


PetControlDeviceImplementation::~PetControlDeviceImplementation() {
}


void PetControlDeviceImplementation::finalize() {
}

void PetControlDeviceImplementation::_initializeImplementation() {
	_setClassHelper(PetControlDeviceHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void PetControlDeviceImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<PetControlDevice*>(stub);
	ControlDeviceImplementation::_setStub(stub);
}

DistributedObjectStub* PetControlDeviceImplementation::_getStub() {
	return _this.get();
}

PetControlDeviceImplementation::operator const PetControlDevice*() {
	return _this.get();
}

void PetControlDeviceImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void PetControlDeviceImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void PetControlDeviceImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void PetControlDeviceImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void PetControlDeviceImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void PetControlDeviceImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void PetControlDeviceImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void PetControlDeviceImplementation::_serializationHelperMethod() {
	ControlDeviceImplementation::_serializationHelperMethod();

	_setClassName("PetControlDevice");

}

void PetControlDeviceImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PetControlDeviceImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool PetControlDeviceImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ControlDeviceImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x86b85062: //PetControlDevice.petControlObserver
		TypeInfo<ManagedReference<PetControlObserver* > >::parseFromBinaryStream(&petControlObserver, stream);
		return true;

	case 0xb9261125: //PetControlDevice.vitality
		TypeInfo<int >::parseFromBinaryStream(&vitality, stream);
		return true;

	case 0x15df0938: //PetControlDevice.maxVitality
		TypeInfo<int >::parseFromBinaryStream(&maxVitality, stream);
		return true;

	case 0x18b9bf5d: //PetControlDevice.vitalityHealthPenalty
		TypeInfo<int >::parseFromBinaryStream(&vitalityHealthPenalty, stream);
		return true;

	case 0xd90608d8: //PetControlDevice.vitalityActionPenalty
		TypeInfo<int >::parseFromBinaryStream(&vitalityActionPenalty, stream);
		return true;

	case 0x71cecd33: //PetControlDevice.vitalityMindPenalty
		TypeInfo<int >::parseFromBinaryStream(&vitalityMindPenalty, stream);
		return true;

	case 0xcf56d4ca: //PetControlDevice.petType
		TypeInfo<int >::parseFromBinaryStream(&petType, stream);
		return true;

	case 0xe6b502f5: //PetControlDevice.trainedCommands
		TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&trainedCommands, stream);
		return true;

	case 0xe3ac3453: //PetControlDevice.trainingCommand
		TypeInfo<unsigned int >::parseFromBinaryStream(&trainingCommand, stream);
		return true;

	case 0xb8a0b38: //PetControlDevice.lastCommand
		TypeInfo<unsigned int >::parseFromBinaryStream(&lastCommand, stream);
		return true;

	case 0x25729aff: //PetControlDevice.lastCommandTarget
		TypeInfo<ManagedWeakReference<SceneObject* > >::parseFromBinaryStream(&lastCommandTarget, stream);
		return true;

	case 0xfd1388b7: //PetControlDevice.futureName
		TypeInfo<String >::parseFromBinaryStream(&futureName, stream);
		return true;

	case 0x7c4bff3f: //PetControlDevice.namingProgress
		TypeInfo<unsigned int >::parseFromBinaryStream(&namingProgress, stream);
		return true;

	case 0xb913c3b9: //PetControlDevice.growthStage
		TypeInfo<int >::parseFromBinaryStream(&growthStage, stream);
		return true;

	case 0x7c2f6962: //PetControlDevice.lastGrowth
		TypeInfo<Time >::parseFromBinaryStream(&lastGrowth, stream);
		return true;

	case 0xf653f7fd: //PetControlDevice.trainedAsMount
		TypeInfo<bool >::parseFromBinaryStream(&trainedAsMount, stream);
		return true;

	case 0x87035d9b: //PetControlDevice.namingCommands
		TypeInfo<Vector<unsigned int> >::parseFromBinaryStream(&namingCommands, stream);
		return true;

	case 0x325a288c: //PetControlDevice.patrolPoints
		TypeInfo<PatrolPointsVector >::parseFromBinaryStream(&patrolPoints, stream);
		return true;

	case 0xc5759ac4: //PetControlDevice.useRanged
		TypeInfo<bool >::parseFromBinaryStream(&useRanged, stream);
		return true;

	}

	return false;
}

void PetControlDeviceImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PetControlDeviceImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PetControlDeviceImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ControlDeviceImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x86b85062; //PetControlDevice.petControlObserver
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<PetControlObserver* > >::toBinaryStream(&petControlObserver, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb9261125; //PetControlDevice.vitality
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vitality, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x15df0938; //PetControlDevice.maxVitality
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxVitality, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x18b9bf5d; //PetControlDevice.vitalityHealthPenalty
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vitalityHealthPenalty, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd90608d8; //PetControlDevice.vitalityActionPenalty
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vitalityActionPenalty, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x71cecd33; //PetControlDevice.vitalityMindPenalty
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vitalityMindPenalty, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcf56d4ca; //PetControlDevice.petType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&petType, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe6b502f5; //PetControlDevice.trainedCommands
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&trainedCommands, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe3ac3453; //PetControlDevice.trainingCommand
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&trainingCommand, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb8a0b38; //PetControlDevice.lastCommand
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&lastCommand, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x25729aff; //PetControlDevice.lastCommandTarget
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObject* > >::toBinaryStream(&lastCommandTarget, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xfd1388b7; //PetControlDevice.futureName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&futureName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7c4bff3f; //PetControlDevice.namingProgress
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&namingProgress, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb913c3b9; //PetControlDevice.growthStage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&growthStage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7c2f6962; //PetControlDevice.lastGrowth
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastGrowth, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf653f7fd; //PetControlDevice.trainedAsMount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&trainedAsMount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x87035d9b; //PetControlDevice.namingCommands
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned int> >::toBinaryStream(&namingCommands, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x325a288c; //PetControlDevice.patrolPoints
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<PatrolPointsVector >::toBinaryStream(&patrolPoints, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc5759ac4; //PetControlDevice.useRanged
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&useRanged, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void PetControlDeviceImplementation::writeJSON(nlohmann::json& j) {
	ControlDeviceImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["petControlObserver"] = petControlObserver;

	thisObject["vitality"] = vitality;

	thisObject["maxVitality"] = maxVitality;

	thisObject["vitalityHealthPenalty"] = vitalityHealthPenalty;

	thisObject["vitalityActionPenalty"] = vitalityActionPenalty;

	thisObject["vitalityMindPenalty"] = vitalityMindPenalty;

	thisObject["petType"] = petType;

	thisObject["trainedCommands"] = trainedCommands;

	thisObject["trainingCommand"] = trainingCommand;

	thisObject["lastCommand"] = lastCommand;

	thisObject["lastCommandTarget"] = lastCommandTarget;

	thisObject["futureName"] = futureName;

	thisObject["namingProgress"] = namingProgress;

	thisObject["growthStage"] = growthStage;

	thisObject["lastGrowth"] = lastGrowth;

	thisObject["trainedAsMount"] = trainedAsMount;

	thisObject["namingCommands"] = namingCommands;

	thisObject["patrolPoints"] = patrolPoints;

	thisObject["useRanged"] = useRanged;

	j["PetControlDevice"] = thisObject;
}

PetControlDeviceImplementation::PetControlDeviceImplementation() {
	_initializeImplementation();
	// server/zone/objects/intangible/PetControlDevice.idl():  		Logger.setLoggingName("PetControlDevice");
	Logger::setLoggingName("PetControlDevice");
	// server/zone/objects/intangible/PetControlDevice.idl():  		Logger.setLogging(false);
	Logger::setLogging(false);
	// server/zone/objects/intangible/PetControlDevice.idl():  		Logger.setGlobalLogging(true);
	Logger::setGlobalLogging(true);
	// server/zone/objects/intangible/PetControlDevice.idl():  		vitality = 1;
	vitality = 1;
	// server/zone/objects/intangible/PetControlDevice.idl():  		maxVitality = 1;
	maxVitality = 1;
	// server/zone/objects/intangible/PetControlDevice.idl():  		vitalityHealthPenalty = 0;
	vitalityHealthPenalty = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		vitalityActionPenalty = 0;
	vitalityActionPenalty = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		vitalityMindPenalty = 0;
	vitalityMindPenalty = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		petType = 0;
	petType = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		trainingCommand = 0;
	trainingCommand = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		lastCommand = 0;
	lastCommand = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		lastCommandTarget = null;
	lastCommandTarget = NULL;
	// server/zone/objects/intangible/PetControlDevice.idl():  		namingProgress = 0;
	namingProgress = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		futureName = "";
	futureName = "";
	// server/zone/objects/intangible/PetControlDevice.idl():  		growthStage = 0;
	growthStage = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		trainedAsMount = false;
	trainedAsMount = false;
	// server/zone/objects/intangible/PetControlDevice.idl():  		useRanged = false;
	useRanged = false;
	// server/zone/objects/intangible/PetControlDevice.idl():  		lastGrowth.updateToCurrentTime();
	(&lastGrowth)->updateToCurrentTime();
	// server/zone/objects/intangible/PetControlDevice.idl():  		trainedCommands.setAllowOverwriteInsertPlan();
	(&trainedCommands)->setAllowOverwriteInsertPlan();
	// server/zone/objects/intangible/PetControlDevice.idl():  		trainedCommands.setNullValue("");
	(&trainedCommands)->setNullValue("");
}

bool PetControlDeviceImplementation::isTrainedAsMount() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return trainedAsMount;
	return trainedAsMount;
}

unsigned int PetControlDeviceImplementation::getTrainingCommand() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return trainingCommand;
	return trainingCommand;
}

bool PetControlDeviceImplementation::hasTrainedCommand(unsigned int command) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		return trainedCommands.contains(command);
	return (&trainedCommands)->contains(command);
}

bool PetControlDeviceImplementation::hasTrainedCommandString(const String& message) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		}
	for (	// server/zone/objects/intangible/PetControlDevice.idl():  		for (int i = 0;
	int i = 0;
	i < (&trainedCommands)->size();
i ++) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		}
	if ((&trainedCommands)->get(i) == message)	// server/zone/objects/intangible/PetControlDevice.idl():  				return true;
	return true;
}
	// server/zone/objects/intangible/PetControlDevice.idl():  		return false;
	return false;
}

bool PetControlDeviceImplementation::hasUsedNamingCommand(unsigned int command) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		return 
	if ((&namingCommands)->contains(command))	// server/zone/objects/intangible/PetControlDevice.idl():  			return true;
	return true;
	// server/zone/objects/intangible/PetControlDevice.idl():  		return false;
	return false;
}

String PetControlDeviceImplementation::getTrainedCommand(unsigned int command) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		return trainedCommands.get(command);
	return (&trainedCommands)->get(command);
}

void PetControlDeviceImplementation::addTrainedCommand(unsigned int command, const String& message) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		trainedCommands.put(command, message);
	(&trainedCommands)->put(command, message);
}

void PetControlDeviceImplementation::setLastCommand(unsigned int c) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		lastCommand = c;
	lastCommand = c;
}

unsigned int PetControlDeviceImplementation::getLastCommand() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return lastCommand;
	return lastCommand;
}

void PetControlDeviceImplementation::setLastCommandTarget(SceneObject* target) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		lastCommandTarget = target;
	lastCommandTarget = target;
}

ManagedWeakReference<SceneObject* > PetControlDeviceImplementation::getLastCommandTarget() {
	// server/zone/objects/intangible/PetControlDevice.idl():  		return lastCommandTarget;
	return lastCommandTarget;
}

String PetControlDeviceImplementation::getFutureName() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return futureName;
	return futureName;
}

void PetControlDeviceImplementation::setFutureName(String& name) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		futureName = name;
	futureName = name;
}

unsigned int PetControlDeviceImplementation::getNamingProgress() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return namingProgress;
	return namingProgress;
}

void PetControlDeviceImplementation::incrementNamingProgress(unsigned int command) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		namingProgress++;
	namingProgress ++;
	// server/zone/objects/intangible/PetControlDevice.idl():  		namingCommands.add(command);
	(&namingCommands)->add(command);
}

void PetControlDeviceImplementation::resetNamingProgress() {
	// server/zone/objects/intangible/PetControlDevice.idl():  		namingProgress = 0;
	namingProgress = 0;
	// server/zone/objects/intangible/PetControlDevice.idl():  		resetNamingCommands();
	resetNamingCommands();
}

bool PetControlDeviceImplementation::isPetControlDevice() {
	// server/zone/objects/intangible/PetControlDevice.idl():  		return true;
	return true;
}

int PetControlDeviceImplementation::getVitality() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return vitality;
	return vitality;
}

int PetControlDeviceImplementation::getMaxVitality() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return maxVitality;
	return maxVitality;
}

void PetControlDeviceImplementation::setMaxVitality(int vit) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		maxVitality = vit;
	maxVitality = vit;
}

int PetControlDeviceImplementation::getPetType() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return petType;
	return petType;
}

void PetControlDeviceImplementation::setPetType(int type) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		petType = type;
	petType = type;
}

void PetControlDeviceImplementation::setGrowthStage(int stage) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		growthStage = stage;
	growthStage = stage;
}

void PetControlDeviceImplementation::clearPatrolPoints() {
	// server/zone/objects/intangible/PetControlDevice.idl():  		patrolPoints.removeAll();
	(&patrolPoints)->removeAll();
}

int PetControlDeviceImplementation::getPatrolPointSize() {
	// server/zone/objects/intangible/PetControlDevice.idl():  		return patrolPoints.size();
	return (&patrolPoints)->size();
}

void PetControlDeviceImplementation::toggleUseRanged() {
	// server/zone/objects/intangible/PetControlDevice.idl():  		useRanged = !useRanged;
	useRanged = !useRanged;
}

void PetControlDeviceImplementation::setVitalityHealthPenalty(float value) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		vitalityHealthPenalty = value;
	vitalityHealthPenalty = value;
}

void PetControlDeviceImplementation::setVitalityActionPenalty(float value) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		vitalityActionPenalty = value;
	vitalityActionPenalty = value;
}

void PetControlDeviceImplementation::setVitalityMindPenalty(float value) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		vitalityMindPenalty = value;
	vitalityMindPenalty = value;
}

bool PetControlDeviceImplementation::getUseRanged() const{
	// server/zone/objects/intangible/PetControlDevice.idl():  		return useRanged;
	return useRanged;
}

bool PetControlDeviceImplementation::isFriend(unsigned long long playerID) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		return friends.contains(playerID);
	return (&friends)->contains(playerID);
}

void PetControlDeviceImplementation::toggleFriend(unsigned long long playerID) {
	// server/zone/objects/intangible/PetControlDevice.idl():  		}
	if ((&friends)->contains(playerID)){
	// server/zone/objects/intangible/PetControlDevice.idl():  			friends.removeElement(playerID);
	(&friends)->removeElement(playerID);
}

	else {
	// server/zone/objects/intangible/PetControlDevice.idl():  			friends.add(playerID);
	(&friends)->add(playerID);
}
}

/*
 *	PetControlDeviceAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


PetControlDeviceAdapter::PetControlDeviceAdapter(PetControlDevice* obj) : ControlDeviceAdapter(obj) {
}

void PetControlDeviceAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_STOREOBJECT__CREATUREOBJECT_BOOL_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			bool force = inv->getBooleanParameter();
			
			storeObject(player, force);
			
		}
		break;
	case RPC_CALLOBJECT__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			callObject(player);
			
		}
		break;
	case RPC_SPAWNOBJECT__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			spawnObject(player);
			
		}
		break;
	case RPC_CANCELSPAWNOBJECT__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			cancelSpawnObject(player);
			
		}
		break;
	case RPC_GROWPET__CREATUREOBJECT_BOOL_BOOL_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			bool force = inv->getBooleanParameter();
			bool adult = inv->getBooleanParameter();
			
			bool _m_res = growPet(player, force, adult);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ARRESTGROWTH__:
		{
			
			arrestGrowth();
			
		}
		break;
	case RPC_TRAINASMOUNT__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			trainAsMount(player);
			
		}
		break;
	case RPC_ISTRAINEDASMOUNT__:
		{
			
			bool _m_res = isTrainedAsMount();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte selectedID = inv->getByteParameter();
			
			int _m_res = handleObjectMenuSelect(player, selectedID);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DESTROYOBJECTFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyObjectFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_DESTROYOBJECTFROMWORLD__BOOL_:
		{
			bool sendSelfDestroy = inv->getBooleanParameter();
			
			destroyObjectFromWorld(sendSelfDestroy);
			
		}
		break;
	case RPC_CANBEDESTROYED__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			int _m_res = canBeDestroyed(player);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CANBETRADEDTO__CREATUREOBJECT_CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* receiver = static_cast<CreatureObject*>(inv->getObjectParameter());
			int numberInTrade = inv->getSignedIntParameter();
			
			bool _m_res = canBeTradedTo(player, receiver, numberInTrade);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETTRAININGCOMMAND__:
		{
			
			unsigned int _m_res = getTrainingCommand();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_HASTRAINEDCOMMAND__INT_:
		{
			unsigned int command = inv->getUnsignedIntParameter();
			
			bool _m_res = hasTrainedCommand(command);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASTRAINEDCOMMANDSTRING__STRING_:
		{
			 String message; inv->getAsciiParameter(message);
			
			bool _m_res = hasTrainedCommandString(message);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASUSEDNAMINGCOMMAND__INT_:
		{
			unsigned int command = inv->getUnsignedIntParameter();
			
			bool _m_res = hasUsedNamingCommand(command);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETTRAINEDCOMMAND__INT_:
		{
			unsigned int command = inv->getUnsignedIntParameter();
			
			String _m_res = getTrainedCommand(command);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ADDTRAINEDCOMMAND__INT_STRING_:
		{
			unsigned int command = inv->getUnsignedIntParameter();
			 String message; inv->getAsciiParameter(message);
			
			addTrainedCommand(command, message);
			
		}
		break;
	case RPC_SETLASTCOMMAND__INT_:
		{
			unsigned int c = inv->getUnsignedIntParameter();
			
			setLastCommand(c);
			
		}
		break;
	case RPC_GETLASTCOMMAND__:
		{
			
			unsigned int _m_res = getLastCommand();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETFUTURENAME__:
		{
			
			String _m_res = getFutureName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETFUTURENAME__STRING_:
		{
			String name; inv->getAsciiParameter(name);
			
			setFutureName(name);
			
		}
		break;
	case RPC_GETNAMINGPROGRESS__:
		{
			
			unsigned int _m_res = getNamingProgress();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_INCREMENTNAMINGPROGRESS__INT_:
		{
			unsigned int command = inv->getUnsignedIntParameter();
			
			incrementNamingProgress(command);
			
		}
		break;
	case RPC_RESETNAMINGPROGRESS__:
		{
			
			resetNamingProgress();
			
		}
		break;
	case RPC_RESETNAMINGCOMMANDS__:
		{
			
			resetNamingCommands();
			
		}
		break;
	case RPC_ISPETCONTROLDEVICE__:
		{
			
			bool _m_res = isPetControlDevice();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETVITALITY__:
		{
			
			int _m_res = getVitality();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMAXVITALITY__:
		{
			
			int _m_res = getMaxVitality();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETVITALITY__INT_:
		{
			int vit = inv->getSignedIntParameter();
			
			setVitality(vit);
			
		}
		break;
	case RPC_SETMAXVITALITY__INT_:
		{
			int vit = inv->getSignedIntParameter();
			
			setMaxVitality(vit);
			
		}
		break;
	case RPC_GETPETTYPE__:
		{
			
			int _m_res = getPetType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETPETTYPE__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			setPetType(type);
			
		}
		break;
	case RPC_SETGROWTHSTAGE__INT_:
		{
			int stage = inv->getSignedIntParameter();
			
			setGrowthStage(stage);
			
		}
		break;
	case RPC_CLEARPATROLPOINTS__:
		{
			
			clearPatrolPoints();
			
		}
		break;
	case RPC_TOGGLEUSERANGED__:
		{
			
			toggleUseRanged();
			
		}
		break;
	case RPC_SETVITALITYHEALTHPENALTY__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setVitalityHealthPenalty(value);
			
		}
		break;
	case RPC_SETVITALITYACTIONPENALTY__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setVitalityActionPenalty(value);
			
		}
		break;
	case RPC_SETVITALITYMINDPENALTY__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setVitalityMindPenalty(value);
			
		}
		break;
	case RPC_GETUSERANGED__:
		{
			
			bool _m_res = getUseRanged();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFRIEND__LONG_:
		{
			unsigned long long playerID = inv->getUnsignedLongParameter();
			
			bool _m_res = isFriend(playerID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_TOGGLEFRIEND__LONG_:
		{
			unsigned long long playerID = inv->getUnsignedLongParameter();
			
			toggleFriend(playerID);
			
		}
		break;
	default:
		ControlDeviceAdapter::invokeMethod(methid, inv);
	}
}

void PetControlDeviceAdapter::storeObject(CreatureObject* player, bool force) {
	(static_cast<PetControlDevice*>(stub))->storeObject(player, force);
}

void PetControlDeviceAdapter::callObject(CreatureObject* player) {
	(static_cast<PetControlDevice*>(stub))->callObject(player);
}

void PetControlDeviceAdapter::spawnObject(CreatureObject* player) {
	(static_cast<PetControlDevice*>(stub))->spawnObject(player);
}

void PetControlDeviceAdapter::cancelSpawnObject(CreatureObject* player) {
	(static_cast<PetControlDevice*>(stub))->cancelSpawnObject(player);
}

bool PetControlDeviceAdapter::growPet(CreatureObject* player, bool force, bool adult) {
	return (static_cast<PetControlDevice*>(stub))->growPet(player, force, adult);
}

void PetControlDeviceAdapter::arrestGrowth() {
	(static_cast<PetControlDevice*>(stub))->arrestGrowth();
}

void PetControlDeviceAdapter::trainAsMount(CreatureObject* player) {
	(static_cast<PetControlDevice*>(stub))->trainAsMount(player);
}

bool PetControlDeviceAdapter::isTrainedAsMount() const {
	return (static_cast<PetControlDevice*>(stub))->isTrainedAsMount();
}

int PetControlDeviceAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<PetControlDevice*>(stub))->handleObjectMenuSelect(player, selectedID);
}

void PetControlDeviceAdapter::destroyObjectFromDatabase(bool destroyContainedObjects) {
	(static_cast<PetControlDevice*>(stub))->destroyObjectFromDatabase(destroyContainedObjects);
}

void PetControlDeviceAdapter::destroyObjectFromWorld(bool sendSelfDestroy) {
	(static_cast<PetControlDevice*>(stub))->destroyObjectFromWorld(sendSelfDestroy);
}

int PetControlDeviceAdapter::canBeDestroyed(CreatureObject* player) {
	return (static_cast<PetControlDevice*>(stub))->canBeDestroyed(player);
}

bool PetControlDeviceAdapter::canBeTradedTo(CreatureObject* player, CreatureObject* receiver, int numberInTrade) {
	return (static_cast<PetControlDevice*>(stub))->canBeTradedTo(player, receiver, numberInTrade);
}

unsigned int PetControlDeviceAdapter::getTrainingCommand() const {
	return (static_cast<PetControlDevice*>(stub))->getTrainingCommand();
}

bool PetControlDeviceAdapter::hasTrainedCommand(unsigned int command) {
	return (static_cast<PetControlDevice*>(stub))->hasTrainedCommand(command);
}

bool PetControlDeviceAdapter::hasTrainedCommandString(const String& message) {
	return (static_cast<PetControlDevice*>(stub))->hasTrainedCommandString(message);
}

bool PetControlDeviceAdapter::hasUsedNamingCommand(unsigned int command) {
	return (static_cast<PetControlDevice*>(stub))->hasUsedNamingCommand(command);
}

String PetControlDeviceAdapter::getTrainedCommand(unsigned int command) {
	return (static_cast<PetControlDevice*>(stub))->getTrainedCommand(command);
}

void PetControlDeviceAdapter::addTrainedCommand(unsigned int command, const String& message) {
	(static_cast<PetControlDevice*>(stub))->addTrainedCommand(command, message);
}

void PetControlDeviceAdapter::setLastCommand(unsigned int c) {
	(static_cast<PetControlDevice*>(stub))->setLastCommand(c);
}

unsigned int PetControlDeviceAdapter::getLastCommand() const {
	return (static_cast<PetControlDevice*>(stub))->getLastCommand();
}

String PetControlDeviceAdapter::getFutureName() const {
	return (static_cast<PetControlDevice*>(stub))->getFutureName();
}

void PetControlDeviceAdapter::setFutureName(String& name) {
	(static_cast<PetControlDevice*>(stub))->setFutureName(name);
}

unsigned int PetControlDeviceAdapter::getNamingProgress() const {
	return (static_cast<PetControlDevice*>(stub))->getNamingProgress();
}

void PetControlDeviceAdapter::incrementNamingProgress(unsigned int command) {
	(static_cast<PetControlDevice*>(stub))->incrementNamingProgress(command);
}

void PetControlDeviceAdapter::resetNamingProgress() {
	(static_cast<PetControlDevice*>(stub))->resetNamingProgress();
}

void PetControlDeviceAdapter::resetNamingCommands() {
	(static_cast<PetControlDevice*>(stub))->resetNamingCommands();
}

bool PetControlDeviceAdapter::isPetControlDevice() {
	return (static_cast<PetControlDevice*>(stub))->isPetControlDevice();
}

int PetControlDeviceAdapter::getVitality() const {
	return (static_cast<PetControlDevice*>(stub))->getVitality();
}

int PetControlDeviceAdapter::getMaxVitality() const {
	return (static_cast<PetControlDevice*>(stub))->getMaxVitality();
}

void PetControlDeviceAdapter::setVitality(int vit) {
	(static_cast<PetControlDevice*>(stub))->setVitality(vit);
}

void PetControlDeviceAdapter::setMaxVitality(int vit) {
	(static_cast<PetControlDevice*>(stub))->setMaxVitality(vit);
}

int PetControlDeviceAdapter::getPetType() const {
	return (static_cast<PetControlDevice*>(stub))->getPetType();
}

void PetControlDeviceAdapter::setPetType(int type) {
	(static_cast<PetControlDevice*>(stub))->setPetType(type);
}

void PetControlDeviceAdapter::setGrowthStage(int stage) {
	(static_cast<PetControlDevice*>(stub))->setGrowthStage(stage);
}

void PetControlDeviceAdapter::clearPatrolPoints() {
	(static_cast<PetControlDevice*>(stub))->clearPatrolPoints();
}

void PetControlDeviceAdapter::toggleUseRanged() {
	(static_cast<PetControlDevice*>(stub))->toggleUseRanged();
}

void PetControlDeviceAdapter::setVitalityHealthPenalty(float value) {
	(static_cast<PetControlDevice*>(stub))->setVitalityHealthPenalty(value);
}

void PetControlDeviceAdapter::setVitalityActionPenalty(float value) {
	(static_cast<PetControlDevice*>(stub))->setVitalityActionPenalty(value);
}

void PetControlDeviceAdapter::setVitalityMindPenalty(float value) {
	(static_cast<PetControlDevice*>(stub))->setVitalityMindPenalty(value);
}

bool PetControlDeviceAdapter::getUseRanged() const {
	return (static_cast<PetControlDevice*>(stub))->getUseRanged();
}

bool PetControlDeviceAdapter::isFriend(unsigned long long playerID) {
	return (static_cast<PetControlDevice*>(stub))->isFriend(playerID);
}

void PetControlDeviceAdapter::toggleFriend(unsigned long long playerID) {
	(static_cast<PetControlDevice*>(stub))->toggleFriend(playerID);
}

/*
 *	PetControlDeviceHelper
 */

PetControlDeviceHelper* PetControlDeviceHelper::staticInitializer = PetControlDeviceHelper::instance();

PetControlDeviceHelper::PetControlDeviceHelper() {
	className = "PetControlDevice";

	Core::getObjectBroker()->registerClass(className, this);
}

void PetControlDeviceHelper::finalizeHelper() {
	PetControlDeviceHelper::finalize();
}

DistributedObject* PetControlDeviceHelper::instantiateObject() {
	return new PetControlDevice(DummyConstructorParameter::instance());
}

DistributedObjectServant* PetControlDeviceHelper::instantiateServant() {
	return new PetControlDeviceImplementation();
}

DistributedObjectPOD* PetControlDeviceHelper::instantiatePOD() {
	return new PetControlDevicePOD();
}

DistributedObjectAdapter* PetControlDeviceHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new PetControlDeviceAdapter(static_cast<PetControlDevice*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	PetControlDevicePOD
 */

PetControlDevicePOD::~PetControlDevicePOD() {
	finalize();
}

PetControlDevicePOD::PetControlDevicePOD(void) {
	_className = "PetControlDevice";
}


void PetControlDevicePOD::writeJSON(nlohmann::json& j) {
	ControlDevicePOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (petControlObserver)
		thisObject["petControlObserver"] = petControlObserver.value();

	if (vitality)
		thisObject["vitality"] = vitality.value();

	if (maxVitality)
		thisObject["maxVitality"] = maxVitality.value();

	if (vitalityHealthPenalty)
		thisObject["vitalityHealthPenalty"] = vitalityHealthPenalty.value();

	if (vitalityActionPenalty)
		thisObject["vitalityActionPenalty"] = vitalityActionPenalty.value();

	if (vitalityMindPenalty)
		thisObject["vitalityMindPenalty"] = vitalityMindPenalty.value();

	if (petType)
		thisObject["petType"] = petType.value();

	if (trainedCommands)
		thisObject["trainedCommands"] = trainedCommands.value();

	if (trainingCommand)
		thisObject["trainingCommand"] = trainingCommand.value();

	if (lastCommand)
		thisObject["lastCommand"] = lastCommand.value();

	if (lastCommandTarget)
		thisObject["lastCommandTarget"] = lastCommandTarget.value();

	if (futureName)
		thisObject["futureName"] = futureName.value();

	if (namingProgress)
		thisObject["namingProgress"] = namingProgress.value();

	if (growthStage)
		thisObject["growthStage"] = growthStage.value();

	if (lastGrowth)
		thisObject["lastGrowth"] = lastGrowth.value();

	if (trainedAsMount)
		thisObject["trainedAsMount"] = trainedAsMount.value();

	if (namingCommands)
		thisObject["namingCommands"] = namingCommands.value();

	if (patrolPoints)
		thisObject["patrolPoints"] = patrolPoints.value();

	if (useRanged)
		thisObject["useRanged"] = useRanged.value();

	j["PetControlDevice"] = thisObject;
}


void PetControlDevicePOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PetControlDevicePOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PetControlDevicePOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ControlDevicePOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (petControlObserver) {
	_nameHashCode = 0x86b85062; //PetControlDevice.petControlObserver
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<PetControlObserverPOD* > >::toBinaryStream(&petControlObserver.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (vitality) {
	_nameHashCode = 0xb9261125; //PetControlDevice.vitality
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vitality.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxVitality) {
	_nameHashCode = 0x15df0938; //PetControlDevice.maxVitality
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxVitality.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (vitalityHealthPenalty) {
	_nameHashCode = 0x18b9bf5d; //PetControlDevice.vitalityHealthPenalty
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vitalityHealthPenalty.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (vitalityActionPenalty) {
	_nameHashCode = 0xd90608d8; //PetControlDevice.vitalityActionPenalty
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vitalityActionPenalty.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (vitalityMindPenalty) {
	_nameHashCode = 0x71cecd33; //PetControlDevice.vitalityMindPenalty
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&vitalityMindPenalty.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (petType) {
	_nameHashCode = 0xcf56d4ca; //PetControlDevice.petType
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&petType.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (trainedCommands) {
	_nameHashCode = 0xe6b502f5; //PetControlDevice.trainedCommands
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&trainedCommands.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (trainingCommand) {
	_nameHashCode = 0xe3ac3453; //PetControlDevice.trainingCommand
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&trainingCommand.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastCommand) {
	_nameHashCode = 0xb8a0b38; //PetControlDevice.lastCommand
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&lastCommand.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastCommandTarget) {
	_nameHashCode = 0x25729aff; //PetControlDevice.lastCommandTarget
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&lastCommandTarget.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (futureName) {
	_nameHashCode = 0xfd1388b7; //PetControlDevice.futureName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&futureName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (namingProgress) {
	_nameHashCode = 0x7c4bff3f; //PetControlDevice.namingProgress
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&namingProgress.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (growthStage) {
	_nameHashCode = 0xb913c3b9; //PetControlDevice.growthStage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&growthStage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastGrowth) {
	_nameHashCode = 0x7c2f6962; //PetControlDevice.lastGrowth
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastGrowth.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (trainedAsMount) {
	_nameHashCode = 0xf653f7fd; //PetControlDevice.trainedAsMount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&trainedAsMount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (namingCommands) {
	_nameHashCode = 0x87035d9b; //PetControlDevice.namingCommands
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned int> >::toBinaryStream(&namingCommands.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (patrolPoints) {
	_nameHashCode = 0x325a288c; //PetControlDevice.patrolPoints
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<PatrolPointsVector >::toBinaryStream(&patrolPoints.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (useRanged) {
	_nameHashCode = 0xc5759ac4; //PetControlDevice.useRanged
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&useRanged.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool PetControlDevicePOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (ControlDevicePOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x86b85062: //PetControlDevice.petControlObserver
		{
			ManagedReference<PetControlObserverPOD* > _mnpetControlObserver;
			TypeInfo<ManagedReference<PetControlObserverPOD* > >::parseFromBinaryStream(&_mnpetControlObserver, stream);
			petControlObserver = std::move(_mnpetControlObserver);
		}
		return true;

	case 0xb9261125: //PetControlDevice.vitality
		{
			int _mnvitality;
			TypeInfo<int >::parseFromBinaryStream(&_mnvitality, stream);
			vitality = std::move(_mnvitality);
		}
		return true;

	case 0x15df0938: //PetControlDevice.maxVitality
		{
			int _mnmaxVitality;
			TypeInfo<int >::parseFromBinaryStream(&_mnmaxVitality, stream);
			maxVitality = std::move(_mnmaxVitality);
		}
		return true;

	case 0x18b9bf5d: //PetControlDevice.vitalityHealthPenalty
		{
			int _mnvitalityHealthPenalty;
			TypeInfo<int >::parseFromBinaryStream(&_mnvitalityHealthPenalty, stream);
			vitalityHealthPenalty = std::move(_mnvitalityHealthPenalty);
		}
		return true;

	case 0xd90608d8: //PetControlDevice.vitalityActionPenalty
		{
			int _mnvitalityActionPenalty;
			TypeInfo<int >::parseFromBinaryStream(&_mnvitalityActionPenalty, stream);
			vitalityActionPenalty = std::move(_mnvitalityActionPenalty);
		}
		return true;

	case 0x71cecd33: //PetControlDevice.vitalityMindPenalty
		{
			int _mnvitalityMindPenalty;
			TypeInfo<int >::parseFromBinaryStream(&_mnvitalityMindPenalty, stream);
			vitalityMindPenalty = std::move(_mnvitalityMindPenalty);
		}
		return true;

	case 0xcf56d4ca: //PetControlDevice.petType
		{
			int _mnpetType;
			TypeInfo<int >::parseFromBinaryStream(&_mnpetType, stream);
			petType = std::move(_mnpetType);
		}
		return true;

	case 0xe6b502f5: //PetControlDevice.trainedCommands
		{
			VectorMap<unsigned int, String> _mntrainedCommands;
			TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&_mntrainedCommands, stream);
			trainedCommands = std::move(_mntrainedCommands);
		}
		return true;

	case 0xe3ac3453: //PetControlDevice.trainingCommand
		{
			unsigned int _mntrainingCommand;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mntrainingCommand, stream);
			trainingCommand = std::move(_mntrainingCommand);
		}
		return true;

	case 0xb8a0b38: //PetControlDevice.lastCommand
		{
			unsigned int _mnlastCommand;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnlastCommand, stream);
			lastCommand = std::move(_mnlastCommand);
		}
		return true;

	case 0x25729aff: //PetControlDevice.lastCommandTarget
		{
			ManagedWeakReference<SceneObjectPOD* > _mnlastCommandTarget;
			TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::parseFromBinaryStream(&_mnlastCommandTarget, stream);
			lastCommandTarget = std::move(_mnlastCommandTarget);
		}
		return true;

	case 0xfd1388b7: //PetControlDevice.futureName
		{
			String _mnfutureName;
			TypeInfo<String >::parseFromBinaryStream(&_mnfutureName, stream);
			futureName = std::move(_mnfutureName);
		}
		return true;

	case 0x7c4bff3f: //PetControlDevice.namingProgress
		{
			unsigned int _mnnamingProgress;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnnamingProgress, stream);
			namingProgress = std::move(_mnnamingProgress);
		}
		return true;

	case 0xb913c3b9: //PetControlDevice.growthStage
		{
			int _mngrowthStage;
			TypeInfo<int >::parseFromBinaryStream(&_mngrowthStage, stream);
			growthStage = std::move(_mngrowthStage);
		}
		return true;

	case 0x7c2f6962: //PetControlDevice.lastGrowth
		{
			Time _mnlastGrowth;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlastGrowth, stream);
			lastGrowth = std::move(_mnlastGrowth);
		}
		return true;

	case 0xf653f7fd: //PetControlDevice.trainedAsMount
		{
			bool _mntrainedAsMount;
			TypeInfo<bool >::parseFromBinaryStream(&_mntrainedAsMount, stream);
			trainedAsMount = std::move(_mntrainedAsMount);
		}
		return true;

	case 0x87035d9b: //PetControlDevice.namingCommands
		{
			Vector<unsigned int> _mnnamingCommands;
			TypeInfo<Vector<unsigned int> >::parseFromBinaryStream(&_mnnamingCommands, stream);
			namingCommands = std::move(_mnnamingCommands);
		}
		return true;

	case 0x325a288c: //PetControlDevice.patrolPoints
		{
			PatrolPointsVector _mnpatrolPoints;
			TypeInfo<PatrolPointsVector >::parseFromBinaryStream(&_mnpatrolPoints, stream);
			patrolPoints = std::move(_mnpatrolPoints);
		}
		return true;

	case 0xc5759ac4: //PetControlDevice.useRanged
		{
			bool _mnuseRanged;
			TypeInfo<bool >::parseFromBinaryStream(&_mnuseRanged, stream);
			useRanged = std::move(_mnuseRanged);
		}
		return true;

	}

	return false;
}

void PetControlDevicePOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PetControlDevicePOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void PetControlDevicePOD::writeObjectCompact(ObjectOutputStream* stream) {
	ControlDevicePOD::writeObjectCompact(stream);

	TypeInfo<ManagedReference<PetControlObserverPOD* > >::toBinaryStream(&petControlObserver.value(), stream);

	TypeInfo<int >::toBinaryStream(&vitality.value(), stream);

	TypeInfo<int >::toBinaryStream(&maxVitality.value(), stream);

	TypeInfo<int >::toBinaryStream(&vitalityHealthPenalty.value(), stream);

	TypeInfo<int >::toBinaryStream(&vitalityActionPenalty.value(), stream);

	TypeInfo<int >::toBinaryStream(&vitalityMindPenalty.value(), stream);

	TypeInfo<int >::toBinaryStream(&petType.value(), stream);

	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&trainedCommands.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&trainingCommand.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&lastCommand.value(), stream);

	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&lastCommandTarget.value(), stream);

	TypeInfo<String >::toBinaryStream(&futureName.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&namingProgress.value(), stream);

	TypeInfo<int >::toBinaryStream(&growthStage.value(), stream);

	TypeInfo<Time >::toBinaryStream(&lastGrowth.value(), stream);

	TypeInfo<bool >::toBinaryStream(&trainedAsMount.value(), stream);

	TypeInfo<Vector<unsigned int> >::toBinaryStream(&namingCommands.value(), stream);

	TypeInfo<PatrolPointsVector >::toBinaryStream(&patrolPoints.value(), stream);

	TypeInfo<bool >::toBinaryStream(&useRanged.value(), stream);


}

