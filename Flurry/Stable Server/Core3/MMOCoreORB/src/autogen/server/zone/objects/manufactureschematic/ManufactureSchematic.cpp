/*
 *	autogen/server/zone/objects/manufactureschematic/ManufactureSchematic.cpp generated by engine3 IDL compiler 0.70
 */

#include "ManufactureSchematic.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/objects/draftschematic/DraftSchematic.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/objects/installation/factory/FactoryObject.h"

/*
 *	ManufactureSchematicStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 3732900343,RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SYNCHRONIZEDUILISTEN__CREATUREOBJECT_INT_,RPC_SYNCHRONIZEDUISTOPLISTEN__CREATUREOBJECT_INT_,RPC_ISMANUFACTURESCHEMATIC__,RPC_SETDRAFTSCHEMATIC__DRAFTSCHEMATIC_,RPC_ADDINGREDIENTTOSLOT__CREATUREOBJECT_SCENEOBJECT_TANGIBLEOBJECT_INT_,RPC_REMOVEINGREDIENTFROMSLOT__CREATUREOBJECT_TANGIBLEOBJECT_INT_,RPC_CLEANUPINGREDIENTSLOTS__CREATUREOBJECT_,RPC_GETDRAFTSCHEMATIC__,RPC_INCREASECOMPLEXITY__,RPC_DECREASECOMPLEXITY__,RPC_GETCOMPLEXITY__,RPC_ISREADYFORASSEMBLY__,RPC_SETASSEMBLED__,RPC_ISASSEMBLED__,RPC_SETCOMPLETED__,RPC_ISCOMPLETED__,RPC_GETSLOTCOUNT__,RPC_SETCRAFTER__CREATUREOBJECT_,RPC_GETCRAFTER__,RPC_SETEXPERIMENTINGCOUNTER__INT_,RPC_GETEXPERIMENTINGCOUNTER__,RPC_GETEXPERIMENTINGCOUNTERPREVIOUS__,RPC_GETINGREDIENTCOUNTER__,RPC_SETMANUFACTURELIMIT__INT_,RPC_GETMANUFACTURELIMIT__,RPC_SETPROTOTYPE__TANGIBLEOBJECT_,RPC_GETPROTOTYPE__,RPC_CANMANUFACTUREITEM__STRING_STRING_,RPC_MANUFACTUREITEM__FACTORYOBJECT_,RPC_CREATEFACTORYBLUEPRINT__,RPC_GETBLUEPRINTSIZE__,RPC_GETFACTORYCRATESIZE__,RPC_ALLOWFACTORYRUN__,RPC_GETLABRATORY__};

ManufactureSchematic::ManufactureSchematic() : IntangibleObject(DummyConstructorParameter::instance()) {
	ManufactureSchematicImplementation* _implementation = new ManufactureSchematicImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("ManufactureSchematic");
}

ManufactureSchematic::ManufactureSchematic(DummyConstructorParameter* param) : IntangibleObject(param) {
	_setClassName("ManufactureSchematic");
}

ManufactureSchematic::~ManufactureSchematic() {
}



void ManufactureSchematic::initializeTransientMembers() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void ManufactureSchematic::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

void ManufactureSchematic::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);
		method.addBooleanParameter(forceLoadContainer);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendTo(player, doClose, forceLoadContainer);
	}
}

void ManufactureSchematic::sendBaselinesTo(SceneObject* player) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

void ManufactureSchematic::synchronizedUIListen(CreatureObject* player, int value) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SYNCHRONIZEDUILISTEN__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->synchronizedUIListen(player, value);
	}
}

void ManufactureSchematic::synchronizedUIStopListen(CreatureObject* player, int value) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SYNCHRONIZEDUISTOPLISTEN__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->synchronizedUIStopListen(player, value);
	}
}

bool ManufactureSchematic::isManufactureSchematic() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMANUFACTURESCHEMATIC__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isManufactureSchematic();
	}
}

void ManufactureSchematic::setDraftSchematic(DraftSchematic* schematic) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDRAFTSCHEMATIC__DRAFTSCHEMATIC_);
		method.addObjectParameter(schematic);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDraftSchematic(schematic);
	}
}

int ManufactureSchematic::addIngredientToSlot(CreatureObject* player, SceneObject* satchel, TangibleObject* tano, int slot) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDINGREDIENTTOSLOT__CREATUREOBJECT_SCENEOBJECT_TANGIBLEOBJECT_INT_);
		method.addObjectParameter(player);
		method.addObjectParameter(satchel);
		method.addObjectParameter(tano);
		method.addSignedIntParameter(slot);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->addIngredientToSlot(player, satchel, tano, slot);
	}
}

int ManufactureSchematic::removeIngredientFromSlot(CreatureObject* player, TangibleObject* tano, int slot) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEINGREDIENTFROMSLOT__CREATUREOBJECT_TANGIBLEOBJECT_INT_);
		method.addObjectParameter(player);
		method.addObjectParameter(tano);
		method.addSignedIntParameter(slot);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->removeIngredientFromSlot(player, tano, slot);
	}
}

void ManufactureSchematic::cleanupIngredientSlots(CreatureObject* player) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEANUPINGREDIENTSLOTS__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->cleanupIngredientSlots(player);
	}
}

DraftSchematic* ManufactureSchematic::getDraftSchematic() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDRAFTSCHEMATIC__);

		return static_cast<DraftSchematic*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getDraftSchematic();
	}
}

void ManufactureSchematic::increaseComplexity() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREASECOMPLEXITY__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->increaseComplexity();
	}
}

void ManufactureSchematic::decreaseComplexity() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASECOMPLEXITY__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->decreaseComplexity();
	}
}

float ManufactureSchematic::getComplexity() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOMPLEXITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getComplexity();
	}
}

bool ManufactureSchematic::isReadyForAssembly() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISREADYFORASSEMBLY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isReadyForAssembly();
	}
}

void ManufactureSchematic::setAssembled() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETASSEMBLED__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAssembled();
	}
}

bool ManufactureSchematic::isAssembled() const {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISASSEMBLED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAssembled();
	}
}

void ManufactureSchematic::setCompleted() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMPLETED__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCompleted();
	}
}

bool ManufactureSchematic::isCompleted() const {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCOMPLETED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCompleted();
	}
}

int ManufactureSchematic::getSlotCount() const {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSLOTCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSlotCount();
	}
}

IngredientSlot* ManufactureSchematic::getSlot(int i) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSlot(i);
	}
}

void ManufactureSchematic::setCrafter(CreatureObject* player) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCRAFTER__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCrafter(player);
	}
}

ManagedWeakReference<CreatureObject* > ManufactureSchematic::getCrafter() const {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCRAFTER__);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getCrafter();
	}
}

CraftingValues* ManufactureSchematic::getCraftingValues() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCraftingValues();
	}
}

void ManufactureSchematic::setExperimentingCounter(int value) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETEXPERIMENTINGCOUNTER__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setExperimentingCounter(value);
	}
}

int ManufactureSchematic::getExperimentingCounter() const {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETEXPERIMENTINGCOUNTER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getExperimentingCounter();
	}
}

int ManufactureSchematic::getExperimentingCounterPrevious() const {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETEXPERIMENTINGCOUNTERPREVIOUS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getExperimentingCounterPrevious();
	}
}

int ManufactureSchematic::getIngredientCounter() const {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINGREDIENTCOUNTER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getIngredientCounter();
	}
}

void ManufactureSchematic::setManufactureLimit(int limit) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMANUFACTURELIMIT__INT_);
		method.addSignedIntParameter(limit);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setManufactureLimit(limit);
	}
}

int ManufactureSchematic::getManufactureLimit() const {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMANUFACTURELIMIT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getManufactureLimit();
	}
}

void ManufactureSchematic::setPrototype(TangibleObject* tano) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPROTOTYPE__TANGIBLEOBJECT_);
		method.addObjectParameter(tano);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPrototype(tano);
	}
}

TangibleObject* ManufactureSchematic::getPrototype() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPROTOTYPE__);

		return static_cast<TangibleObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getPrototype();
	}
}

void ManufactureSchematic::canManufactureItem(String& type, String& displayedName) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANMANUFACTUREITEM__STRING_STRING_);
		method.addAsciiParameter(type);
		method.addAsciiParameter(displayedName);

		method.executeWithVoidReturn();
	} else {
		_implementation->canManufactureItem(type, displayedName);
	}
}

void ManufactureSchematic::manufactureItem(FactoryObject* factory) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_MANUFACTUREITEM__FACTORYOBJECT_);
		method.addObjectParameter(factory);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->manufactureItem(factory);
	}
}

void ManufactureSchematic::createFactoryBlueprint() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEFACTORYBLUEPRINT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->createFactoryBlueprint();
	}
}

int ManufactureSchematic::getBlueprintSize() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBLUEPRINTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBlueprintSize();
	}
}

BlueprintEntry* ManufactureSchematic::getBlueprintEntry(int i) {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getBlueprintEntry(i);
	}
}

int ManufactureSchematic::getFactoryCrateSize() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTORYCRATESIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFactoryCrateSize();
	}
}

bool ManufactureSchematic::allowFactoryRun() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ALLOWFACTORYRUN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->allowFactoryRun();
	}
}

int ManufactureSchematic::getLabratory() {
	ManufactureSchematicImplementation* _implementation = static_cast<ManufactureSchematicImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLABRATORY__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getLabratory();
	}
}

DistributedObjectServant* ManufactureSchematic::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* ManufactureSchematic::_getImplementationForRead() const {
	return _impl;
}

void ManufactureSchematic::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ManufactureSchematicImplementation
 */

ManufactureSchematicImplementation::ManufactureSchematicImplementation(DummyConstructorParameter* param) : IntangibleObjectImplementation(param) {
	_initializeImplementation();
}


ManufactureSchematicImplementation::~ManufactureSchematicImplementation() {
}


void ManufactureSchematicImplementation::finalize() {
}

void ManufactureSchematicImplementation::_initializeImplementation() {
	_setClassHelper(ManufactureSchematicHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ManufactureSchematicImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<ManufactureSchematic*>(stub);
	IntangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ManufactureSchematicImplementation::_getStub() {
	return _this.get();
}

ManufactureSchematicImplementation::operator const ManufactureSchematic*() {
	return _this.get();
}

void ManufactureSchematicImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ManufactureSchematicImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ManufactureSchematicImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ManufactureSchematicImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ManufactureSchematicImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ManufactureSchematicImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ManufactureSchematicImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ManufactureSchematicImplementation::_serializationHelperMethod() {
	IntangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("ManufactureSchematic");

}

void ManufactureSchematicImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ManufactureSchematicImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ManufactureSchematicImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (IntangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x4b5af35: //ManufactureSchematic.draftSchematic
		TypeInfo<ManagedReference<DraftSchematic* > >::parseFromBinaryStream(&draftSchematic, stream);
		return true;

	case 0xcb5711a2: //ManufactureSchematic.prototype
		TypeInfo<ManagedReference<TangibleObject* > >::parseFromBinaryStream(&prototype, stream);
		return true;

	case 0x4904038a: //ManufactureSchematic.dataSize
		TypeInfo<float >::parseFromBinaryStream(&dataSize, stream);
		return true;

	case 0x8f59b3aa: //ManufactureSchematic.manufactureLimit
		TypeInfo<int >::parseFromBinaryStream(&manufactureLimit, stream);
		return true;

	case 0x3ca4c59b: //ManufactureSchematic.complexity
		TypeInfo<float >::parseFromBinaryStream(&complexity, stream);
		return true;

	case 0xdf94c6a8: //ManufactureSchematic.crafter
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&crafter, stream);
		return true;

	case 0xd54d020c: //ManufactureSchematic.factoryBlueprint
		TypeInfo<FactoryBlueprint >::parseFromBinaryStream(&factoryBlueprint, stream);
		return true;

	case 0x3e614c3b: //ManufactureSchematic.customizationOptions
		TypeInfo<Vector<byte> >::parseFromBinaryStream(&customizationOptions, stream);
		return true;

	case 0x438dcae2: //ManufactureSchematic.customizationDefaultValues
		TypeInfo<Vector<byte> >::parseFromBinaryStream(&customizationDefaultValues, stream);
		return true;

	}

	return false;
}

void ManufactureSchematicImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ManufactureSchematicImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ManufactureSchematicImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = IntangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x4b5af35; //ManufactureSchematic.draftSchematic
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<DraftSchematic* > >::toBinaryStream(&draftSchematic, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcb5711a2; //ManufactureSchematic.prototype
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<TangibleObject* > >::toBinaryStream(&prototype, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4904038a; //ManufactureSchematic.dataSize
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&dataSize, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8f59b3aa; //ManufactureSchematic.manufactureLimit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&manufactureLimit, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3ca4c59b; //ManufactureSchematic.complexity
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&complexity, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdf94c6a8; //ManufactureSchematic.crafter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&crafter, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd54d020c; //ManufactureSchematic.factoryBlueprint
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FactoryBlueprint >::toBinaryStream(&factoryBlueprint, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3e614c3b; //ManufactureSchematic.customizationOptions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<byte> >::toBinaryStream(&customizationOptions, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x438dcae2; //ManufactureSchematic.customizationDefaultValues
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<byte> >::toBinaryStream(&customizationDefaultValues, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void ManufactureSchematicImplementation::writeJSON(nlohmann::json& j) {
	IntangibleObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["draftSchematic"] = draftSchematic;

	thisObject["prototype"] = prototype;

	thisObject["dataSize"] = dataSize;

	thisObject["manufactureLimit"] = manufactureLimit;

	thisObject["complexity"] = complexity;

	thisObject["crafter"] = crafter;

	thisObject["factoryBlueprint"] = factoryBlueprint;

	thisObject["customizationOptions"] = customizationOptions;

	thisObject["customizationDefaultValues"] = customizationDefaultValues;

	j["ManufactureSchematic"] = thisObject;
}

ManufactureSchematicImplementation::ManufactureSchematicImplementation() {
	_initializeImplementation();
	Reference<CraftingValues*> _ref0;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		Logger.setLoggingName("ManufactureSchematic");
	Logger::setLoggingName("ManufactureSchematic");
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		craftingValues = new CraftingValues();
	craftingValues = _ref0 = new CraftingValues();
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		prototype = null;
	prototype = NULL;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		draftSchematic = null;
	draftSchematic = NULL;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		dataSize = 0;
	dataSize = 0;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		complexity = 0;
	complexity = 0;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		crafter = null;
	crafter = NULL;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		assembled = false;
	assembled = false;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		completed = false;
	completed = false;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		initialized = false;
	initialized = false;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		ingredientCounter = 0;
	ingredientCounter = 0;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		experimentingCounter = 0;
	experimentingCounter = 0;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		experimentingCounterPrevious = 0;
	experimentingCounterPrevious = 0;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		possibleSyncIssue = false;
	possibleSyncIssue = false;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		manufactureLimit = 1000;
	manufactureLimit = 1000;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		ContainerPermissions permissions = super.getContainerPermissionsForUpdate();
	ContainerPermissions* permissions = IntangibleObjectImplementation::getContainerPermissionsForUpdate();
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		permissions.setInheritPermissionsFromParent(true);
	permissions->setInheritPermissionsFromParent(true);
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		permissions.clearDefaultDenyPermission(ContainerPermissions.MOVECONTAINER);
	permissions->clearDefaultDenyPermission(ContainerPermissions::MOVECONTAINER);
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		permissions.clearDenyPermission("owner", ContainerPermissions.MOVECONTAINER);
	permissions->clearDenyPermission("owner", ContainerPermissions::MOVECONTAINER);
}

void ManufactureSchematicImplementation::initializeTransientMembers() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		super.initializeTransientMembers();
	IntangibleObjectImplementation::initializeTransientMembers();
}

bool ManufactureSchematicImplementation::isManufactureSchematic() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return true;
	return true;
}

DraftSchematic* ManufactureSchematicImplementation::getDraftSchematic() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return draftSchematic;
	return draftSchematic;
}

void ManufactureSchematicImplementation::increaseComplexity() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		complexity++;
	complexity ++;
}

void ManufactureSchematicImplementation::decreaseComplexity() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  	}
	if (complexity > 1)	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  			complexity = complexity - 1;
	complexity = complexity - 1;
}

float ManufactureSchematicImplementation::getComplexity() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return complexity;
	return complexity;
}

bool ManufactureSchematicImplementation::isAssembled() const{
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return assembled;
	return assembled;
}

void ManufactureSchematicImplementation::setCompleted() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		completed = true;
	completed = true;
}

bool ManufactureSchematicImplementation::isCompleted() const{
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return completed;
	return completed;
}

int ManufactureSchematicImplementation::getSlotCount() const{
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return ingredientSlots.size();
	return (&ingredientSlots)->size();
}

IngredientSlot* ManufactureSchematicImplementation::getSlot(int i) {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return ingredientSlots.get(i);
	return (&ingredientSlots)->get(i);
}

void ManufactureSchematicImplementation::setCrafter(CreatureObject* player) {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		crafter = player;
	crafter = player;
}

ManagedWeakReference<CreatureObject* > ManufactureSchematicImplementation::getCrafter() const{
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return crafter;
	return crafter;
}

CraftingValues* ManufactureSchematicImplementation::getCraftingValues() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return craftingValues;
	return craftingValues;
}

void ManufactureSchematicImplementation::setExperimentingCounter(int value) {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		experimentingCounterPrevious = experimentingCounter;
	experimentingCounterPrevious = experimentingCounter;
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		experimentingCounter = value;
	experimentingCounter = value;
}

int ManufactureSchematicImplementation::getExperimentingCounter() const{
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return experimentingCounter;
	return experimentingCounter;
}

int ManufactureSchematicImplementation::getExperimentingCounterPrevious() const{
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return experimentingCounterPrevious;
	return experimentingCounterPrevious;
}

void ManufactureSchematicImplementation::updateIngredientCounter() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		ingredientCounter += 4;
	ingredientCounter += 4;
}

int ManufactureSchematicImplementation::getIngredientCounter() const{
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return ingredientCounter;
	return ingredientCounter;
}

void ManufactureSchematicImplementation::setManufactureLimit(int limit) {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		manufactureLimit = limit;
	manufactureLimit = limit;
}

int ManufactureSchematicImplementation::getManufactureLimit() const{
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return manufactureLimit;
	return manufactureLimit;
}

TangibleObject* ManufactureSchematicImplementation::getPrototype() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return prototype;
	return prototype;
}

void ManufactureSchematicImplementation::canManufactureItem(String& type, String& displayedName) {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		factoryBlueprint.canManufactureItem(type, displayedName);
	(&factoryBlueprint)->canManufactureItem(type, displayedName);
}

void ManufactureSchematicImplementation::manufactureItem(FactoryObject* factory) {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		factoryBlueprint.manufactureItem(factory);
	(&factoryBlueprint)->manufactureItem(factory);
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		setManufactureLimit(getManufactureLimit() - 1);
	setManufactureLimit(getManufactureLimit() - 1);
}

int ManufactureSchematicImplementation::getBlueprintSize() {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return factoryBlueprint.getConsolidatedSize();
	return (&factoryBlueprint)->getConsolidatedSize();
}

BlueprintEntry* ManufactureSchematicImplementation::getBlueprintEntry(int i) {
	// server/zone/objects/manufactureschematic/ManufactureSchematic.idl():  		return factoryBlueprint.getConsolidatedEntry(i);
	return (&factoryBlueprint)->getConsolidatedEntry(i);
}

/*
 *	ManufactureSchematicAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ManufactureSchematicAdapter::ManufactureSchematicAdapter(ManufactureSchematic* obj) : IntangibleObjectAdapter(obj) {
}

void ManufactureSchematicAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			bool doClose = inv->getBooleanParameter();
			bool forceLoadContainer = inv->getBooleanParameter();
			
			sendTo(player, doClose, forceLoadContainer);
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_SYNCHRONIZEDUILISTEN__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int value = inv->getSignedIntParameter();
			
			synchronizedUIListen(player, value);
			
		}
		break;
	case RPC_SYNCHRONIZEDUISTOPLISTEN__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int value = inv->getSignedIntParameter();
			
			synchronizedUIStopListen(player, value);
			
		}
		break;
	case RPC_ISMANUFACTURESCHEMATIC__:
		{
			
			bool _m_res = isManufactureSchematic();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETDRAFTSCHEMATIC__DRAFTSCHEMATIC_:
		{
			DraftSchematic* schematic = static_cast<DraftSchematic*>(inv->getObjectParameter());
			
			setDraftSchematic(schematic);
			
		}
		break;
	case RPC_ADDINGREDIENTTOSLOT__CREATUREOBJECT_SCENEOBJECT_TANGIBLEOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			SceneObject* satchel = static_cast<SceneObject*>(inv->getObjectParameter());
			TangibleObject* tano = static_cast<TangibleObject*>(inv->getObjectParameter());
			int slot = inv->getSignedIntParameter();
			
			int _m_res = addIngredientToSlot(player, satchel, tano, slot);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_REMOVEINGREDIENTFROMSLOT__CREATUREOBJECT_TANGIBLEOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			TangibleObject* tano = static_cast<TangibleObject*>(inv->getObjectParameter());
			int slot = inv->getSignedIntParameter();
			
			int _m_res = removeIngredientFromSlot(player, tano, slot);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CLEANUPINGREDIENTSLOTS__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			cleanupIngredientSlots(player);
			
		}
		break;
	case RPC_GETDRAFTSCHEMATIC__:
		{
			
			DistributedObject* _m_res = getDraftSchematic();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_INCREASECOMPLEXITY__:
		{
			
			increaseComplexity();
			
		}
		break;
	case RPC_DECREASECOMPLEXITY__:
		{
			
			decreaseComplexity();
			
		}
		break;
	case RPC_GETCOMPLEXITY__:
		{
			
			float _m_res = getComplexity();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ISREADYFORASSEMBLY__:
		{
			
			bool _m_res = isReadyForAssembly();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETASSEMBLED__:
		{
			
			setAssembled();
			
		}
		break;
	case RPC_ISASSEMBLED__:
		{
			
			bool _m_res = isAssembled();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCOMPLETED__:
		{
			
			setCompleted();
			
		}
		break;
	case RPC_ISCOMPLETED__:
		{
			
			bool _m_res = isCompleted();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSLOTCOUNT__:
		{
			
			int _m_res = getSlotCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETCRAFTER__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			setCrafter(player);
			
		}
		break;
	case RPC_GETCRAFTER__:
		{
			
			DistributedObject* _m_res = getCrafter().get();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_SETEXPERIMENTINGCOUNTER__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			setExperimentingCounter(value);
			
		}
		break;
	case RPC_GETEXPERIMENTINGCOUNTER__:
		{
			
			int _m_res = getExperimentingCounter();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETEXPERIMENTINGCOUNTERPREVIOUS__:
		{
			
			int _m_res = getExperimentingCounterPrevious();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETINGREDIENTCOUNTER__:
		{
			
			int _m_res = getIngredientCounter();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMANUFACTURELIMIT__INT_:
		{
			int limit = inv->getSignedIntParameter();
			
			setManufactureLimit(limit);
			
		}
		break;
	case RPC_GETMANUFACTURELIMIT__:
		{
			
			int _m_res = getManufactureLimit();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETPROTOTYPE__TANGIBLEOBJECT_:
		{
			TangibleObject* tano = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			setPrototype(tano);
			
		}
		break;
	case RPC_GETPROTOTYPE__:
		{
			
			DistributedObject* _m_res = getPrototype();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_CANMANUFACTUREITEM__STRING_STRING_:
		{
			String type; inv->getAsciiParameter(type);
			String displayedName; inv->getAsciiParameter(displayedName);
			
			canManufactureItem(type, displayedName);
			
		}
		break;
	case RPC_MANUFACTUREITEM__FACTORYOBJECT_:
		{
			FactoryObject* factory = static_cast<FactoryObject*>(inv->getObjectParameter());
			
			manufactureItem(factory);
			
		}
		break;
	case RPC_CREATEFACTORYBLUEPRINT__:
		{
			
			createFactoryBlueprint();
			
		}
		break;
	case RPC_GETBLUEPRINTSIZE__:
		{
			
			int _m_res = getBlueprintSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFACTORYCRATESIZE__:
		{
			
			int _m_res = getFactoryCrateSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ALLOWFACTORYRUN__:
		{
			
			bool _m_res = allowFactoryRun();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETLABRATORY__:
		{
			
			int _m_res = getLabratory();
			resp->insertSignedInt(_m_res);
		}
		break;
	default:
		IntangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

void ManufactureSchematicAdapter::initializeTransientMembers() {
	(static_cast<ManufactureSchematic*>(stub))->initializeTransientMembers();
}

void ManufactureSchematicAdapter::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	(static_cast<ManufactureSchematic*>(stub))->sendTo(player, doClose, forceLoadContainer);
}

void ManufactureSchematicAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<ManufactureSchematic*>(stub))->sendBaselinesTo(player);
}

void ManufactureSchematicAdapter::synchronizedUIListen(CreatureObject* player, int value) {
	(static_cast<ManufactureSchematic*>(stub))->synchronizedUIListen(player, value);
}

void ManufactureSchematicAdapter::synchronizedUIStopListen(CreatureObject* player, int value) {
	(static_cast<ManufactureSchematic*>(stub))->synchronizedUIStopListen(player, value);
}

bool ManufactureSchematicAdapter::isManufactureSchematic() {
	return (static_cast<ManufactureSchematic*>(stub))->isManufactureSchematic();
}

void ManufactureSchematicAdapter::setDraftSchematic(DraftSchematic* schematic) {
	(static_cast<ManufactureSchematic*>(stub))->setDraftSchematic(schematic);
}

int ManufactureSchematicAdapter::addIngredientToSlot(CreatureObject* player, SceneObject* satchel, TangibleObject* tano, int slot) {
	return (static_cast<ManufactureSchematic*>(stub))->addIngredientToSlot(player, satchel, tano, slot);
}

int ManufactureSchematicAdapter::removeIngredientFromSlot(CreatureObject* player, TangibleObject* tano, int slot) {
	return (static_cast<ManufactureSchematic*>(stub))->removeIngredientFromSlot(player, tano, slot);
}

void ManufactureSchematicAdapter::cleanupIngredientSlots(CreatureObject* player) {
	(static_cast<ManufactureSchematic*>(stub))->cleanupIngredientSlots(player);
}

DraftSchematic* ManufactureSchematicAdapter::getDraftSchematic() {
	return (static_cast<ManufactureSchematic*>(stub))->getDraftSchematic();
}

void ManufactureSchematicAdapter::increaseComplexity() {
	(static_cast<ManufactureSchematic*>(stub))->increaseComplexity();
}

void ManufactureSchematicAdapter::decreaseComplexity() {
	(static_cast<ManufactureSchematic*>(stub))->decreaseComplexity();
}

float ManufactureSchematicAdapter::getComplexity() {
	return (static_cast<ManufactureSchematic*>(stub))->getComplexity();
}

bool ManufactureSchematicAdapter::isReadyForAssembly() {
	return (static_cast<ManufactureSchematic*>(stub))->isReadyForAssembly();
}

void ManufactureSchematicAdapter::setAssembled() {
	(static_cast<ManufactureSchematic*>(stub))->setAssembled();
}

bool ManufactureSchematicAdapter::isAssembled() const {
	return (static_cast<ManufactureSchematic*>(stub))->isAssembled();
}

void ManufactureSchematicAdapter::setCompleted() {
	(static_cast<ManufactureSchematic*>(stub))->setCompleted();
}

bool ManufactureSchematicAdapter::isCompleted() const {
	return (static_cast<ManufactureSchematic*>(stub))->isCompleted();
}

int ManufactureSchematicAdapter::getSlotCount() const {
	return (static_cast<ManufactureSchematic*>(stub))->getSlotCount();
}

void ManufactureSchematicAdapter::setCrafter(CreatureObject* player) {
	(static_cast<ManufactureSchematic*>(stub))->setCrafter(player);
}

ManagedWeakReference<CreatureObject* > ManufactureSchematicAdapter::getCrafter() const {
	return (static_cast<ManufactureSchematic*>(stub))->getCrafter();
}

void ManufactureSchematicAdapter::setExperimentingCounter(int value) {
	(static_cast<ManufactureSchematic*>(stub))->setExperimentingCounter(value);
}

int ManufactureSchematicAdapter::getExperimentingCounter() const {
	return (static_cast<ManufactureSchematic*>(stub))->getExperimentingCounter();
}

int ManufactureSchematicAdapter::getExperimentingCounterPrevious() const {
	return (static_cast<ManufactureSchematic*>(stub))->getExperimentingCounterPrevious();
}

int ManufactureSchematicAdapter::getIngredientCounter() const {
	return (static_cast<ManufactureSchematic*>(stub))->getIngredientCounter();
}

void ManufactureSchematicAdapter::setManufactureLimit(int limit) {
	(static_cast<ManufactureSchematic*>(stub))->setManufactureLimit(limit);
}

int ManufactureSchematicAdapter::getManufactureLimit() const {
	return (static_cast<ManufactureSchematic*>(stub))->getManufactureLimit();
}

void ManufactureSchematicAdapter::setPrototype(TangibleObject* tano) {
	(static_cast<ManufactureSchematic*>(stub))->setPrototype(tano);
}

TangibleObject* ManufactureSchematicAdapter::getPrototype() {
	return (static_cast<ManufactureSchematic*>(stub))->getPrototype();
}

void ManufactureSchematicAdapter::canManufactureItem(String& type, String& displayedName) {
	(static_cast<ManufactureSchematic*>(stub))->canManufactureItem(type, displayedName);
}

void ManufactureSchematicAdapter::manufactureItem(FactoryObject* factory) {
	(static_cast<ManufactureSchematic*>(stub))->manufactureItem(factory);
}

void ManufactureSchematicAdapter::createFactoryBlueprint() {
	(static_cast<ManufactureSchematic*>(stub))->createFactoryBlueprint();
}

int ManufactureSchematicAdapter::getBlueprintSize() {
	return (static_cast<ManufactureSchematic*>(stub))->getBlueprintSize();
}

int ManufactureSchematicAdapter::getFactoryCrateSize() {
	return (static_cast<ManufactureSchematic*>(stub))->getFactoryCrateSize();
}

bool ManufactureSchematicAdapter::allowFactoryRun() {
	return (static_cast<ManufactureSchematic*>(stub))->allowFactoryRun();
}

int ManufactureSchematicAdapter::getLabratory() {
	return (static_cast<ManufactureSchematic*>(stub))->getLabratory();
}

/*
 *	ManufactureSchematicHelper
 */

ManufactureSchematicHelper* ManufactureSchematicHelper::staticInitializer = ManufactureSchematicHelper::instance();

ManufactureSchematicHelper::ManufactureSchematicHelper() {
	className = "ManufactureSchematic";

	Core::getObjectBroker()->registerClass(className, this);
}

void ManufactureSchematicHelper::finalizeHelper() {
	ManufactureSchematicHelper::finalize();
}

DistributedObject* ManufactureSchematicHelper::instantiateObject() {
	return new ManufactureSchematic(DummyConstructorParameter::instance());
}

DistributedObjectServant* ManufactureSchematicHelper::instantiateServant() {
	return new ManufactureSchematicImplementation();
}

DistributedObjectPOD* ManufactureSchematicHelper::instantiatePOD() {
	return new ManufactureSchematicPOD();
}

DistributedObjectAdapter* ManufactureSchematicHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ManufactureSchematicAdapter(static_cast<ManufactureSchematic*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	ManufactureSchematicPOD
 */

ManufactureSchematicPOD::~ManufactureSchematicPOD() {
	finalize();
}

ManufactureSchematicPOD::ManufactureSchematicPOD(void) {
	_className = "ManufactureSchematic";
}


void ManufactureSchematicPOD::writeJSON(nlohmann::json& j) {
	IntangibleObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (draftSchematic)
		thisObject["draftSchematic"] = draftSchematic.value();

	if (prototype)
		thisObject["prototype"] = prototype.value();

	if (dataSize)
		thisObject["dataSize"] = dataSize.value();

	if (manufactureLimit)
		thisObject["manufactureLimit"] = manufactureLimit.value();

	if (complexity)
		thisObject["complexity"] = complexity.value();

	if (crafter)
		thisObject["crafter"] = crafter.value();

	if (factoryBlueprint)
		thisObject["factoryBlueprint"] = factoryBlueprint.value();

	if (customizationOptions)
		thisObject["customizationOptions"] = customizationOptions.value();

	if (customizationDefaultValues)
		thisObject["customizationDefaultValues"] = customizationDefaultValues.value();

	j["ManufactureSchematic"] = thisObject;
}


void ManufactureSchematicPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ManufactureSchematicPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ManufactureSchematicPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = IntangibleObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (draftSchematic) {
	_nameHashCode = 0x4b5af35; //ManufactureSchematic.draftSchematic
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<DraftSchematicPOD* > >::toBinaryStream(&draftSchematic.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (prototype) {
	_nameHashCode = 0xcb5711a2; //ManufactureSchematic.prototype
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<TangibleObjectPOD* > >::toBinaryStream(&prototype.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dataSize) {
	_nameHashCode = 0x4904038a; //ManufactureSchematic.dataSize
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&dataSize.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (manufactureLimit) {
	_nameHashCode = 0x8f59b3aa; //ManufactureSchematic.manufactureLimit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&manufactureLimit.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (complexity) {
	_nameHashCode = 0x3ca4c59b; //ManufactureSchematic.complexity
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&complexity.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (crafter) {
	_nameHashCode = 0xdf94c6a8; //ManufactureSchematic.crafter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::toBinaryStream(&crafter.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (factoryBlueprint) {
	_nameHashCode = 0xd54d020c; //ManufactureSchematic.factoryBlueprint
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FactoryBlueprint >::toBinaryStream(&factoryBlueprint.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (customizationOptions) {
	_nameHashCode = 0x3e614c3b; //ManufactureSchematic.customizationOptions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<byte> >::toBinaryStream(&customizationOptions.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (customizationDefaultValues) {
	_nameHashCode = 0x438dcae2; //ManufactureSchematic.customizationDefaultValues
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<byte> >::toBinaryStream(&customizationDefaultValues.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool ManufactureSchematicPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (IntangibleObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x4b5af35: //ManufactureSchematic.draftSchematic
		{
			ManagedReference<DraftSchematicPOD* > _mndraftSchematic;
			TypeInfo<ManagedReference<DraftSchematicPOD* > >::parseFromBinaryStream(&_mndraftSchematic, stream);
			draftSchematic = std::move(_mndraftSchematic);
		}
		return true;

	case 0xcb5711a2: //ManufactureSchematic.prototype
		{
			ManagedReference<TangibleObjectPOD* > _mnprototype;
			TypeInfo<ManagedReference<TangibleObjectPOD* > >::parseFromBinaryStream(&_mnprototype, stream);
			prototype = std::move(_mnprototype);
		}
		return true;

	case 0x4904038a: //ManufactureSchematic.dataSize
		{
			float _mndataSize;
			TypeInfo<float >::parseFromBinaryStream(&_mndataSize, stream);
			dataSize = std::move(_mndataSize);
		}
		return true;

	case 0x8f59b3aa: //ManufactureSchematic.manufactureLimit
		{
			int _mnmanufactureLimit;
			TypeInfo<int >::parseFromBinaryStream(&_mnmanufactureLimit, stream);
			manufactureLimit = std::move(_mnmanufactureLimit);
		}
		return true;

	case 0x3ca4c59b: //ManufactureSchematic.complexity
		{
			float _mncomplexity;
			TypeInfo<float >::parseFromBinaryStream(&_mncomplexity, stream);
			complexity = std::move(_mncomplexity);
		}
		return true;

	case 0xdf94c6a8: //ManufactureSchematic.crafter
		{
			ManagedWeakReference<CreatureObjectPOD* > _mncrafter;
			TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::parseFromBinaryStream(&_mncrafter, stream);
			crafter = std::move(_mncrafter);
		}
		return true;

	case 0xd54d020c: //ManufactureSchematic.factoryBlueprint
		{
			FactoryBlueprint _mnfactoryBlueprint;
			TypeInfo<FactoryBlueprint >::parseFromBinaryStream(&_mnfactoryBlueprint, stream);
			factoryBlueprint = std::move(_mnfactoryBlueprint);
		}
		return true;

	case 0x3e614c3b: //ManufactureSchematic.customizationOptions
		{
			Vector<byte> _mncustomizationOptions;
			TypeInfo<Vector<byte> >::parseFromBinaryStream(&_mncustomizationOptions, stream);
			customizationOptions = std::move(_mncustomizationOptions);
		}
		return true;

	case 0x438dcae2: //ManufactureSchematic.customizationDefaultValues
		{
			Vector<byte> _mncustomizationDefaultValues;
			TypeInfo<Vector<byte> >::parseFromBinaryStream(&_mncustomizationDefaultValues, stream);
			customizationDefaultValues = std::move(_mncustomizationDefaultValues);
		}
		return true;

	}

	return false;
}

void ManufactureSchematicPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ManufactureSchematicPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ManufactureSchematicPOD::writeObjectCompact(ObjectOutputStream* stream) {
	IntangibleObjectPOD::writeObjectCompact(stream);

	TypeInfo<ManagedReference<DraftSchematicPOD* > >::toBinaryStream(&draftSchematic.value(), stream);

	TypeInfo<ManagedReference<TangibleObjectPOD* > >::toBinaryStream(&prototype.value(), stream);

	TypeInfo<float >::toBinaryStream(&dataSize.value(), stream);

	TypeInfo<int >::toBinaryStream(&manufactureLimit.value(), stream);

	TypeInfo<float >::toBinaryStream(&complexity.value(), stream);

	TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::toBinaryStream(&crafter.value(), stream);

	TypeInfo<FactoryBlueprint >::toBinaryStream(&factoryBlueprint.value(), stream);

	TypeInfo<Vector<byte> >::toBinaryStream(&customizationOptions.value(), stream);

	TypeInfo<Vector<byte> >::toBinaryStream(&customizationDefaultValues.value(), stream);


}

