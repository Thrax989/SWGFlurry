/*
 *	autogen/server/zone/objects/creature/ai/Creature.cpp generated by engine3 IDL compiler 0.70
 */

#include "Creature.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/objects/creature/ai/CreatureTemplate.h"

#include "server/zone/Zone.h"

/*
 *	CreatureStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 4015475806,RPC_ISCREATURE__,RPC_GETDNASTATE__,RPC_GETDNASAMPLECOUNT__,RPC_INCDNASAMPLECOUNT__,RPC_ISCAMOUFLAGED__CREATUREOBJECT_,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_SCHEDULEDESPAWN__,RPC_HASORGANICS__,RPC_HASMILK__,RPC_HASDNA__,RPC_CANHARVESTME__CREATUREOBJECT_,RPC_CANDROIDHARVESTME__CREATUREOBJECT_CREATUREOBJECT_,RPC_HASSKILLTOHARVESTME__CREATUREOBJECT_,RPC_CANTAMEME__CREATUREOBJECT_,RPC_GETCHANCETOTAME__CREATUREOBJECT_,RPC_CANMILKME__CREATUREOBJECT_,RPC_CANCOLLECTDNA__CREATUREOBJECT_,RPC_HASSKILLTOSAMPLEME__CREATUREOBJECT_,RPC_ADDALREADYHARVESTED__CREATUREOBJECT_,RPC_SETMILKSTATE__SHORT_,RPC_SETDNASTATE__SHORT_,RPC_NOTIFYDESPAWN__ZONE_,RPC_SETPETLEVEL__INT_,RPC_ISVICIOUS__,RPC_ISBABY__,RPC_SETBABY__BOOL_,RPC_GETTAME__,RPC_GETMEATTYPE__,RPC_GETBONETYPE__,RPC_GETHIDETYPE__,RPC_GETMILKTYPE__,RPC_GETMILK__,RPC_GETHIDEMAX__,RPC_GETBONEMAX__,RPC_GETMEATMAX__,RPC_GETBASEXP__,RPC_GETCONTROLDEVICETEMPLATE__,RPC_ISMOUNT__,RPC_GETADULTLEVEL__};

Creature::Creature() : AiAgent(DummyConstructorParameter::instance()) {
	CreatureImplementation* _implementation = new CreatureImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("Creature");
}

Creature::Creature(DummyConstructorParameter* param) : AiAgent(param) {
	_setClassName("Creature");
}

Creature::~Creature() {
}



void Creature::initializeTransientMembers() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

bool Creature::isCreature() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCREATURE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCreature();
	}
}

short Creature::getDnaState() const {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDNASTATE__);

		return method.executeWithSignedShortReturn();
	} else {
		return _implementation->getDnaState();
	}
}

short Creature::getDnaSampleCount() const {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDNASAMPLECOUNT__);

		return method.executeWithSignedShortReturn();
	} else {
		return _implementation->getDnaSampleCount();
	}
}

void Creature::incDnaSampleCount() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCDNASAMPLECOUNT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->incDnaSampleCount();
	}
}

bool Creature::isCamouflaged(CreatureObject* target) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMOUFLAGED__CREATUREOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCamouflaged(target);
	}
}

void Creature::fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillObjectMenuResponse(menuResponse, player);
	}
}

int Creature::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

void Creature::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

void Creature::loadTemplateDataForBaby(CreatureTemplate* templateData) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateDataForBaby(templateData);
	}
}

void Creature::scheduleDespawn() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEDESPAWN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->scheduleDespawn();
	}
}

bool Creature::hasOrganics() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASORGANICS__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasOrganics();
	}
}

bool Creature::hasMilk() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASMILK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasMilk();
	}
}

bool Creature::hasDNA() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASDNA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasDNA();
	}
}

bool Creature::canHarvestMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANHARVESTME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canHarvestMe(player);
	}
}

bool Creature::canDroidHarvestMe(CreatureObject* player, CreatureObject* droid) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANDROIDHARVESTME__CREATUREOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(droid);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canDroidHarvestMe(player, droid);
	}
}

bool Creature::hasSkillToHarvestMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSKILLTOHARVESTME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSkillToHarvestMe(player);
	}
}

bool Creature::canTameMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANTAMEME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canTameMe(player);
	}
}

float Creature::getChanceToTame(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHANCETOTAME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getChanceToTame(player);
	}
}

bool Creature::canMilkMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANMILKME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canMilkMe(player);
	}
}

bool Creature::canCollectDna(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCOLLECTDNA__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canCollectDna(player);
	}
}

bool Creature::hasSkillToSampleMe(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSKILLTOSAMPLEME__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSkillToSampleMe(player);
	}
}

void Creature::addAlreadyHarvested(CreatureObject* player) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDALREADYHARVESTED__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addAlreadyHarvested(player);
	}
}

void Creature::setMilkState(short milkState) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMILKSTATE__SHORT_);
		method.addSignedShortParameter(milkState);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMilkState(milkState);
	}
}

void Creature::setDnaState(short dnaState) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDNASTATE__SHORT_);
		method.addSignedShortParameter(dnaState);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDnaState(dnaState);
	}
}

void Creature::notifyDespawn(Zone* zone) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYDESPAWN__ZONE_);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->notifyDespawn(zone);
	}
}

void Creature::setPetLevel(int newLevel) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPETLEVEL__INT_);
		method.addSignedIntParameter(newLevel);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPetLevel(newLevel);
	}
}

bool Creature::isVicious() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISVICIOUS__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isVicious();
	}
}

bool Creature::isBaby() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBABY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isBaby();
	}
}

void Creature::setBaby(bool bab) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBABY__BOOL_);
		method.addBooleanParameter(bab);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setBaby(bab);
	}
}

float Creature::getTame() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTAME__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getTame();
	}
}

String Creature::getMeatType() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMEATTYPE__);

		String _return_getMeatType;
		method.executeWithAsciiReturn(_return_getMeatType);
		return _return_getMeatType;
	} else {
		return _implementation->getMeatType();
	}
}

String Creature::getBoneType() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBONETYPE__);

		String _return_getBoneType;
		method.executeWithAsciiReturn(_return_getBoneType);
		return _return_getBoneType;
	} else {
		return _implementation->getBoneType();
	}
}

String Creature::getHideType() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHIDETYPE__);

		String _return_getHideType;
		method.executeWithAsciiReturn(_return_getHideType);
		return _return_getHideType;
	} else {
		return _implementation->getHideType();
	}
}

String Creature::getMilkType() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMILKTYPE__);

		String _return_getMilkType;
		method.executeWithAsciiReturn(_return_getMilkType);
		return _return_getMilkType;
	} else {
		return _implementation->getMilkType();
	}
}

float Creature::getMilk() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMILK__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMilk();
	}
}

float Creature::getHideMax() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHIDEMAX__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHideMax();
	}
}

float Creature::getBoneMax() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBONEMAX__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getBoneMax();
	}
}

float Creature::getMeatMax() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMEATMAX__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMeatMax();
	}
}

int Creature::getBaseXp() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASEXP__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseXp();
	}
}

String Creature::getControlDeviceTemplate() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONTROLDEVICETEMPLATE__);

		String _return_getControlDeviceTemplate;
		method.executeWithAsciiReturn(_return_getControlDeviceTemplate);
		return _return_getControlDeviceTemplate;
	} else {
		return _implementation->getControlDeviceTemplate();
	}
}

bool Creature::isMount() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMOUNT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMount();
	}
}

void Creature::sendMessage(BasePacket* msg) {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->sendMessage(msg);
	}
}

int Creature::getAdultLevel() {
	CreatureImplementation* _implementation = static_cast<CreatureImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETADULTLEVEL__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAdultLevel();
	}
}

DistributedObjectServant* Creature::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* Creature::_getImplementationForRead() const {
	return _impl;
}

void Creature::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	CreatureImplementation
 */

CreatureImplementation::CreatureImplementation(DummyConstructorParameter* param) : AiAgentImplementation(param) {
	_initializeImplementation();
}


CreatureImplementation::~CreatureImplementation() {
}


void CreatureImplementation::finalize() {
}

void CreatureImplementation::_initializeImplementation() {
	_setClassHelper(CreatureHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void CreatureImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<Creature*>(stub);
	AiAgentImplementation::_setStub(stub);
}

DistributedObjectStub* CreatureImplementation::_getStub() {
	return _this.get();
}

CreatureImplementation::operator const Creature*() {
	return _this.get();
}

void CreatureImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void CreatureImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void CreatureImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void CreatureImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void CreatureImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void CreatureImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void CreatureImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void CreatureImplementation::_serializationHelperMethod() {
	AiAgentImplementation::_serializationHelperMethod();

	_setClassName("Creature");

}

void CreatureImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(CreatureImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool CreatureImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (AiAgentImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xd784ea84: //Creature.milkState
		TypeInfo<short >::parseFromBinaryStream(&milkState, stream);
		return true;

	case 0x74d712e: //Creature.dnaState
		TypeInfo<short >::parseFromBinaryStream(&dnaState, stream);
		return true;

	case 0x55bbec19: //Creature.dnaSampleCount
		TypeInfo<short >::parseFromBinaryStream(&dnaSampleCount, stream);
		return true;

	case 0x49505389: //Creature.baby
		TypeInfo<bool >::parseFromBinaryStream(&baby, stream);
		return true;

	}

	return false;
}

void CreatureImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = CreatureImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int CreatureImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = AiAgentImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xd784ea84; //Creature.milkState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&milkState, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x74d712e; //Creature.dnaState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&dnaState, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x55bbec19; //Creature.dnaSampleCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&dnaSampleCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x49505389; //Creature.baby
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&baby, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void CreatureImplementation::writeJSON(nlohmann::json& j) {
	AiAgentImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["milkState"] = milkState;

	thisObject["dnaState"] = dnaState;

	thisObject["dnaSampleCount"] = dnaSampleCount;

	thisObject["baby"] = baby;

	j["Creature"] = thisObject;
}

CreatureImplementation::CreatureImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/ai/Creature.idl():  		baby = false;
	baby = false;
	// server/zone/objects/creature/ai/Creature.idl():  		Logger.setLoggingName("Creature");
	Logger::setLoggingName("Creature");
	// server/zone/objects/creature/ai/Creature.idl():  		Logger.setLogging(false);
	Logger::setLogging(false);
	// server/zone/objects/creature/ai/Creature.idl():  		Logger.setGlobalLogging(true);
	Logger::setGlobalLogging(true);
}

bool CreatureImplementation::isCreature() {
	// server/zone/objects/creature/ai/Creature.idl():  		return true;
	return true;
}

short CreatureImplementation::getDnaState() const{
	// server/zone/objects/creature/ai/Creature.idl():  		return dnaState;
	return dnaState;
}

short CreatureImplementation::getDnaSampleCount() const{
	// server/zone/objects/creature/ai/Creature.idl():  		return dnaSampleCount;
	return dnaSampleCount;
}

void CreatureImplementation::incDnaSampleCount() {
	// server/zone/objects/creature/ai/Creature.idl():  		dnaSampleCount++;
	dnaSampleCount ++;
}

bool CreatureImplementation::isCamouflaged(CreatureObject* target) {
	// server/zone/objects/creature/ai/Creature.idl():  		return isAggressiveTo(target) && (isScentMasked(target) || isConcealed(target));
	return isAggressiveTo(target) && (isScentMasked(target) || isConcealed(target));
}

bool CreatureImplementation::isBaby() {
	// server/zone/objects/creature/ai/Creature.idl():  		return baby;
	return baby;
}

void CreatureImplementation::setBaby(bool bab) {
	// server/zone/objects/creature/ai/Creature.idl():  		baby = bab;
	baby = bab;
}

float CreatureImplementation::getTame() {
	// server/zone/objects/creature/ai/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/ai/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/Creature.idl():  		return super.npcTemplate.getTame();
	return AiAgentImplementation::npcTemplate->getTame();
}

String CreatureImplementation::getMeatType() {
	// server/zone/objects/creature/ai/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/ai/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/Creature.idl():  		return super.npcTemplate.getMeatType();
	return AiAgentImplementation::npcTemplate->getMeatType();
}

String CreatureImplementation::getBoneType() {
	// server/zone/objects/creature/ai/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/ai/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/Creature.idl():  		return super.npcTemplate.getBoneType();
	return AiAgentImplementation::npcTemplate->getBoneType();
}

String CreatureImplementation::getHideType() {
	// server/zone/objects/creature/ai/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/ai/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/Creature.idl():  		return super.npcTemplate.getHideType();
	return AiAgentImplementation::npcTemplate->getHideType();
}

String CreatureImplementation::getMilkType() {
	// server/zone/objects/creature/ai/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/ai/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/Creature.idl():  		return super.npcTemplate.getMilkType();
	return AiAgentImplementation::npcTemplate->getMilkType();
}

float CreatureImplementation::getMilk() {
	// server/zone/objects/creature/ai/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL || isEventMob())	// server/zone/objects/creature/ai/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/Creature.idl():  		return super.npcTemplate.getMilk();
	return AiAgentImplementation::npcTemplate->getMilk();
}

float CreatureImplementation::getHideMax() {
	// server/zone/objects/creature/ai/Creature.idl():  		if 
	if (AiAgentImplementation::npcTemplate == NULL || isEventMob())	// server/zone/objects/creature/ai/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/Creature.idl():  			return super.npcTemplate.getHideMax();
	if (isBaby())	// server/zone/objects/creature/ai/Creature.idl():  			return (super.npcTemplate.getHideMax() / 10);
	return (AiAgentImplementation::npcTemplate->getHideMax() / 10);

	else 	// server/zone/objects/creature/ai/Creature.idl():  			return super.npcTemplate.getHideMax();
	return AiAgentImplementation::npcTemplate->getHideMax();
}

float CreatureImplementation::getBoneMax() {
	// server/zone/objects/creature/ai/Creature.idl():  		if 
	if (AiAgentImplementation::npcTemplate == NULL || isEventMob())	// server/zone/objects/creature/ai/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/Creature.idl():  			return super.npcTemplate.getBoneMax();
	if (isBaby())	// server/zone/objects/creature/ai/Creature.idl():  			return (super.npcTemplate.getBoneMax() / 10);
	return (AiAgentImplementation::npcTemplate->getBoneMax() / 10);

	else 	// server/zone/objects/creature/ai/Creature.idl():  			return super.npcTemplate.getBoneMax();
	return AiAgentImplementation::npcTemplate->getBoneMax();
}

float CreatureImplementation::getMeatMax() {
	// server/zone/objects/creature/ai/Creature.idl():  		if 
	if (AiAgentImplementation::npcTemplate == NULL || isEventMob())	// server/zone/objects/creature/ai/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/Creature.idl():  			return super.npcTemplate.getMeatMax();
	if (isBaby())	// server/zone/objects/creature/ai/Creature.idl():  			return (super.npcTemplate.getMeatMax() / 10);
	return (AiAgentImplementation::npcTemplate->getMeatMax() / 10);

	else 	// server/zone/objects/creature/ai/Creature.idl():  			return super.npcTemplate.getMeatMax();
	return AiAgentImplementation::npcTemplate->getMeatMax();
}

int CreatureImplementation::getBaseXp() {
	// server/zone/objects/creature/ai/Creature.idl():  		if 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/ai/Creature.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/Creature.idl():  			return super.npcTemplate.getBaseXp();
	if (isBaby() || isEventMob())	// server/zone/objects/creature/ai/Creature.idl():  			return 0;
	return 0;

	else 	// server/zone/objects/creature/ai/Creature.idl():  			return super.npcTemplate.getBaseXp();
	return AiAgentImplementation::npcTemplate->getBaseXp();
}

String CreatureImplementation::getControlDeviceTemplate() {
	// server/zone/objects/creature/ai/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/ai/Creature.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/Creature.idl():  		return super.npcTemplate.getControlDeviceTemplate();
	return AiAgentImplementation::npcTemplate->getControlDeviceTemplate();
}

int CreatureImplementation::getAdultLevel() {
	// server/zone/objects/creature/ai/Creature.idl():  		if 
	if (AiAgentImplementation::petDeed.getForUpdate() != NULL){
	// server/zone/objects/creature/ai/Creature.idl():  			return super.petDeed.getLevel();
	return AiAgentImplementation::petDeed.getForUpdate()->getLevel();
}
	// server/zone/objects/creature/ai/Creature.idl():  		return 
	if (AiAgentImplementation::npcTemplate == NULL)	// server/zone/objects/creature/ai/Creature.idl():  			return super.getLevel();
	return AiAgentImplementation::getLevel();
	// server/zone/objects/creature/ai/Creature.idl():  		return super.npcTemplate.getLevel();
	return AiAgentImplementation::npcTemplate->getLevel();
}

/*
 *	CreatureAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


CreatureAdapter::CreatureAdapter(Creature* obj) : AiAgentAdapter(obj) {
}

void CreatureAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_ISCREATURE__:
		{
			
			bool _m_res = isCreature();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETDNASTATE__:
		{
			
			short _m_res = getDnaState();
			resp->insertSignedShort(_m_res);
		}
		break;
	case RPC_GETDNASAMPLECOUNT__:
		{
			
			short _m_res = getDnaSampleCount();
			resp->insertSignedShort(_m_res);
		}
		break;
	case RPC_INCDNASAMPLECOUNT__:
		{
			
			incDnaSampleCount();
			
		}
		break;
	case RPC_ISCAMOUFLAGED__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isCamouflaged(target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte selectedID = inv->getByteParameter();
			
			int _m_res = handleObjectMenuSelect(player, selectedID);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SCHEDULEDESPAWN__:
		{
			
			scheduleDespawn();
			
		}
		break;
	case RPC_HASORGANICS__:
		{
			
			bool _m_res = hasOrganics();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASMILK__:
		{
			
			bool _m_res = hasMilk();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASDNA__:
		{
			
			bool _m_res = hasDNA();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANHARVESTME__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = canHarvestMe(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANDROIDHARVESTME__CREATUREOBJECT_CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			CreatureObject* droid = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = canDroidHarvestMe(player, droid);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASSKILLTOHARVESTME__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = hasSkillToHarvestMe(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANTAMEME__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = canTameMe(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCHANCETOTAME__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			float _m_res = getChanceToTame(player);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_CANMILKME__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = canMilkMe(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANCOLLECTDNA__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = canCollectDna(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASSKILLTOSAMPLEME__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = hasSkillToSampleMe(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDALREADYHARVESTED__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			addAlreadyHarvested(player);
			
		}
		break;
	case RPC_SETMILKSTATE__SHORT_:
		{
			short milkState = inv->getSignedShortParameter();
			
			setMilkState(milkState);
			
		}
		break;
	case RPC_SETDNASTATE__SHORT_:
		{
			short dnaState = inv->getSignedShortParameter();
			
			setDnaState(dnaState);
			
		}
		break;
	case RPC_NOTIFYDESPAWN__ZONE_:
		{
			Zone* zone = static_cast<Zone*>(inv->getObjectParameter());
			
			notifyDespawn(zone);
			
		}
		break;
	case RPC_SETPETLEVEL__INT_:
		{
			int newLevel = inv->getSignedIntParameter();
			
			setPetLevel(newLevel);
			
		}
		break;
	case RPC_ISVICIOUS__:
		{
			
			bool _m_res = isVicious();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISBABY__:
		{
			
			bool _m_res = isBaby();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETBABY__BOOL_:
		{
			bool bab = inv->getBooleanParameter();
			
			setBaby(bab);
			
		}
		break;
	case RPC_GETTAME__:
		{
			
			float _m_res = getTame();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETMEATTYPE__:
		{
			
			String _m_res = getMeatType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETBONETYPE__:
		{
			
			String _m_res = getBoneType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETHIDETYPE__:
		{
			
			String _m_res = getHideType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETMILKTYPE__:
		{
			
			String _m_res = getMilkType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETMILK__:
		{
			
			float _m_res = getMilk();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHIDEMAX__:
		{
			
			float _m_res = getHideMax();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBONEMAX__:
		{
			
			float _m_res = getBoneMax();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETMEATMAX__:
		{
			
			float _m_res = getMeatMax();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBASEXP__:
		{
			
			int _m_res = getBaseXp();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCONTROLDEVICETEMPLATE__:
		{
			
			String _m_res = getControlDeviceTemplate();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISMOUNT__:
		{
			
			bool _m_res = isMount();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETADULTLEVEL__:
		{
			
			int _m_res = getAdultLevel();
			resp->insertSignedInt(_m_res);
		}
		break;
	default:
		AiAgentAdapter::invokeMethod(methid, inv);
	}
}

void CreatureAdapter::initializeTransientMembers() {
	(static_cast<Creature*>(stub))->initializeTransientMembers();
}

bool CreatureAdapter::isCreature() {
	return (static_cast<Creature*>(stub))->isCreature();
}

short CreatureAdapter::getDnaState() const {
	return (static_cast<Creature*>(stub))->getDnaState();
}

short CreatureAdapter::getDnaSampleCount() const {
	return (static_cast<Creature*>(stub))->getDnaSampleCount();
}

void CreatureAdapter::incDnaSampleCount() {
	(static_cast<Creature*>(stub))->incDnaSampleCount();
}

bool CreatureAdapter::isCamouflaged(CreatureObject* target) {
	return (static_cast<Creature*>(stub))->isCamouflaged(target);
}

int CreatureAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<Creature*>(stub))->handleObjectMenuSelect(player, selectedID);
}

void CreatureAdapter::scheduleDespawn() {
	(static_cast<Creature*>(stub))->scheduleDespawn();
}

bool CreatureAdapter::hasOrganics() {
	return (static_cast<Creature*>(stub))->hasOrganics();
}

bool CreatureAdapter::hasMilk() {
	return (static_cast<Creature*>(stub))->hasMilk();
}

bool CreatureAdapter::hasDNA() {
	return (static_cast<Creature*>(stub))->hasDNA();
}

bool CreatureAdapter::canHarvestMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->canHarvestMe(player);
}

bool CreatureAdapter::canDroidHarvestMe(CreatureObject* player, CreatureObject* droid) {
	return (static_cast<Creature*>(stub))->canDroidHarvestMe(player, droid);
}

bool CreatureAdapter::hasSkillToHarvestMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->hasSkillToHarvestMe(player);
}

bool CreatureAdapter::canTameMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->canTameMe(player);
}

float CreatureAdapter::getChanceToTame(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->getChanceToTame(player);
}

bool CreatureAdapter::canMilkMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->canMilkMe(player);
}

bool CreatureAdapter::canCollectDna(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->canCollectDna(player);
}

bool CreatureAdapter::hasSkillToSampleMe(CreatureObject* player) {
	return (static_cast<Creature*>(stub))->hasSkillToSampleMe(player);
}

void CreatureAdapter::addAlreadyHarvested(CreatureObject* player) {
	(static_cast<Creature*>(stub))->addAlreadyHarvested(player);
}

void CreatureAdapter::setMilkState(short milkState) {
	(static_cast<Creature*>(stub))->setMilkState(milkState);
}

void CreatureAdapter::setDnaState(short dnaState) {
	(static_cast<Creature*>(stub))->setDnaState(dnaState);
}

void CreatureAdapter::notifyDespawn(Zone* zone) {
	(static_cast<Creature*>(stub))->notifyDespawn(zone);
}

void CreatureAdapter::setPetLevel(int newLevel) {
	(static_cast<Creature*>(stub))->setPetLevel(newLevel);
}

bool CreatureAdapter::isVicious() {
	return (static_cast<Creature*>(stub))->isVicious();
}

bool CreatureAdapter::isBaby() {
	return (static_cast<Creature*>(stub))->isBaby();
}

void CreatureAdapter::setBaby(bool bab) {
	(static_cast<Creature*>(stub))->setBaby(bab);
}

float CreatureAdapter::getTame() {
	return (static_cast<Creature*>(stub))->getTame();
}

String CreatureAdapter::getMeatType() {
	return (static_cast<Creature*>(stub))->getMeatType();
}

String CreatureAdapter::getBoneType() {
	return (static_cast<Creature*>(stub))->getBoneType();
}

String CreatureAdapter::getHideType() {
	return (static_cast<Creature*>(stub))->getHideType();
}

String CreatureAdapter::getMilkType() {
	return (static_cast<Creature*>(stub))->getMilkType();
}

float CreatureAdapter::getMilk() {
	return (static_cast<Creature*>(stub))->getMilk();
}

float CreatureAdapter::getHideMax() {
	return (static_cast<Creature*>(stub))->getHideMax();
}

float CreatureAdapter::getBoneMax() {
	return (static_cast<Creature*>(stub))->getBoneMax();
}

float CreatureAdapter::getMeatMax() {
	return (static_cast<Creature*>(stub))->getMeatMax();
}

int CreatureAdapter::getBaseXp() {
	return (static_cast<Creature*>(stub))->getBaseXp();
}

String CreatureAdapter::getControlDeviceTemplate() {
	return (static_cast<Creature*>(stub))->getControlDeviceTemplate();
}

bool CreatureAdapter::isMount() {
	return (static_cast<Creature*>(stub))->isMount();
}

int CreatureAdapter::getAdultLevel() {
	return (static_cast<Creature*>(stub))->getAdultLevel();
}

/*
 *	CreatureHelper
 */

CreatureHelper* CreatureHelper::staticInitializer = CreatureHelper::instance();

CreatureHelper::CreatureHelper() {
	className = "Creature";

	Core::getObjectBroker()->registerClass(className, this);
}

void CreatureHelper::finalizeHelper() {
	CreatureHelper::finalize();
}

DistributedObject* CreatureHelper::instantiateObject() {
	return new Creature(DummyConstructorParameter::instance());
}

DistributedObjectServant* CreatureHelper::instantiateServant() {
	return new CreatureImplementation();
}

DistributedObjectPOD* CreatureHelper::instantiatePOD() {
	return new CreaturePOD();
}

DistributedObjectAdapter* CreatureHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new CreatureAdapter(static_cast<Creature*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	CreaturePOD
 */

CreaturePOD::~CreaturePOD() {
	finalize();
}

CreaturePOD::CreaturePOD(void) {
	_className = "Creature";
}


void CreaturePOD::writeJSON(nlohmann::json& j) {
	AiAgentPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (milkState)
		thisObject["milkState"] = milkState.value();

	if (dnaState)
		thisObject["dnaState"] = dnaState.value();

	if (dnaSampleCount)
		thisObject["dnaSampleCount"] = dnaSampleCount.value();

	if (baby)
		thisObject["baby"] = baby.value();

	j["Creature"] = thisObject;
}


void CreaturePOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = CreaturePOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int CreaturePOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = AiAgentPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (milkState) {
	_nameHashCode = 0xd784ea84; //Creature.milkState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&milkState.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dnaState) {
	_nameHashCode = 0x74d712e; //Creature.dnaState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&dnaState.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dnaSampleCount) {
	_nameHashCode = 0x55bbec19; //Creature.dnaSampleCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&dnaSampleCount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (baby) {
	_nameHashCode = 0x49505389; //Creature.baby
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&baby.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool CreaturePOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (AiAgentPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xd784ea84: //Creature.milkState
		{
			short _mnmilkState;
			TypeInfo<short >::parseFromBinaryStream(&_mnmilkState, stream);
			milkState = std::move(_mnmilkState);
		}
		return true;

	case 0x74d712e: //Creature.dnaState
		{
			short _mndnaState;
			TypeInfo<short >::parseFromBinaryStream(&_mndnaState, stream);
			dnaState = std::move(_mndnaState);
		}
		return true;

	case 0x55bbec19: //Creature.dnaSampleCount
		{
			short _mndnaSampleCount;
			TypeInfo<short >::parseFromBinaryStream(&_mndnaSampleCount, stream);
			dnaSampleCount = std::move(_mndnaSampleCount);
		}
		return true;

	case 0x49505389: //Creature.baby
		{
			bool _mnbaby;
			TypeInfo<bool >::parseFromBinaryStream(&_mnbaby, stream);
			baby = std::move(_mnbaby);
		}
		return true;

	}

	return false;
}

void CreaturePOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(CreaturePOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void CreaturePOD::writeObjectCompact(ObjectOutputStream* stream) {
	AiAgentPOD::writeObjectCompact(stream);

	TypeInfo<short >::toBinaryStream(&milkState.value(), stream);

	TypeInfo<short >::toBinaryStream(&dnaState.value(), stream);

	TypeInfo<short >::toBinaryStream(&dnaSampleCount.value(), stream);

	TypeInfo<bool >::toBinaryStream(&baby.value(), stream);


}

